---
title: 'Analysis 7: Demographic analysis'
author: "Joe Gunn"
date: "2022-09-05"
output: html_document
---

# Project: Population genomic analysis of Smallmouth Bass and Neosho Bass in the Central Interior Highlands
We investigated the extent of genomic divergence, local directional selection, and admixture between the Smallmouth Bass (<i>Micropterus dolomieu</i>) and the Neosho Bass (<i>M. velox</i>) in the Central Interior Highlands (CIH) ecoregion of central north America. Specifically, we used ddRADseq data to assessed the phylogenomic relationship between and within species, characterizing inter- and intraspecific diversity and SNPs potentially under local directional selection at the population level. Additionally, we inferred the relative timing of admxiture in Neosho Bass streams where there is known introgressive hybridization with Smallmouth Bass to understand the influence of natural, historic geographic factors on mixing (stream capture or transient flooding) vs. anthropogenic factors (i.e., non-native introductions through stocking), which is known to have occurred widely in these economically valuable species. We ultimately hoped to provide novel insights into the diversity of endemic, ecologically important and popular sport fish in the CIH.

## Specific Aim: Demographic analysis
In this analysis, we investigated the demographic history of populations found to be admixed between Smallmouth Bass and Neosho Bass based on admixture and phylogenomics (Analysis 3) and admixture mapping analysis (Analysis 5). Specifically, we used the joint site frequency spectrum (JSFS) of admixed populations within the Neosho Bass range (ELK, BAYOU, ILLI, and UPPARK) and the inferred interspecific parent population within the Smallmouth Bass range (SKIA, MISS, and WHITE) to determine the relative timing of admixture events by testing multiple demographic scenarios in a model-testing maximum likelihood framework. We inferred whether admixed populations were the results of relatively recent admixture, old admixture, or a combination of both and gleaned insights about the complexities of potential natural and anthropogenic sources of gene flow.

## Phases of analysis:
### Phase 1: Model identification and definitions
### Phase 2: Data preparation
### Phase 3: DADI analysis
### Phase 4:

## Libraries needed for analysis
```{r setup, echo = FALSE, include=FALSE}
library(readxl)
library(tidyverse)
library(cowplot)
library(tools)
```

## PHASE 1: MODEL IDENTIFICATION AND DEFINITIONS
In this phase of the analysis, we prepared to analyze the demographic history of admxiture events between Smallmouth Bass and Neosho Bass by selecting previously developed demographic models based on joint site frequency spectra. We reviewed the 'Two_Population_Pipeline' (Portik et al. 2017; Charles et al. 2018) for the software program DADI (Diffusion Analysis of Demographic Inference; Gutenkunst et al. 2009; see Phase 2 for citation information), which defines an array of possible models representing different demographic scenarios involving two potentially diverging and fusing populations.\

<b>Programs and sources needed:</b> <br><br>

Two_Population_Pipeline GitHub repo (Portik et al. 2017; Charles et al. 2018; retrieved from GitHub: https://github.com/dportik/dadi_pipeline)

<b>Citation</b>:<br>

Portik, D.M., Leache, A.D., Rivera, D., Blackburn, D.C., Rodel, M.-O., Barej, M.F., Hirschfeld, M., Burger, M., and M.K. Fujita. 2017. Evaluating mechanisms of diversification in a Guineo-Congolian forest frog using demographic model selection. Molecular Ecology 26: 5245-5263. doi: 10.1111/mec.14266

Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K., Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea, and forest islands: diversification in the African leaf-folding frog Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae). Journal of Biogeography 45: 1781-1794. doi: 10.1111/jbi.13365

### STEP 1: Populations Modeled
We modeled the demographic history of four pairs of populations, which represent admixed stream populations in the Neosho Bass native range and their corresponding Smallmouth Bass parent:

  1. Elk River (ELK) and White River (WHITE)
  2. Bayou River (BAYOU) and White River (WHITE)
  3. Upper Arkansas Tributaries (UPPARK) and the White River (WHITE)
  4. Illinois River (ILLI) and Skiatook Lake (SKIA)

### STEP 2: Models Tested
We reviewed the 'Models_2D.pdf' and chose 9 models to explicitly test for each of these four population pairs based on our knowledge of the Smallmouth Bass and Neosho system in the Central Interior Highlands. The models we tested are defined below:

  1. no_mig: Divergence with no migration
  2. sym_mig: Divdergence with continuous symmetric migration
  3. asym_mig: Divergence with continuous asymmetric migration
  4. sec_contact_sym_mig: Divergence in isolation, continuous symmetric secondary contact (recent symmetric admixture)
  5. sec_contact_asym_mig: Divergence in isolation, continuous asymmetric secondary contact (recent asymmetric admixture)
  6. anc_sym_mig: Divergence with ancient continuous symmetric migration, then isolation (ancient symmetric admixture)
  7. anc_asym_mig: Divergence with ancient continuous asymmetric migration, then isolation (ancient asymmetric admixture)
  8. sym_mig_twoepoch: Divergence with continuous symmetric migration that varies across two epochs
  9. asym_mig_twoepoch: Divergence with continuous asymmetric migration that varies across two epochs

### ----------------------- END OF PHASE 1: MODEL IDENTIFICATION AND DEFINITIONS ----------------------- ###

## PHASE 2: Data preparation
In this phase, we are preparing the fully filtered (thinned) VCF data and generating metadata population files for model testing in DADI. Since DADI assesses demographic history, we are only using neutral (non-outlier) SNP loci in all analyses. Thus, we begin with the neutral SNPs VCF generated for the species complex hierarchical level in Analysis 6 (outlier fst analysis): `outlier_fst_analysis/data/processed_vcf/02_popgen_species_complex_neutral_snps.vcf`. We further manipulate this VCF dataset into four different files, one for each pair of populations as listed above in Phase 1. 

### STEP 1: Prepare VCF input data for DADI
In this step, we are using the software VCFTools to prepare all input data for the program DADI.

#### 1a: Generate lists of samples based on population (for filtering VCF files)
In this step, we are generating text files listing samples belonging to the four two-population pairs of interest (see Phase 1 above) for DADI analysis, as inferred in Analysis 4 (population inference). These lists are then used to filter the four VCF files for downstream analyses.

##### 1a.1. Read in sample metadata and generate list of samples for the BAYOU and WHITE populations; run the Rmd chunk below:

##### Generate population file: `data/pop_files/bayou_white.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

# Get only BAYOU and White populations
bayou_white <- metadata_populations_spb %>%
  filter(population == "BAYOU" | population == "WHITE")

# Select sample id column
bayou_white <- bayou_white %>%
  select(sample_id)

# Generate text file
write_tsv(bayou_white, 
          file = "data/filtering_data/bayou_white.txt", 
          col_names = FALSE)
```

##### 1a.2. Read in sample metadata and generate list of samples for the ELK and WHITE populations; run the Rmd chunk below:

##### Generate population file: `data/pop_files/elk_white.txt`
```{r}
# Get only BAYOU and White populations
elk_white <- metadata_populations_spb %>%
  filter(population == "ELK" | population == "WHITE")

# Select sample id column
elk_white <- elk_white %>%
  select(sample_id)

# Generate text file
write_tsv(elk_white, 
          file = "data/filtering_data/elk_white.txt", 
          col_names = FALSE)
```

##### 1a.3. Read in sample metadata and generate list of samples for the ILLI and SKIA populations; run the Rmd chunk below:

##### Generate population file: `data/pop_files/illi_skia.txt`
```{r}
# Get only BAYOU and White populations
illi_skia <- metadata_populations_spb %>%
  filter(population == "ILLI" | population == "SKIA")

# Select sample id column
illi_skia <- illi_skia %>%
  select(sample_id)

# Generate text file
write_tsv(illi_skia, 
          file = "data/filtering_data/illi_skia.txt", 
          col_names = FALSE)
```

##### 1a.2. Read in sample metadata and generate list of samples for the UPPARK and WHITE populations; run the Rmd chunk below:

##### Generate population file: `data/pop_files/uppark_white.txt`
```{r}
# Get only BAYOU and White populations
uppark_white <- metadata_populations_spb %>%
  filter(population == "UPPARK" | population == "WHITE")

# Select sample id column
uppark_white <- uppark_white %>%
  select(sample_id)

# Generate text file
write_tsv(uppark_white, 
          file = "data/filtering_data/uppark_white.txt", 
          col_names = FALSE)
```

#### 1b: Filter VCF data to generate datasets for each pair of populations

##### 1b.1. Generate a general bash shell script header for all VCF filtering steps commands
In this step, we are generating a universal bash shell script to run all filtering commands in VCFTOOLS (See Phase 1 in Analysis 2 for programs needed and citation information). Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all VCFTOOLS code is called "vcftools.sh".

###### 1b.1.1. Copy and paste the code below in a new shell script file:

##### Generate VCFTOOLS bash shell script: `code/shell_scripts/vcftools.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J filter_admixed  # give the job a custom name
#SBATCH -o filtering_missing.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

## UNCOMMENT LINES STARTING HERE 

## Load VCFtools module
# module load rss/rss-2020
# module load vcftools/vcftools-v0.1.14
```

##### 1b.2. Filter VCF to retain BAYOU and WHITE population samples; copy and paste the code below in the shell file generated in Step 1b.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 01: keep BAYOU and WHITE samples
# vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex_neutral_snps.vcf --keep ../../data/filtering_data/bayou_white.txt --recode --recode-INFO-all --out ../../data/processed_vcf/01_popgen_bayou_white
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/01_popgen_bayou_white.vcf`.

##### 1b.3. Filter VCF to retain ELK and WHITE population samples; copy and paste the code below in the shell file generated in Step 1b.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 02: keep ELK and WHITE population samples
# vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex_neutral_snps.vcf --keep ../../data/filtering_data/elk_white.txt --recode --recode-INFO-all --out ../../data/processed_vcf/02_popgen_elk_white
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/02_popgen_elk_white.vcf`.

##### 1b.4. Filter VCF to retain ILLI and SKIA population samples; copy and paste the code below in the shell file generated in Step 1b.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 03: keep ILLI and SKIA population samples
# vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex_neutral_snps.vcf --keep ../../data/filtering_data/illi_skia.txt --recode --recode-INFO-all --out ../../data/processed_vcf/03_popgen_illi_skia
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/03_popgen_illi_skia.vcf`.

##### 1b.5. Filter VCF to retain UPPARK and WHITE population samples; copy and paste the code below in the shell file generated in Step 1b.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 04: keep UPPARK and WHITE population samples
# vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex_neutral_snps.vcf --keep ../../data/filtering_data/uppark_white.txt --recode --recode-INFO-all --out ../../data/processed_vcf/04_popgen_uppark_white
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/04_popgen_uppark_white.vcf`.
  
### ----------------------- END OF PHASE 2: DATA PREPARATION ----------------------- ###

## PHASE 3: DADI ANALYSIS
In this phase of the analysis, we are conducting demographic analysis of admixture in our four population pairs using folded joint site frequency spectra for neutral SNP loci in teh software program DADI. Specifically, we are comparing 9 distinct, previously developed models of demographic history (see Phase 1 for models run and corresponding definitions). DADI employs maximum likelihood model testing, wherein the likelihood of a given model is determined based on residuals calculated from comparing the empirical data to theoretical data based on population genetic theory. All model likelihoods are then compared to determine the best-fitting model (the model with the smallest average residual differences between empirical and theoretical data).

DADI is written in Python and is compatible with Python Version 3. Below, we detail the steps taken to install DADI in a Python Anaconda virtual environment. We specifically used the compact version of Anaconda, Miniconda3, which only includes code for Conda, Python, and dependencies, rather than all of the software built into Anaconda (Anaconda is too large for our computing cluster disk quota). We then accessed all previously developed python scripts for running DADI on GitHub (see Phase 1 above for link to the GitHub code repository). 

All analyses conducted by calling commands in bash shell scripts were performed on the Lewis high-performance computing cluster at the University of Missouri <br>

<b>Programs needed</b>: <br><br>

DADI v.3.1.6 (Gutenkunst et al. 2009) <br>

<b>Citation</b>:<br>

Gutenkunst, R.N., Hernandez, R.D., Williamson, S.D., Bustamante, C.D. (2009). Inferring the joint demographic history of multiple populations from multidimensional SNP frequency data. PLoS Genetics 5: e1000695. doi:/10.1371/journal.pgen.1000695

### STEP 1: Load in Miniconda software and set up a Python virtual environment with DADI installed.
In this step, we are setting up a virtual Python working environment for running all Python analyses; we are using the software package Miniconda for Python v.3.7.

#### 1a: Generate a general bash shell script header for running all DADI commands
In this step, we are generating a universal bash shell script to run all commands in DADI. Here, we only generate the annotated header for the shell script, including loading in Miniconda3. In subsequent steps, we include and provide details on each step of the analysis and the associated lines of code in Rmd chunks. The shell script for running all DADI code is called "dadi.sh".

##### 1a.1. Copy and paste the code below in a new shell script file:

##### Generate DADI bash shell script: `code/shell_scripts/dadi.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J ILLI_SKIA  # give the job a custom name
#SBATCH -o ILLI_SKIA-%j.out  # give the job output a custom name
#SBATCH -t 2-00:00  # two day time limit
#SBATCH --mem 100G

#SBATCH -N 1  # number of nodes
#SBATCH -n 14  # number of cores (AKA tasks)

# UNCOMMENT STARTING HERE

## Commands here run only on the first core
# module load miniconda3
```

##### 1a.1. Create a Python virtual environment to run all DADI analysis, and install the DADI software library in this environment.

###### 1a.1.1. Create a new virtual environment; copy and paste the code below on the command line:

##### Command line code for generating virutal environment: `dadi_env`. UNCOMMENT this code in the shell script:
```{bash}
# conda create --name dadi_env
```

###### 1a.1.2. Activate the new conda environment; copy and past the code below on the command line:

##### Command line code for activating the `dadi_env` virtual environment. UNCOMMENT this code in the shell script:
```{bash}
# conda activate dadi_env
```

###### 1a.1.3. Install DADI; copy and past the code below on the command line:

##### Command line code for installing DADI. UNCOMMENT this code in the shell script:
```{bash}
# conda install -c conda-forge dadi
```

### STEP 2: Generate DADI input files for model testing.
In this step, we are modifying previously developed Python scripts for analyzing multiple demographic models with DADI to run on each of our four population pairs.

#### 2a: Clone and clean the 'dadi_pipeline' GitHub repository.

##### 2a.1. Navigate to the `code/` directory and run the command: `git clone https://github.com/dportik/dadi_pipeline.git`

##### 2a.2. Remove unnecessary directories and files. 
For our analysis, we are only interested in the 'Two_Population_Pipeline'. We copied all required, generalized scripts to run this pipeline and placed them into renamed folders within the `/code` directory.

###### 2a.2.1. Create a new directory for base scripts, and copy and paste all base scripts (unmodified) in the directory: `code/base_scripts`
The following scripts were copied and placed in the `/base_scripts` directory: <br>

1. README.md <br>
3. dad_Run_2D_Set.py <br>
4. Models_2D.py <br>
5. Optimize_Functions.py <br>
6. Summarize_Outputs.py <br>

Of the original scripts, 'dadi_Run_Optimizations.py' (not listed above) was removed, because it is a general use version of the 'dadi_Run_2D_Set.py' script. We modified the 'dadi_Run_2D_Set.py' for all downstream analyses.

###### 2a.2.2. Create a new directory for analysis scripts (modified for each population pair), and copy and paste the 'dadi_Run_2D_Set.py' file in the directory: `code/analysis_scripts`.

###### 2a.2.3. Create four copies of the  'dadi_Run_2D_Set.py' script and rename for each population pair.
After this step, there should be four distinct script files in the `/analysis_scripts` directory: <br>

1. uppark_white.py <br>
2. illi_skia.py <br>
3. elk_white.py <br>
4. bayou_white.py <br>

###### 2a.2.4. Create a new directory for plotting scripts (unmodified) in the directory: `code/plotting_scripts`
The following scripts were copied and placed in the `/base_scripts` directory: <br>

1. README.md <br>
3. Plotting_Functions.py <br>
4. Make_Plots.py <br>

#### 2b: Modify DADI 2D Set input files to run for each analysis.
In this step, we are modifying each of the four two-population pair analysis scripts to run each analysis. Specifically, we included the input .vcf and population metadata (.txt; see Phase 2 above) for each population pair and input the 9 specific models to test from the 'Models_2D.py' script.

In each analysis, we project the data down to the exact number of alleles per population, which is equal to the number of individuals*2 since each individual is diploid, meaning that there are 2<i>N</i> alleles:

[BAYOU (<i>N</i> = 7), WHITE (<i>N</i> = 10)] = [14, 20]
[ELK (<i>N</i> = 6), WHITE (<i>N</i> = 10)] = [12, 20]
[ILLI (<i>N</i> = 9), SKIA (<i>N</i>  5)] = [18, 10]
[UPPARK (<i>N</i> = 18), WHITE (<i>N</i> = 10)] = [36, 20]

We run a four round perturbed optimization algorithm (built into the 'Two_Population_Pipeline' on each dataset. In the first round, the optimization algorithm employs a set of random starting settings and outputs likelihood estimates over a user-defined number of replicates over a user-defined number of iterations. Then, in each subsequent round (four rounds total), the parameter estimates of the model's best-scoring replicate are used to define the settings for the next round (making it 'perturbed" each round). We ran the optimization procedure with the following specs:

<b>Optimization settings</b>: <br><br>

Round1: 10 replicates, maxiter = 3, fold = 3 <br>
Round2: 20 replicates, maxiter = 5, fold = 2 <br>
Round3: 30 replicates, maxiter = 10, fold = 2 <br>
Round4: 40 replicates, maxiter = 15, fold = 1 <br>

We copied and pasted the comands to run each of our 9 chosen models in each two-population analysis script, which calls the 'Models.py' python script to run the appropriate models.

##### 2b.1. Modify the 'bayou_white.py' script: the script should be as follows:

##### bayou_white.py
```{r, includ = FASLE}
'''
Usage: python dadi_Run_2D_Set.py

This is a modified version of the 'dadi_Run_Optimizations.py' script in which
we run optimizations for 2D comparisons for a large set of models that have been
made available as part of published works. These models are stored in the
Models_2D.py script, and will be called directly here. The user can delete or
comment out models to analyze a subset of the models available. 

This script must be in the same working directory as Optimize_Functions.py, which
contains all the functions necessary, as well as the  Models_2D.py script, which
has all the model definitions.


General workflow:
 The optimization routine runs a user-defined number of rounds, each with a user-defined
 or predefined number of replicates. The starting parameters are initially random, but after
 each round is complete the parameters of the best scoring replicate from that round are
 used to generate perturbed starting parameters for the replicates of the subsequent round.
 The arguments controlling steps of the optimization algorithm (maxiter) and perturbation
 of starting parameters (fold) can be supplied by the user for more control across rounds.
 The user can also supply their own set of initial parameters, or set custom bounds on the
 parameters (upper_bound and lower_bound) to meet specific model needs. This flexibility
 should allow these scripts to be generally useful for model-fitting with any data set.

 
Outputs:
 For each model run, there will be a log file showing the optimization steps per replicate
 and a summary file that has all the important information. Here is an example of the output
 from a summary file, which will be in tab-delimited format:
 
 Model	Replicate	log-likelihood	AIC	chi-squared	theta	optimized_params(nu1, nu2, m, T)
 sym_mig	Round_1_Replicate_1	-1684.99	3377.98	14628.4	383.04	0.2356,0.5311,0.8302,0.182
 sym_mig	Round_1_Replicate_2	-2255.47	4518.94	68948.93	478.71	0.3972,0.2322,2.6093,0.611
 sym_mig	Round_1_Replicate_3	-2837.96	5683.92	231032.51	718.25	0.1078,0.3932,4.2544,2.9936
 sym_mig	Round_1_Replicate_4	-4262.29	8532.58	8907386.55	288.05	0.3689,0.8892,3.0951,2.8496
 sym_mig	Round_1_Replicate_5	-4474.86	8957.72	13029301.84	188.94	2.9248,1.9986,0.2484,0.3688


Notes/Caveats:
 The likelihood and AIC returned represent the true likelihood only if the SNPs are
 unlinked across loci. For ddRADseq data where a single SNP is selected per locus, this
 is true, but if SNPs are linked across loci then the likelihood is actually a composite
 likelihood and using something like AIC is no longer appropriate for model comparisons.
 See the discussion group for more information on this subject. 

Citations:
 If you use these scripts or the main diversification models for your work, please
 cite the following publication:
    Portik, D.M., Leache, A.D., Rivera, D., Blackburn, D.C., Rodel, M.-O.,
    Barej, M.F., Hirschfeld, M., Burger, M., and M.K. Fujita. 2017.
    Evaluating mechanisms of diversification in a Guineo-Congolian forest
    frog using demographic model selection. Molecular Ecology 26: 5245-5263.
    doi: 10.1111/mec.14266
 
 If you use the additional diversification models or the island models set please cite 
 the following publication:
    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365
        
 If you are interesting in contributing your models to this workflow, please email me!

-------------------------
Written for Python 2.7 and 3.7
Python modules required:
-Numpy
-Scipy
-dadi
-------------------------

Daniel Portik
daniel.portik@gmail.com
https://github.com/dportik
Updated September 2019
'''

import sys
import os
import numpy
import dadi
import pylab
from datetime import datetime
import Optimize_Functions
import Models_2D


#===========================================================================
# Import data to create joint-site frequency spectrum
#===========================================================================

#**************

dd = dadi.Misc.make_data_dict_vcf("/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/vcfs_for_dadi/dadi_bayou_white_neutral.vcf", "/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/dadi_pops/dadi_bayou_white.txt")


#**************
#pop_ids is a list which should match the populations headers of your SNPs file columns
pop_ids=["BAYOU", "WHITE"]

#**************
#projection sizes, in ALLELES not individuals
proj = [14, 20]

fs = dadi.Spectrum.from_data_dict(dd, pop_ids=pop_ids, projections = proj, polarized = False)


#print some useful information about the afs or jsfs
print("\n\n============================================================================")
print("\nData for site frequency spectrum:\n")
print("Projection: {}".format(proj))
print("Sample sizes: {}".format(fs.sample_sizes))
print("Sum of SFS: {}".format(numpy.around(fs.S(), 2)))
print("\n============================================================================\n")

#================================================================================
# Calling external 2D models from the Models_2D.py script
#================================================================================
'''
 We will use a function from the Optimize_Functions.py script for our optimization routines:
 
 Optimize_Routine(fs, pts, outfile, model_name, func, rounds, param_number, fs_folded=True, 
                        reps=None, maxiters=None, folds=None, in_params=None, 
                        in_upper=None, in_lower=None, param_labels=None, optimizer="log_fmin")
 
   Mandatory Arguments =
    fs:  spectrum object name
    pts: grid size for extrapolation, list of three values
    outfile:  prefix for output naming
    model_name: a label to help label the output files; ex. "no_mig"
    func: access the model function from within 'moments_Run_Optimizations.py' or from a separate python model script, 
          ex. after importing Models_2D, calling Models_2D.no_mig
    rounds: number of optimization rounds to perform
    param_number: number of parameters in the model selected (can count in params line for the model)
    fs_folded: A Boolean value (True or False) indicating whether the empirical fs is folded (True) or not (False).

   Optional Arguments =
     reps: a list of integers controlling the number of replicates in each of the optimization rounds
     maxiters: a list of integers controlling the maxiter argument in each of the optimization rounds
     folds: a list of integers controlling the fold argument when perturbing input parameter values
     in_params: a list of parameter values 
     in_upper: a list of upper bound values
     in_lower: a list of lower bound values
     param_labels: list of labels for parameters that will be written to the output file to keep track of their order
     optimizer: a string, to select the optimizer. Choices include: "log" (BFGS method), "log_lbfgsb" (L-BFGS-B method), 
                "log_fmin" (Nelder-Mead method), and "log_powell" (Powell's method).

Below, I give all the necessary information to call each model available in the
Models_2D.py script. I have set the optimization routine to be the same for each
model using the optional lists below, which are included as optional arguments for
each model. This particular configuration will run 4 rounds as follows:
Round1 - 10 replicates, maxiter = 3, fold = 3
Round2 - 20 replicates, maxiter = 5, fold = 2
Round3 - 30 replicates, maxiter = 10, fold = 2
Round4 - 40 replicates, maxiter = 15, fold = 1

If this script was run as is, each model would be called and optimized sequentially;
this could take a very long time. For your actual analyses, I strongly recommend
creating multiple scripts with only a few models each and running them
independently. It is also not a good idea to mix models from the Diversification Set
and the Island Set, as each was meant to be mutually exclusive.

'''


#create a prefix based on the population names to label the output files
#ex. Pop1_Pop2
prefix = "_".join(pop_ids)

#**************
#make sure to define your extrapolation grid size (based on your projections)
pts = [30,40,50]

#**************
#Set the number of rounds here
rounds = 4

#define the lists for optional arguments
#you can change these to alter the settings of the optimization routine
reps = [10,20,30,40]
maxiters = [3,5,10,15]
folds = [3,2,2,1]

#**************
#Indicate whether your frequency spectrum object is folded (True) or unfolded (False)
fs_folded = True


'''
Diversification Model Set

This first set of models come from the following publication:

    Portik, D.M., Leache, A.D., Rivera, D., Blackburn, D.C., Rodel, M.-O.,
    Barej, M.F., Hirschfeld, M., Burger, M., and M.K.Fujita. 2017.
    Evaluating mechanisms of diversification in a Guineo-Congolian forest
    frog using demographic model selection. Molecular Ecology 26: 5245-5263.
    doi: 10.1111/mec.14266

'''

# Split into two populations, no migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "no_mig", Models_2D.no_mig, rounds, 3, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, T")


# Split into two populations, with continuous symmetric migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sym_mig", Models_2D.sym_mig, rounds, 4, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T")


# Split into two populations, with continuous asymmetric migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "asym_mig", Models_2D.asym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T")


# Split with continuous symmetric migration, followed by isolation.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "anc_sym_mig", Models_2D.anc_sym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T1, T2")


# Split with continuous asymmetric migration, followed by isolation.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "anc_asym_mig", Models_2D.anc_asym_mig, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T1, T2")


# Split with no gene flow, followed by period of continuous symmetrical gene flow.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sec_contact_sym_mig", Models_2D.sec_contact_sym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T1, T2")


# Split with no gene flow, followed by period of continuous asymmetrical gene flow.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sec_contact_asym_mig", Models_2D.sec_contact_asym_mig, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T1, T2")



'''
The following 6 models were added to the Diversification Model Set by:

    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365
'''
# Split into two populations, with continuous symmetric migration, rate varying across two epochs.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sym_mig_twoepoch", Models_2D.sym_mig_twoepoch, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m1, m2, T1, T2")


# Split into two populations, with continuous asymmetric migration, rate varying across two epochs.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "asym_mig_twoepoch", Models_2D.asym_mig_twoepoch, rounds, 8, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12a, m21a, m12b, m21b, T1, T2")




'''
Island Diversification Model Set

This model set comes from the following publication:

    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365

For all the following models, pop2 is assumed to be the 'island' population and pop1 is the 
mainland population. Their sizes are based on the parameter s, where 0 < s < 1. Here, s 
represents the fraction of Nref that enters a population, with pop2 = s, and pop1 = 1-s. 
When these models are called the upper bound on s is set to 0.5, such that the island pop 
(pop2) can never contain >50% of the ancestral population. The values of nu1 and nu2 are 
therefore 1-s and s, unless there is a size change event. 

The 'vicariance' models involve no population size change, whereas the 'founder' event 
models always enforce exponential growth in pop2 (the island population).

NOTE: For these models, we must include an optional upper bound argument in
order to constrain the parameter 's' to be no more than 0.5, and we must also
supply a starting parameter list to keep the initial value of s within these bounds. 
For models with discrete admixture events, we need to constrain 'f' to between 0-1, 
and do so in a similar fashion.

'''
```

##### 2b.2. Modify the 'elk_white.py' script: the script should be as follows:

##### elk_white.py
```{r, include = FALSE}
'''
Usage: python dadi_Run_2D_Set.py

This is a modified version of the 'dadi_Run_Optimizations.py' script in which
we run optimizations for 2D comparisons for a large set of models that have been
made available as part of published works. These models are stored in the
Models_2D.py script, and will be called directly here. The user can delete or
comment out models to analyze a subset of the models available. 

This script must be in the same working directory as Optimize_Functions.py, which
contains all the functions necessary, as well as the  Models_2D.py script, which
has all the model definitions.


General workflow:
 The optimization routine runs a user-defined number of rounds, each with a user-defined
 or predefined number of replicates. The starting parameters are initially random, but after
 each round is complete the parameters of the best scoring replicate from that round are
 used to generate perturbed starting parameters for the replicates of the subsequent round.
 The arguments controlling steps of the optimization algorithm (maxiter) and perturbation
 of starting parameters (fold) can be supplied by the user for more control across rounds.
 The user can also supply their own set of initial parameters, or set custom bounds on the
 parameters (upper_bound and lower_bound) to meet specific model needs. This flexibility
 should allow these scripts to be generally useful for model-fitting with any data set.

 
Outputs:
 For each model run, there will be a log file showing the optimization steps per replicate
 and a summary file that has all the important information. Here is an example of the output
 from a summary file, which will be in tab-delimited format:
 
 Model	Replicate	log-likelihood	AIC	chi-squared	theta	optimized_params(nu1, nu2, m, T)
 sym_mig	Round_1_Replicate_1	-1684.99	3377.98	14628.4	383.04	0.2356,0.5311,0.8302,0.182
 sym_mig	Round_1_Replicate_2	-2255.47	4518.94	68948.93	478.71	0.3972,0.2322,2.6093,0.611
 sym_mig	Round_1_Replicate_3	-2837.96	5683.92	231032.51	718.25	0.1078,0.3932,4.2544,2.9936
 sym_mig	Round_1_Replicate_4	-4262.29	8532.58	8907386.55	288.05	0.3689,0.8892,3.0951,2.8496
 sym_mig	Round_1_Replicate_5	-4474.86	8957.72	13029301.84	188.94	2.9248,1.9986,0.2484,0.3688


Notes/Caveats:
 The likelihood and AIC returned represent the true likelihood only if the SNPs are
 unlinked across loci. For ddRADseq data where a single SNP is selected per locus, this
 is true, but if SNPs are linked across loci then the likelihood is actually a composite
 likelihood and using something like AIC is no longer appropriate for model comparisons.
 See the discussion group for more information on this subject. 

Citations:
 If you use these scripts or the main diversification models for your work, please
 cite the following publication:
    Portik, D.M., Leache, A.D., Rivera, D., Blackburn, D.C., Rodel, M.-O.,
    Barej, M.F., Hirschfeld, M., Burger, M., and M.K. Fujita. 2017.
    Evaluating mechanisms of diversification in a Guineo-Congolian forest
    frog using demographic model selection. Molecular Ecology 26: 5245-5263.
    doi: 10.1111/mec.14266
 
 If you use the additional diversification models or the island models set please cite 
 the following publication:
    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365
        
 If you are interesting in contributing your models to this workflow, please email me!

-------------------------
Written for Python 2.7 and 3.7
Python modules required:
-Numpy
-Scipy
-dadi
-------------------------

Daniel Portik
daniel.portik@gmail.com
https://github.com/dportik
Updated September 2019
'''

import sys
import os
import numpy
import dadi
import pylab
from datetime import datetime
import Optimize_Functions
import Models_2D


#===========================================================================
# Import data to create joint-site frequency spectrum
#===========================================================================

#**************
#Create python dictionary from snps file

dd = dadi.Misc.make_data_dict_vcf("/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/vcfs_for_dadi/dadi_elk_white_neutral.vcf", "/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/dadi_pops/dadi_elk_white.txt")


#**************
#pop_ids is a list which should match the populations headers of your SNPs file columns
pop_ids=["ELK", "WHITE"]

#**************
#projection sizes, in ALLELES not individuals
proj = [12, 20]


fs = dadi.Spectrum.from_data_dict(dd, pop_ids=pop_ids, projections = proj, polarized = False)


#print some useful information about the afs or jsfs
print("\n\n============================================================================")
print("\nData for site frequency spectrum:\n")
print("Projection: {}".format(proj))
print("Sample sizes: {}".format(fs.sample_sizes))
print("Sum of SFS: {}".format(numpy.around(fs.S(), 2)))
print("\n============================================================================\n")

#================================================================================
# Calling external 2D models from the Models_2D.py script
#================================================================================
'''
 We will use a function from the Optimize_Functions.py script for our optimization routines:
 
 Optimize_Routine(fs, pts, outfile, model_name, func, rounds, param_number, fs_folded=True, 
                        reps=None, maxiters=None, folds=None, in_params=None, 
                        in_upper=None, in_lower=None, param_labels=None, optimizer="log_fmin")
 
   Mandatory Arguments =
    fs:  spectrum object name
    pts: grid size for extrapolation, list of three values
    outfile:  prefix for output naming
    model_name: a label to help label the output files; ex. "no_mig"
    func: access the model function from within 'moments_Run_Optimizations.py' or from a separate python model script, 
          ex. after importing Models_2D, calling Models_2D.no_mig
    rounds: number of optimization rounds to perform
    param_number: number of parameters in the model selected (can count in params line for the model)
    fs_folded: A Boolean value (True or False) indicating whether the empirical fs is folded (True) or not (False).

   Optional Arguments =
     reps: a list of integers controlling the number of replicates in each of the optimization rounds
     maxiters: a list of integers controlling the maxiter argument in each of the optimization rounds
     folds: a list of integers controlling the fold argument when perturbing input parameter values
     in_params: a list of parameter values 
     in_upper: a list of upper bound values
     in_lower: a list of lower bound values
     param_labels: list of labels for parameters that will be written to the output file to keep track of their order
     optimizer: a string, to select the optimizer. Choices include: "log" (BFGS method), "log_lbfgsb" (L-BFGS-B method), 
                "log_fmin" (Nelder-Mead method), and "log_powell" (Powell's method).

Below, I give all the necessary information to call each model available in the
Models_2D.py script. I have set the optimization routine to be the same for each
model using the optional lists below, which are included as optional arguments for
each model. This particular configuration will run 4 rounds as follows:
Round1 - 10 replicates, maxiter = 3, fold = 3
Round2 - 20 replicates, maxiter = 5, fold = 2
Round3 - 30 replicates, maxiter = 10, fold = 2
Round4 - 40 replicates, maxiter = 15, fold = 1

If this script was run as is, each model would be called and optimized sequentially;
this could take a very long time. For your actual analyses, I strongly recommend
creating multiple scripts with only a few models each and running them
independently. It is also not a good idea to mix models from the Diversification Set
and the Island Set, as each was meant to be mutually exclusive.

'''


#create a prefix based on the population names to label the output files
#ex. Pop1_Pop2
prefix = "_".join(pop_ids)

#**************
#make sure to define your extrapolation grid size (based on your projections)
pts = [30,40,50]

#**************
#Set the number of rounds here
rounds = 4

#define the lists for optional arguments
#you can change these to alter the settings of the optimization routine
reps = [10,20,30,40]
maxiters = [3,5,10,15]
folds = [3,2,2,1]

#**************
#Indicate whether your frequency spectrum object is folded (True) or unfolded (False)
fs_folded = True


'''
Diversification Model Set

This first set of models come from the following publication:

    Portik, D.M., Leache, A.D., Rivera, D., Blackburn, D.C., Rodel, M.-O.,
    Barej, M.F., Hirschfeld, M., Burger, M., and M.K.Fujita. 2017.
    Evaluating mechanisms of diversification in a Guineo-Congolian forest
    frog using demographic model selection. Molecular Ecology 26: 5245-5263.
    doi: 10.1111/mec.14266

'''

# Split into two populations, no migration.
#Optimize_Functions.Optimize_Routine(fs, pts, prefix, "no_mig", Models_2D.no_mig, rounds, 3, fs_folded=fs_folded,
                                    #    reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, T")


# Split into two populations, with continuous symmetric migration.
#Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sym_mig", Models_2D.sym_mig, rounds, 4, fs_folded=fs_folded,
                                    #    reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T")


# Split into two populations, with continuous asymmetric migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "asym_mig", Models_2D.asym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T")


# Split with continuous symmetric migration, followed by isolation.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "anc_sym_mig", Models_2D.anc_sym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T1, T2")


# Split with continuous asymmetric migration, followed by isolation.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "anc_asym_mig", Models_2D.anc_asym_mig, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T1, T2")


# Split with no gene flow, followed by period of continuous symmetrical gene flow.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sec_contact_sym_mig", Models_2D.sec_contact_sym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T1, T2")


# Split with no gene flow, followed by period of continuous asymmetrical gene flow.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sec_contact_asym_mig", Models_2D.sec_contact_asym_mig, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T1, T2")



'''
The following 6 models were added to the Diversification Model Set by:

    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365
'''
# Split into two populations, with continuous symmetric migration, rate varying across two epochs.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sym_mig_twoepoch", Models_2D.sym_mig_twoepoch, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m1, m2, T1, T2")


# Split into two populations, with continuous asymmetric migration, rate varying across two epochs.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "asym_mig_twoepoch", Models_2D.asym_mig_twoepoch, rounds, 8, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12a, m21a, m12b, m21b, T1, T2")




'''
Island Diversification Model Set

This model set comes from the following publication:

    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365

For all the following models, pop2 is assumed to be the 'island' population and pop1 is the 
mainland population. Their sizes are based on the parameter s, where 0 < s < 1. Here, s 
represents the fraction of Nref that enters a population, with pop2 = s, and pop1 = 1-s. 
When these models are called the upper bound on s is set to 0.5, such that the island pop 
(pop2) can never contain >50% of the ancestral population. The values of nu1 and nu2 are 
therefore 1-s and s, unless there is a size change event. 

The 'vicariance' models involve no population size change, whereas the 'founder' event 
models always enforce exponential growth in pop2 (the island population).

NOTE: For these models, we must include an optional upper bound argument in
order to constrain the parameter 's' to be no more than 0.5, and we must also
supply a starting parameter list to keep the initial value of s within these bounds. 
For models with discrete admixture events, we need to constrain 'f' to between 0-1, 
and do so in a similar fashion.
'''
```

##### 2b.3. Modify the 'illi_skia.py' script: the script should be as follows:

##### illi_skia.py
```{r, include = FALSE}
'''
Usage: python dadi_Run_2D_Set.py

This is a modified version of the 'dadi_Run_Optimizations.py' script in which
we run optimizations for 2D comparisons for a large set of models that have been
made available as part of published works. These models are stored in the
Models_2D.py script, and will be called directly here. The user can delete or
comment out models to analyze a subset of the models available. 

This script must be in the same working directory as Optimize_Functions.py, which
contains all the functions necessary, as well as the  Models_2D.py script, which
has all the model definitions.


General workflow:
 The optimization routine runs a user-defined number of rounds, each with a user-defined
 or predefined number of replicates. The starting parameters are initially random, but after
 each round is complete the parameters of the best scoring replicate from that round are
 used to generate perturbed starting parameters for the replicates of the subsequent round.
 The arguments controlling steps of the optimization algorithm (maxiter) and perturbation
 of starting parameters (fold) can be supplied by the user for more control across rounds.
 The user can also supply their own set of initial parameters, or set custom bounds on the
 parameters (upper_bound and lower_bound) to meet specific model needs. This flexibility
 should allow these scripts to be generally useful for model-fitting with any data set.

 
Outputs:
 For each model run, there will be a log file showing the optimization steps per replicate
 and a summary file that has all the important information. Here is an example of the output
 from a summary file, which will be in tab-delimited format:
 
 Model	Replicate	log-likelihood	AIC	chi-squared	theta	optimized_params(nu1, nu2, m, T)
 sym_mig	Round_1_Replicate_1	-1684.99	3377.98	14628.4	383.04	0.2356,0.5311,0.8302,0.182
 sym_mig	Round_1_Replicate_2	-2255.47	4518.94	68948.93	478.71	0.3972,0.2322,2.6093,0.611
 sym_mig	Round_1_Replicate_3	-2837.96	5683.92	231032.51	718.25	0.1078,0.3932,4.2544,2.9936
 sym_mig	Round_1_Replicate_4	-4262.29	8532.58	8907386.55	288.05	0.3689,0.8892,3.0951,2.8496
 sym_mig	Round_1_Replicate_5	-4474.86	8957.72	13029301.84	188.94	2.9248,1.9986,0.2484,0.3688


Notes/Caveats:
 The likelihood and AIC returned represent the true likelihood only if the SNPs are
 unlinked across loci. For ddRADseq data where a single SNP is selected per locus, this
 is true, but if SNPs are linked across loci then the likelihood is actually a composite
 likelihood and using something like AIC is no longer appropriate for model comparisons.
 See the discussion group for more information on this subject. 

Citations:
 If you use these scripts or the main diversification models for your work, please
 cite the following publication:
    Portik, D.M., Leache, A.D., Rivera, D., Blackburn, D.C., Rodel, M.-O.,
    Barej, M.F., Hirschfeld, M., Burger, M., and M.K. Fujita. 2017.
    Evaluating mechanisms of diversification in a Guineo-Congolian forest
    frog using demographic model selection. Molecular Ecology 26: 5245-5263.
    doi: 10.1111/mec.14266
 
 If you use the additional diversification models or the island models set please cite 
 the following publication:
    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365
        
 If you are interesting in contributing your models to this workflow, please email me!

-------------------------
Written for Python 2.7 and 3.7
Python modules required:
-Numpy
-Scipy
-dadi
-------------------------

Daniel Portik
daniel.portik@gmail.com
https://github.com/dportik
Updated September 2019
'''

import sys
import os
import numpy
import dadi
import pylab
from datetime import datetime
import Optimize_Functions
import Models_2D


#===========================================================================
# Import data to create joint-site frequency spectrum
#===========================================================================

#**************
#snps = "/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/dadi_input/elk_white_dadi.fs"

#Create python dictionary from snps file
#dd = dadi.Misc.make_data_dict(snps)
dd = dadi.Misc.make_data_dict_vcf("/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/vcfs_for_dadi/dadi_illi_skia_neutral.vcf", "/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/dadi_pops/dadi_illi_skia.txt")


#**************
#pop_ids is a list which should match the populations headers of your SNPs file columns
pop_ids=["ILLI", "SKIA"]

#**************
#projection sizes, in ALLELES not individuals
proj = [18, 10]

#Convert this dictionary into folded AFS object
#[polarized = False] creates folded spectrum object

#fs = "/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/dadi_input/elk_white_dadi.fs"
fs = dadi.Spectrum.from_data_dict(dd, pop_ids=pop_ids, projections = proj, polarized = False)
#fs = dadi.Spectrum.from_data_dict(dd, pop_ids=pop_ids, polarized = False)

#print some useful information about the afs or jsfs
print("\n\n============================================================================")
print("\nData for site frequency spectrum:\n")
print("Projection: {}".format(proj))
print("Sample sizes: {}".format(fs.sample_sizes))
print("Sum of SFS: {}".format(numpy.around(fs.S(), 2)))
print("\n============================================================================\n")

#================================================================================
# Calling external 2D models from the Models_2D.py script
#================================================================================
'''
 We will use a function from the Optimize_Functions.py script for our optimization routines:
 
 Optimize_Routine(fs, pts, outfile, model_name, func, rounds, param_number, fs_folded=True, 
                        reps=None, maxiters=None, folds=None, in_params=None, 
                        in_upper=None, in_lower=None, param_labels=None, optimizer="log_fmin")
 
   Mandatory Arguments =
    fs:  spectrum object name
    pts: grid size for extrapolation, list of three values
    outfile:  prefix for output naming
    model_name: a label to help label the output files; ex. "no_mig"
    func: access the model function from within 'moments_Run_Optimizations.py' or from a separate python model script, 
          ex. after importing Models_2D, calling Models_2D.no_mig
    rounds: number of optimization rounds to perform
    param_number: number of parameters in the model selected (can count in params line for the model)
    fs_folded: A Boolean value (True or False) indicating whether the empirical fs is folded (True) or not (False).

   Optional Arguments =
     reps: a list of integers controlling the number of replicates in each of the optimization rounds
     maxiters: a list of integers controlling the maxiter argument in each of the optimization rounds
     folds: a list of integers controlling the fold argument when perturbing input parameter values
     in_params: a list of parameter values 
     in_upper: a list of upper bound values
     in_lower: a list of lower bound values
     param_labels: list of labels for parameters that will be written to the output file to keep track of their order
     optimizer: a string, to select the optimizer. Choices include: "log" (BFGS method), "log_lbfgsb" (L-BFGS-B method), 
                "log_fmin" (Nelder-Mead method), and "log_powell" (Powell's method).

Below, I give all the necessary information to call each model available in the
Models_2D.py script. I have set the optimization routine to be the same for each
model using the optional lists below, which are included as optional arguments for
each model. This particular configuration will run 4 rounds as follows:
Round1 - 10 replicates, maxiter = 3, fold = 3
Round2 - 20 replicates, maxiter = 5, fold = 2
Round3 - 30 replicates, maxiter = 10, fold = 2
Round4 - 40 replicates, maxiter = 15, fold = 1

If this script was run as is, each model would be called and optimized sequentially;
this could take a very long time. For your actual analyses, I strongly recommend
creating multiple scripts with only a few models each and running them
independently. It is also not a good idea to mix models from the Diversification Set
and the Island Set, as each was meant to be mutually exclusive.

'''


#create a prefix based on the population names to label the output files
#ex. Pop1_Pop2
prefix = "_".join(pop_ids)

#**************
#make sure to define your extrapolation grid size (based on your projections)
pts = [30,40,50]

#**************
#Set the number of rounds here
rounds = 4

#define the lists for optional arguments
#you can change these to alter the settings of the optimization routine
reps = [10,20,30,40]
maxiters = [3,5,10,15]
folds = [3,2,2,1]

#**************
#Indicate whether your frequency spectrum object is folded (True) or unfolded (False)
fs_folded = True


'''
Diversification Model Set

This first set of models come from the following publication:

    Portik, D.M., Leache, A.D., Rivera, D., Blackburn, D.C., Rodel, M.-O.,
    Barej, M.F., Hirschfeld, M., Burger, M., and M.K.Fujita. 2017.
    Evaluating mechanisms of diversification in a Guineo-Congolian forest
    frog using demographic model selection. Molecular Ecology 26: 5245-5263.
    doi: 10.1111/mec.14266

'''

# Split into two populations, no migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "no_mig", Models_2D.no_mig, rounds, 3, fs_folded=fs_folded,
                                      reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, T")


# Split into two populations, with continuous symmetric migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sym_mig", Models_2D.sym_mig, rounds, 4, fs_folded=fs_folded,
                                       reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T")


# Split into two populations, with continuous asymmetric migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "asym_mig", Models_2D.asym_mig, rounds, 5, fs_folded=fs_folded,
                                      reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T")


# Split with continuous symmetric migration, followed by isolation.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "anc_sym_mig", Models_2D.anc_sym_mig, rounds, 5, fs_folded=fs_folded,
                                      reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T1, T2")


# Split with continuous asymmetric migration, followed by isolation.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "anc_asym_mig", Models_2D.anc_asym_mig, rounds, 6, fs_folded=fs_folded,
                                     reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T1, T2")


# Split with no gene flow, followed by period of continuous symmetrical gene flow.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sec_contact_sym_mig", Models_2D.sec_contact_sym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T1, T2")


# Split with no gene flow, followed by period of continuous asymmetrical gene flow.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sec_contact_asym_mig", Models_2D.sec_contact_asym_mig, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T1, T2")



'''
The following 6 models were added to the Diversification Model Set by:

    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365
'''
# Split into two populations, with continuous symmetric migration, rate varying across two epochs.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sym_mig_twoepoch", Models_2D.sym_mig_twoepoch, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m1, m2, T1, T2")


# Split into two populations, with continuous asymmetric migration, rate varying across two epochs.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "asym_mig_twoepoch", Models_2D.asym_mig_twoepoch, rounds, 8, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12a, m21a, m12b, m21b, T1, T2")




'''
Island Diversification Model Set

This model set comes from the following publication:

    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365

For all the following models, pop2 is assumed to be the 'island' population and pop1 is the 
mainland population. Their sizes are based on the parameter s, where 0 < s < 1. Here, s 
represents the fraction of Nref that enters a population, with pop2 = s, and pop1 = 1-s. 
When these models are called the upper bound on s is set to 0.5, such that the island pop 
(pop2) can never contain >50% of the ancestral population. The values of nu1 and nu2 are 
therefore 1-s and s, unless there is a size change event. 

The 'vicariance' models involve no population size change, whereas the 'founder' event 
models always enforce exponential growth in pop2 (the island population).

NOTE: For these models, we must include an optional upper bound argument in
order to constrain the parameter 's' to be no more than 0.5, and we must also
supply a starting parameter list to keep the initial value of s within these bounds. 
For models with discrete admixture events, we need to constrain 'f' to between 0-1, 
and do so in a similar fashion.
'''
```

##### 2b.4. Modify the uppark_white.py' script: the script should be as follows:
The following 

##### uppark_white.py
```{r, include = FALSE}
'''
Usage: python dadi_Run_2D_Set.py

This is a modified version of the 'dadi_Run_Optimizations.py' script in which
we run optimizations for 2D comparisons for a large set of models that have been
made available as part of published works. These models are stored in the
Models_2D.py script, and will be called directly here. The user can delete or
comment out models to analyze a subset of the models available. 

This script must be in the same working directory as Optimize_Functions.py, which
contains all the functions necessary, as well as the  Models_2D.py script, which
has all the model definitions.


General workflow:
 The optimization routine runs a user-defined number of rounds, each with a user-defined
 or predefined number of replicates. The starting parameters are initially random, but after
 each round is complete the parameters of the best scoring replicate from that round are
 used to generate perturbed starting parameters for the replicates of the subsequent round.
 The arguments controlling steps of the optimization algorithm (maxiter) and perturbation
 of starting parameters (fold) can be supplied by the user for more control across rounds.
 The user can also supply their own set of initial parameters, or set custom bounds on the
 parameters (upper_bound and lower_bound) to meet specific model needs. This flexibility
 should allow these scripts to be generally useful for model-fitting with any data set.

 
Outputs:
 For each model run, there will be a log file showing the optimization steps per replicate
 and a summary file that has all the important information. Here is an example of the output
 from a summary file, which will be in tab-delimited format:
 
 Model	Replicate	log-likelihood	AIC	chi-squared	theta	optimized_params(nu1, nu2, m, T)
 sym_mig	Round_1_Replicate_1	-1684.99	3377.98	14628.4	383.04	0.2356,0.5311,0.8302,0.182
 sym_mig	Round_1_Replicate_2	-2255.47	4518.94	68948.93	478.71	0.3972,0.2322,2.6093,0.611
 sym_mig	Round_1_Replicate_3	-2837.96	5683.92	231032.51	718.25	0.1078,0.3932,4.2544,2.9936
 sym_mig	Round_1_Replicate_4	-4262.29	8532.58	8907386.55	288.05	0.3689,0.8892,3.0951,2.8496
 sym_mig	Round_1_Replicate_5	-4474.86	8957.72	13029301.84	188.94	2.9248,1.9986,0.2484,0.3688


Notes/Caveats:
 The likelihood and AIC returned represent the true likelihood only if the SNPs are
 unlinked across loci. For ddRADseq data where a single SNP is selected per locus, this
 is true, but if SNPs are linked across loci then the likelihood is actually a composite
 likelihood and using something like AIC is no longer appropriate for model comparisons.
 See the discussion group for more information on this subject. 

Citations:
 If you use these scripts or the main diversification models for your work, please
 cite the following publication:
    Portik, D.M., Leache, A.D., Rivera, D., Blackburn, D.C., Rodel, M.-O.,
    Barej, M.F., Hirschfeld, M., Burger, M., and M.K. Fujita. 2017.
    Evaluating mechanisms of diversification in a Guineo-Congolian forest
    frog using demographic model selection. Molecular Ecology 26: 5245-5263.
    doi: 10.1111/mec.14266
 
 If you use the additional diversification models or the island models set please cite 
 the following publication:
    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365
        
 If you are interesting in contributing your models to this workflow, please email me!

-------------------------
Written for Python 2.7 and 3.7
Python modules required:
-Numpy
-Scipy
-dadi
-------------------------

Daniel Portik
daniel.portik@gmail.com
https://github.com/dportik
Updated September 2019
'''

import sys
import os
import numpy
import dadi
import pylab
from datetime import datetime
import Optimize_Functions
import Models_2D


#===========================================================================
# Import data to create joint-site frequency spectrum
#===========================================================================

#**************
#snps = "/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/dadi_input/elk_white_dadi.fs"

#Create python dictionary from snps file
#dd = dadi.Misc.make_data_dict(snps)
dd = dadi.Misc.make_data_dict_vcf("/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/vcfs_for_dadi/dadi_uppark_white_neutral.vcf", "/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/dadi_pops/dadi_uppark_white.txt")


#**************
#pop_ids is a list which should match the populations headers of your SNPs file columns
pop_ids=["UPPARK", "WHITE"]

#**************
#projection sizes, in ALLELES not individuals
proj = [36, 20]

#Convert this dictionary into folded AFS object
#[polarized = False] creates folded spectrum object

#fs = "/Users/joegunn/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/raw_data/dadi_data/dadi_input/elk_white_dadi.fs"
fs = dadi.Spectrum.from_data_dict(dd, pop_ids=pop_ids, projections = proj, polarized = False)
#fs = dadi.Spectrum.from_data_dict(dd, pop_ids=pop_ids, polarized = False)

#print some useful information about the afs or jsfs
print("\n\n============================================================================")
print("\nData for site frequency spectrum:\n")
print("Projection: {}".format(proj))
print("Sample sizes: {}".format(fs.sample_sizes))
print("Sum of SFS: {}".format(numpy.around(fs.S(), 2)))
print("\n============================================================================\n")

#================================================================================
# Calling external 2D models from the Models_2D.py script
#================================================================================
'''
 We will use a function from the Optimize_Functions.py script for our optimization routines:
 
 Optimize_Routine(fs, pts, outfile, model_name, func, rounds, param_number, fs_folded=True, 
                        reps=None, maxiters=None, folds=None, in_params=None, 
                        in_upper=None, in_lower=None, param_labels=None, optimizer="log_fmin")
 
   Mandatory Arguments =
    fs:  spectrum object name
    pts: grid size for extrapolation, list of three values
    outfile:  prefix for output naming
    model_name: a label to help label the output files; ex. "no_mig"
    func: access the model function from within 'moments_Run_Optimizations.py' or from a separate python model script, 
          ex. after importing Models_2D, calling Models_2D.no_mig
    rounds: number of optimization rounds to perform
    param_number: number of parameters in the model selected (can count in params line for the model)
    fs_folded: A Boolean value (True or False) indicating whether the empirical fs is folded (True) or not (False).

   Optional Arguments =
     reps: a list of integers controlling the number of replicates in each of the optimization rounds
     maxiters: a list of integers controlling the maxiter argument in each of the optimization rounds
     folds: a list of integers controlling the fold argument when perturbing input parameter values
     in_params: a list of parameter values 
     in_upper: a list of upper bound values
     in_lower: a list of lower bound values
     param_labels: list of labels for parameters that will be written to the output file to keep track of their order
     optimizer: a string, to select the optimizer. Choices include: "log" (BFGS method), "log_lbfgsb" (L-BFGS-B method), 
                "log_fmin" (Nelder-Mead method), and "log_powell" (Powell's method).

Below, I give all the necessary information to call each model available in the
Models_2D.py script. I have set the optimization routine to be the same for each
model using the optional lists below, which are included as optional arguments for
each model. This particular configuration will run 4 rounds as follows:
Round1 - 10 replicates, maxiter = 3, fold = 3
Round2 - 20 replicates, maxiter = 5, fold = 2
Round3 - 30 replicates, maxiter = 10, fold = 2
Round4 - 40 replicates, maxiter = 15, fold = 1

If this script was run as is, each model would be called and optimized sequentially;
this could take a very long time. For your actual analyses, I strongly recommend
creating multiple scripts with only a few models each and running them
independently. It is also not a good idea to mix models from the Diversification Set
and the Island Set, as each was meant to be mutually exclusive.

'''


#create a prefix based on the population names to label the output files
#ex. Pop1_Pop2
prefix = "_".join(pop_ids)

#**************
#make sure to define your extrapolation grid size (based on your projections)
pts = [50,60,70]

#**************
#Set the number of rounds here
rounds = 4

#define the lists for optional arguments
#you can change these to alter the settings of the optimization routine
reps = [10,20,30,40]
maxiters = [3,5,10,15]
folds = [3,2,2,1]

#**************
#Indicate whether your frequency spectrum object is folded (True) or unfolded (False)
fs_folded = True


'''
Diversification Model Set

This first set of models come from the following publication:

    Portik, D.M., Leache, A.D., Rivera, D., Blackburn, D.C., Rodel, M.-O.,
    Barej, M.F., Hirschfeld, M., Burger, M., and M.K.Fujita. 2017.
    Evaluating mechanisms of diversification in a Guineo-Congolian forest
    frog using demographic model selection. Molecular Ecology 26: 5245-5263.
    doi: 10.1111/mec.14266

'''

# Split into two populations, no migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "no_mig", Models_2D.no_mig, rounds, 3, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, T")


# Split into two populations, with continuous symmetric migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sym_mig", Models_2D.sym_mig, rounds, 4, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T")


# Split into two populations, with continuous asymmetric migration.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "asym_mig", Models_2D.asym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T")


# Split with continuous symmetric migration, followed by isolation.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "anc_sym_mig", Models_2D.anc_sym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T1, T2")


# Split with continuous asymmetric migration, followed by isolation.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "anc_asym_mig", Models_2D.anc_asym_mig, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T1, T2")


# Split with no gene flow, followed by period of continuous symmetrical gene flow.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sec_contact_sym_mig", Models_2D.sec_contact_sym_mig, rounds, 5, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T1, T2")


# Split with no gene flow, followed by period of continuous asymmetrical gene flow.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sec_contact_asym_mig", Models_2D.sec_contact_asym_mig, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T1, T2")



'''
The following 6 models were added to the Diversification Model Set by:

    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365
'''
# Split into two populations, with continuous symmetric migration, rate varying across two epochs.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "sym_mig_twoepoch", Models_2D.sym_mig_twoepoch, rounds, 6, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m1, m2, T1, T2")


# Split into two populations, with continuous asymmetric migration, rate varying across two epochs.
Optimize_Functions.Optimize_Routine(fs, pts, prefix, "asym_mig_twoepoch", Models_2D.asym_mig_twoepoch, rounds, 8, fs_folded=fs_folded,
                                        reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12a, m21a, m12b, m21b, T1, T2")




'''
Island Diversification Model Set

This model set comes from the following publication:

    Charles, K.C., Bell, R.C., Blackburn, D.C., Burger, M., Fujita, M.K.,
    Gvozdik, V., Jongsma, G.F.M., Leache, A.D., and D.M. Portik. Sky, sea,
    and forest islands: diversification in the African leaf-folding frog
    Afrixalus paradorsalis (Order: Anura, Family: Hyperoliidae).
    Journal of Biogeography 45: 1781-1794. 
    doi: 10.1111/jbi.13365

For all the following models, pop2 is assumed to be the 'island' population and pop1 is the 
mainland population. Their sizes are based on the parameter s, where 0 < s < 1. Here, s 
represents the fraction of Nref that enters a population, with pop2 = s, and pop1 = 1-s. 
When these models are called the upper bound on s is set to 0.5, such that the island pop 
(pop2) can never contain >50% of the ancestral population. The values of nu1 and nu2 are 
therefore 1-s and s, unless there is a size change event. 

The 'vicariance' models involve no population size change, whereas the 'founder' event 
models always enforce exponential growth in pop2 (the island population).

NOTE: For these models, we must include an optional upper bound argument in
order to constrain the parameter 's' to be no more than 0.5, and we must also
supply a starting parameter list to keep the initial value of s within these bounds. 
For models with discrete admixture events, we need to constrain 'f' to between 0-1, 
and do so in a similar fashion.

'''
```

#### 2c: Run DADI on all population pairs.
In this step, we are executing the DADI program for all population pairs.

##### 2c.1. Run DADI on BAYOU and WHITE populations; copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate output files from DADI:

##### Command line code for running DADI on BAYOU and WHITE populations. UNCOMMENT this code in the shell script:
```{r}
## DADI run 01:	Run DADI on BAYOU and WHITE populations
#python3 ../analysis_scripts/illi_skia.py
```

This code produces output files for each model tested for the BAYOU and WHITE populations. For each model, there are two files, each beginning with "BAYOU_WHITE.", followed by [name_of_model]. One is `.optimized.txt`, and the other is `.log.txt`.

##### 2c.2. Run DADI on ELK and WHITE populations; copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate output files from DADI:

##### Command line code for running DADI on ELK and WHITE populations. UNCOMMENT this code in the shell script:
```{r}
## DADI run 02:	Run DADI on ELK and WHITE populations
#python3 ../analysis_scripts/elk_white.py
```

This code produces output files for each model tested for the ELK and WHITE populations. For each model, there are two files, each beginning with "ELK_WHITE.", followed by [name_of_model]. One is `.optimized.txt`, and the other is `.log.txt`.

##### 2c.3. Run DADI on ILLI and SKIA populations; copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate output files from DADI:

##### Command line code for running DADI on ILLI and SKIA populations. UNCOMMENT this code in the shell script:
```{r}
## DADI run 03:	Run DADI on ILLI and SKIA populations
#python3 ../analysis_scripts/illi_skia.py
```

This code produces output files for each model tested for the ILLI and SKIA populations. For each model, there are two files, each beginning with "ILLI_SKIA.", followed by [name_of_model]. One is `.optimized.txt`, and the other is `.log.txt`.

##### 2c.4. Run DADI on ILLI and SKIA populations; copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate output files from DADI:

##### Command line code for running DADI on ILLI and SKIA populations. UNCOMMENT this code in the shell script:
```{r}
## DADI run 04:	Run DADI on UPPARK and WHITE populations
#python3 ../analysis_scripts/uppark_white.py
```

This code produces output files for each model tested for the UPPARK and WHITE populations. For each model, there are two files, each beginning with "UPPARK_WHITE.", followed by [name_of_model]. One is `.optimized.txt`, and the other is `.log.txt`.
