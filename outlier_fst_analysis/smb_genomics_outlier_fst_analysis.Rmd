---
title: 'Analysis 6: Directional Selection Analysis'
author: "Joe Gunn"
date: "2022-09-03"
output: html_document
---

# Project: Population genomic analysis of Smallmouth Bass and Neosho Bass in the Central Interior Highlands
We investigated the extent of genomic divergence, local directional selection, and admixture between the Smallmouth Bass (<i>Micropterus dolomieu</i>) and the Neosho Bass (<i>M. velox</i>) in the Central Interior Highlands (CIH) ecoregion of central north America. Specifically, we used ddRADseq data to assessed the phylogenomic relationship between and within species, characterizing inter- and intraspecific diversity and SNPs potentially under local directional selection at the population level. Additionally, we inferred the relative timing of admxiture in Neosho Bass streams where there is known introgressive hybridization with Smallmouth Bass to understand the influence of natural, historic geographic factors on mixing (stream capture or transient flooding) vs. anthropogenic factors (i.e., non-native introductions through stocking), which is known to have occurred widely in these economically valuable species. We ultimately hoped to provide novel insights into the diversity of endemic, ecologically important and popular sport fish in the CIH.

## Specific Aim: Directional selection analysis
In this analysis, we used the popgen.vcf data generated in Analysis 2 (SNP Filtering...) to scan for signatures of directional selection on SNP loci with outlier Fst (high outlier Fst: directional selection; low Fst: balancing selection). We used two software programs with different underlying statistical frameworks to detect outliers and then used any outliers commonly detected in both analyses as canditates for being under strong selection. Specifically, we used the software program BAYESCAN (based in Bayesian analysis) and the R package PCAdapt principal component analysis (based in multivariate principal component analysis). We then employed DAPC in R to map patterns of population differentiation at any shared outlier and neutral loci to detect populations that may be under differential selection pressures and to detect signatures of genetic drift, respectively.

## Phases of analysis:
### Phase 1: Data preparation
### Phase 2: Outlier Fst analysis with BAYESCAN
### Phase 3: Outlier Fst analysis with PCADAPT
### Phase 4: Outlier mapping

## Libraries needed for analysis
```{r setup, echo = FALSE, include=FALSE}
library(readxl)
library(tidyverse)
library(cowplot)
library(devtools)
library(SNPRelate)
library(vcfR)
library(pophelper)
library(PopGenome)
library(pcadapt)
library(viridis)
```

## PHASE 1: DATA PREPARATION
In this phase of the analysis, we are converting the fully filtered, thinned dataset excluding Spotted Bass and the Spotted Bass hybrid (`admixture_phylogenomics_analysis/data/processed_vcf/03_popgen_spb.vcf`) into input files compatible with the software programs BAYESCAN and the R package PCAdapt. For BAYESCAN, we are using the intermediate conversion software PGDSPIDER to generate input files, and for PCAdapt, we are again using the program PLINK.

For the outlier Fst analysis, we are conducing scans for outlier loci hiearchically at the black bass species level (between Spotted Bass, Smallmouth Bass, and Neosho Bass), among species within the Smallmouth Bass species complex (Smallmouth Bass and Neosho Bass), and among populations within black bass species. The goal with this structure is to reduce false positive detection due to population structure and to detect potentially selected SNPs at each hierarchical level.

With this analysis structure, we conducted scans with the following sets of data: 

1) All black bass samples, including Spotted Bass, Smallmouth Bass, and Neosho Bass (excluding the Spotted Bass hybrid)
2) All Smallmouth Bass and Neosho Bass samples, excluding Spotted Bass
3) All Neosho Bass populations only
4) All Smallmouth Bass populations only

All analyses conducted by calling commands in bash shell scripts were performed on the Lewis high-performance computing cluster at the University of Missouri <br>

<b>Programs needed</b>: <br><br>

PGDSPIDER v.2.1.1.5 (Lischer and Excoffier 2012) <br>

<b>Citation</b>:<br>

Lischer, H. E. L., E& Excoffier, L. (2012). PGDSpider: an automated data conversion tool fo connecting population genetics and genomics programs. Bionformatics, 28, 298-299. doi:/10.1093/bioinformatics/btr642


PLINK v.1.90p (high-contig build; Change et al. 2015) <br>

<b>Citation</b>:<br>

Chang, C. C., Chow, C. C., Tellier, L. C. A. M., Vattikuti, S., Purcell, S. M., & Lee, J. J. (2015). Second-generation PLINK: Rising to the challenge of larger and richer datasets. GigaScience, 4, 1–16. doi:10.1186/s13742-015-0047-8

### STEP 1: Prepare input data for BAYESCAN.
In this step, we are using the conversion software PGDSPIDER to prepare all input data for the software program BAYESCAN.

#### 1a: Filter fully filtered, thinned VCF file (excluding Spotted Bass hybrid) for each analysis level 
In this step, we are generating filtered VCF data to to run each level of the outlier Fst analysis (see above for the four hierarchical levels of analysis)  

##### 1a.1. Generate a general bash shell script header for all VCF filtering steps commands
In this step, we are generating a universal bash shell script to run all filtering commands in VCFTOOLS (See Phase 1 in Analysis 2 for programs needed and citation information) Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all VCFTOOLS code is called "vcftools.sh".

###### 1a.1.1 Copy and paste the code below in a new shell script file:

##### Generate VCFTOOLS bash shell script: `code/shell_scripts/vcftools.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J filter_admixed  # give the job a custom name
#SBATCH -o filtering_missing.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

## UNCOMMENT LINES STARTING HERE 

## Load VCFtools module
# module load rss/rss-2020
# module load vcftools/vcftools-v0.1.14
```

##### 1a.2. Generate lists of individuals to use for all filtering steps.
In this step, we are generating lists of individuals to filter from the VCF dataset. For the first level of analysis (all black bass samples, we are not excluding any samples). For the second level of analysis, we are excluding Spotted Bass. For the third level of analysis, we are excluding all Smallmouth Bass to retain only Neosho Bass. For the fourth analysis, we are excluding all Neosho Bass to retain only Smallmouth Bass.

###### 1a.2.1. Generate a list of Spotted Bass to omit from analyses 2, 3, and 4.

##### Generate list file: `data/filtering_data/spotted_bass.txt`
```{r}
# Load in full metadata
load("../raw_data/metadata.Rda")

# Filter all individuals but Spotted Bass
spotted_bass <- metadata %>%
  filter(species == "Spotted_Bass")

# Convert to dataframe
spotted_bass <- data.frame(spotted_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(spotted_bass, 
          file = "data/filtering_data/spotted_bass.txt", 
          col_names = FALSE)

# Turn column into vector without column name to save as un-headered list for downstream filtering
spotted_bass <- as.vector(spotted_bass$sample_id)

# Save the list of bad samples as a .Rda file without column names
save(spotted_bass, file = "data/filtering_data/spotted_bass.Rda")
```

###### 1a.2.2. Generate a list of Smallmouth Bass to omit from analysis 3.

##### Generate list file: `data/filtering_data/smallmouth_bass.txt`
```{r}
# Filter all individuals but Spotted Bass
smallmouth_bass <- metadata %>%
  filter(species == "Smallmouth_Bass")

# Convert to dataframe
smallmouth_bass <- data.frame(smallmouth_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(smallmouth_bass, 
          file = "data/filtering_data/smallmouth_bass.txt", 
          col_names = FALSE)

# Turn column into vector without column name to save as un-headered list for downstream filtering
smallmouth_bass <- as.vector(smallmouth_bass$sample_id)

# Save the list of bad samples as a .Rda file without column names
save(smallmouth_bass, file = "data/filtering_data/smallmouth_bass.Rda")
```

###### 1a.2.3. Generate a list of Neosho Bass to omit from analysis 4.

##### Generate list file: `data/filtering_data/neosho_bass.txt`
```{r}
# Filter all individuals but Spotted Bass
neosho_bass <- metadata %>%
  filter(species == "Neosho_Bass")

# Convert to dataframe
neosho_bass <- data.frame(neosho_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(neosho_bass, 
          file = "data/filtering_data/neosho_bass.txt", 
          col_names = FALSE)

# Turn column into vector without column name to save as un-headered list for downstream filtering
neosho_bass <- as.vector(neosho_bass$sample_id)

# Save the list of bad samples as a .Rda file without column names
save(neosho_bass, file = "data/filtering_data/neosho_bass.Rda")
```

#### 1a.3. Filter VCF files.

##### 1a.3.1. Filter out Spotted Bass to generate VCF for species complex samples (Smallmouth Bass and Neosho Bass); copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 01: omit Spotted Bass individuals to get samples at the species complex level (Smallmouth Bass and Neosho Bass only)
#vcftools --vcf ../../data/processed_vcf/01_popgen_spb_hybrid.vcf --remove ../../data/filtering_data/spotted_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/02_popgen_species_complex
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/02_popgen_species_complex.vcf`.

##### 1a.3.2. Filter out Smallmouth Bass to generate VCF for Neosho Bass samples (Neosho Bass only); copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 02: omit Smallmouth Bass samples to get only Neosho samples for the Neosho Bass population level
#vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --remove ../../data/filtering_data/smallmouth_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/03_popgen_neosho
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/03_popgen_neosho.vcf`.

##### 1a.3.3. Filter out Smallmouth Bass to generate VCF for Smallmouth Bass samples (Smallmouth Bass only); copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 03: omit Neosho Bass samples to get only Smallmouth Bass samples for the Smallmouth Bass population level
#vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --remove ../../data/filtering_data/neosho_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/04_popgen_smallmouth
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/03_popgen_neosho.vcf`.

#### 1b: Generate PGDSPIDER accompanying SPID files
In this step, we are generating text scripts for an accompanying file needed for PGDSPIDER conversions called a "spid" file. This file includes specific parameters that must to be completed for each file conversion in order to generate the correct output.

##### 1b.1. Generate a general text script for PGDSPIDER SPID file
Here, we only provide the base script without any parameters filled in. In subsequent steps, we include the completed version for each file conversion with specific parameters. The base script is called "spid.spid".

###### 1b.1.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/spid.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=
```

##### 1b.2. Generate a PGDSPIDER SPID file for the black bass level genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the Black Bass level genome scan, which includes all Spotted Bass, Smallmouth Bass, and Neosho Bass.

###### 1b.2.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/01_all.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/01_all_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

##### 1b.3. Generate a PGDSPIDER SPID file for the Smallmouth Bass species complex genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the species complex level genome scan, which includes all Smallmouth Bass and Neosho Bass.

###### 1b.3.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/02_species_complex.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/02_species_complex_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

##### 1b.4. Generate a PGDSPIDER SPID file for the Neosho Bass genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the Neosho Bass population level genome scan, which includes all Neosho Bass only

###### 1b.4.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/03_neosho.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/03_neosho_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

##### 1b.5. Generate a PGDSPIDER SPID file for the Neosho Bass genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the Smallmouth Bass population level genome scan, which includes all Smallmouth Bass only

###### 1b.5.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/04_smallmouth.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/04_smallmouth_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

#### 1c: Generate population designation files (read by SPID files)
In this step, we are generating text files listing all samples in at each genome scan level and their corresponding population designations as inferred in Analysis 4 (population inference). Our inferred populations were named according to their general geographic locations (see Phase 4 of population_analysis, "MIDARK", "ELK", "BAYOU", etc.), but PGDSPIDER expects input populations in a specific format (i.e., "pop_1", "pop_2", etc.). We generate population files according to this naming convention

##### 1c.1. Read in sample metadata and generate lists of populations for the black bass species level.

###### 1c.1.1 Generate population file for all black bass samples (Spotted Bass, Smallmouth Bass, and Neosho Bass):

##### Generate population file: `data/pop_files/01_all_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

metadata_populations_spb <- metadata_populations_spb %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_spb$population[metadata_populations_spb$population == "MIDARK"] <- "pop_1"
metadata_populations_spb$population[metadata_populations_spb$population == "MISS"] <- "pop_2"
metadata_populations_spb$population[metadata_populations_spb$population == "SKIA"] <- "pop_3"
metadata_populations_spb$population[metadata_populations_spb$population == "LMULB"] <- "pop_4"
metadata_populations_spb$population[metadata_populations_spb$population == "WHITE"] <- "pop_5"
metadata_populations_spb$population[metadata_populations_spb$population == "ELK"] <- "pop_6"
metadata_populations_spb$population[metadata_populations_spb$population == "ILLI"] <- "pop_7"
metadata_populations_spb$population[metadata_populations_spb$population == "UPPARK"] <- "pop_8"
metadata_populations_spb$population[metadata_populations_spb$population == "BAYOU"] <- "pop_9"
metadata_populations_spb$population[metadata_populations_spb$population == "SPB"] <- "pop_10"

# Generate text file
write_delim(metadata_populations_spb, 
          delim = " ",
          file = "data/pop_files/01_all_pops.txt", 
          col_names = FALSE)
```

##### 1c.2. Read in sample metadata and generate lists of populations for the species complex level.

###### 1c.2.1 Generate population file for species complex samples (Smallmouth Bass and Neosho Bass):

##### Generate population file: `data/pop_files/02_species_complex_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

metadata_populations_complex <- metadata_populations_spb %>%
  filter(population != "SPB")

metadata_populations_complex <- metadata_populations_complex %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_complex$population[metadata_populations_complex$population == "MIDARK"] <- "pop_1"
metadata_populations_complex$population[metadata_populations_complex$population == "MISS"] <- "pop_2"
metadata_populations_complex$population[metadata_populations_complex$population == "SKIA"] <- "pop_3"
metadata_populations_complex$population[metadata_populations_complex$population == "LMULB"] <- "pop_4"
metadata_populations_complex$population[metadata_populations_complex$population == "WHITE"] <- "pop_5"
metadata_populations_complex$population[metadata_populations_complex$population == "ELK"] <- "pop_6"
metadata_populations_complex$population[metadata_populations_complex$population == "ILLI"] <- "pop_7"
metadata_populations_complex$population[metadata_populations_complex$population == "UPPARK"] <- "pop_8"
metadata_populations_complex$population[metadata_populations_complex$population == "BAYOU"] <- "pop_9"

# Generate text file
write_delim(metadata_populations_complex, 
          delim = " ",
          file = "data/pop_files/02_species_complex_pops.txt", 
          col_names = FALSE)
```

##### 1c.3. Read in sample metadata and generate lists of populations for the Neosho Bass level.

###### 1c.3.1 Generate population file for Neosho Bass samples (Neosho Bass only):

##### Generate population file: `data/pop_files/03_neosho_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

metadata_populations_neosho <- metadata_populations_spb %>%
  filter(population != "SPB") %>%
  filter(population != "MISS") %>%
  filter(population != "SKIA") %>%
  filter(population != "WHITE")

metadata_populations_neosho <- metadata_populations_neosho %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_neosho$population[metadata_populations_neosho$population == "MIDARK"] <- "pop_1"
metadata_populations_neosho$population[metadata_populations_neosho$population == "LMULB"] <- "pop_2"
metadata_populations_neosho$population[metadata_populations_neosho$population == "ELK"] <- "pop_3"
metadata_populations_neosho$population[metadata_populations_neosho$population == "ILLI"] <- "pop_4"
metadata_populations_neosho$population[metadata_populations_neosho$population == "UPPARK"] <- "pop_5"
metadata_populations_neosho$population[metadata_populations_neosho$population == "BAYOU"] <- "pop_6"

# Generate text file
write_delim(metadata_populations_neosho, 
          delim = " ",
          file = "data/pop_files/03_neosho_pops.txt", 
          col_names = FALSE)
```

##### 1c.4. Read in sample metadata and generate lists of populations for the Smallmouth Bass level.

###### 1c.4.1 Generate population file for Smallmouth Bass samples (Smallmouth Bass only):

##### Generate population file: `data/pop_files/04_neosho_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

metadata_populations_smallmouth <- metadata_populations_spb %>%
  filter(population != "SPB") %>%
  filter(population != "MIDARK") %>%
  filter(population != "ELK") %>%
  filter(population != "ILLI") %>%
  filter(population != "LMULB") %>%
  filter(population != "BAYOU") %>%
  filter(population != "UPPARK")

metadata_populations_smallmouth <- metadata_populations_smallmouth %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_smallmouth$population[metadata_populations_smallmouth$population == "WHITE"] <- "pop_1"
metadata_populations_smallmouth$population[metadata_populations_smallmouth$population == "MISS"] <- "pop_2"
metadata_populations_smallmouth$population[metadata_populations_smallmouth$population == "SKIA"] <- "pop_3"

# Generate text file
write_delim(metadata_populations_smallmouth, 
          delim = " ",
          file = "data/pop_files/04_smallmouth_pops.txt", 
          col_names = FALSE)
```

#### 1d: Generate a general bash shell script header for all PGDSPIDER conversion commands
In this step, we are generating a universal bash shell script to run all file type conversions in PGDSPIDER. Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all PGDSPIDER code is called "pgdspider.sh".

##### 1d.1: Copy and paste the code below in a new shell script file:

##### Generate PGDSPIDER bash shell script: `code/shell_scripts/pgdspider.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J pgd_coversion  # give the job a custom name
#SBATCH -o pgd_results-%j.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit
#SBATCH --mem-per-cpu=8G

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

# UNCOMMENT STARTING HERE

## Commands here run only on the first core
# module load rss/rss-2020
# module load pgdspider/pgdspider-2.1.1.5
```

#### 1e: Convert VCF files to BAYESCAN format.
In this step, we are using the general bash script for PGDSPIDER in addition to the four unique spid files for each analysis level to generate input files for BAYESCAN.

##### 1e.1. Convert VCF to BAYESCAN format for all black bass samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for all samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 01: all black bass samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/01_popgen_spb_hybrid.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/01_all -outputformat GESTE_BAYE_SCAN -spid ../spid_files/01_all.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/01_all`

##### 1e.2. Convert VCF to BAYESCAN format for all species complex samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for speices complex samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 02: species complex samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/02_popgen_species_complex.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/02_species_complex -outputformat GESTE_BAYE_SCAN -spid ../spid_files/02_species_complex.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/02_species_complex`

##### 1e.3. Convert VCF to BAYESCAN format for Neosho Bass samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for Neosho Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 03: Neosho Bass samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/03_popgen_neosho.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/03_neosho -outputformat GESTE_BAYE_SCAN -spid ../spid_files/03_neosho.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/03_neosho`

##### 1e.4. Convert VCF to BAYESCAN format for Smallmouth Bass samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for Smallmouth Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 04: Smallmouth Bass samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/04_popgen_smallmouth.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/04_smallmouth -outputformat GESTE_BAYE_SCAN -spid ../spid_files/04_smallmouth.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/04_smallmouth`

### STEP 2: Prepare input data for PCADAPT
In this step, we are preparing all input data for the R program PCADAPT. PCADAPT reads .bed files (generated in the software program PLINK) as input, along with accompanying .bim and .fam files.

#### 2a: Generate a general bash shell script header for all PLINK commands
In this step, we are generating a universal bash shell script to run all file type conversions in PLINK. Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all PLINK code is called "plink.sh".

##### 2a.1. Copy and paste the code below in a new shell script file:

##### Generate PLINK bash shell script: `code/shell_scripts/plink.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J plink # give the job a custom name
#SBATCH -o plink.out  # give the job output a custom name
#SBATCH -t 0-01:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

## Commands here run only on the first core

# (UNCOMMENT THIS LINE TO RUN THE CODE)

## Modules to load

# module load rss/rss-2020
# module load plink/plink-high-contig-1.90p 
```

#### 2b: Convert VCF data into .bed format for PCADAPT analysis.

##### 2a.1. Convert VCF data for all black bass samples; copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 01: Convert VCF data for all black bass samples (excluding Spotted Bass hybrid, BFC10) to .bed format
#plink --vcf ../../data/processed_vcf/01_popgen_spb_hybrid.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/01_all_output/01_all
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/01_all_output/01_all.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.

##### 2a.2. Convert VCF data for species complex samples (Neosho Bass and Smallmouth Bass); copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 02: Convert VCF data for species complex samples (Neosho Bass and Smallmouth Bass) to .bed format
#plink --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/02_species_complex_output/02_species_complex
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/02_species_complex_output/02_species_complex.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.

##### 2a.3. Convert VCF data for Neosho Bass samples only; copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 03: Convert VCF data for Neosho Bass only to .bed format
#plink --vcf ../../data/processed_vcf/03_popgen_neosho.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/03_neosho_output/03_neosho
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/03_neosho_output/03_neosho.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.

##### 2a.4. Convert VCF data for Smallmouth Bass samples only; copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 04: Convert VCF data for Smallmouth Bass only to .bed format
#plink --vcf ../../data/processed_vcf/04_popgen_smallmouth.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/04_smallmouth_output/04_smallmouth
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/04_smallmouth_output/04_smallmouth.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.


### ----------------------- END OF PHASE 1: DATA PREPARATION ----------------------- ###

## PHASE 2: OUTLIER ANALYSIS WITH BAYESCAN
In this phase of the analysis, we are using the software program BAYESCAN to conduct a genome scan for SNP loci with outlier Fst values to assess potential signatures of local directional selection and neutrality at various loci. We are conducting this analysis at four hierarchical levels, as listed in the description for Phase 1 of the analysis (see above). We are using input data for each hierarchical level of analysis as generated in Phase 1 of this analysis.

BAYESCAN uses a Bayesian framework to calculate probabilities of outlier loci across the genome.

All analyses conducted by calling commands in bash shell scripts were performed on the Lewis high-performance computing cluster at the University of Missouri <br>

 
 <b>Programs needed</b>: <br><br>

BAYESCAN v.2.1 (Foll & Gaggiotti 2008) <br>

<b>Citation</b>:<br>

Foll, M., & Gaggiotti, O. (2008). A genome-scan method to identify selected loci appropriate for both dominant and codominant markers: A Bayesian perspective. Genetics, 180, 977–993. doi:10.1534/genetics.108.092221


### STEP 1: Generate a general bash shell script header for all BAYESCAN runs.
In this step, we are generating a universal bash shell script to run all analyses in BAYESCAN Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each analysis and the associated lines of code in Rmd chunks. The shell script for running all BAYESCAN code is called "bayescan.sh".

#### 1a: Copy and paste the code below in a new shell script file:

##### Generate BAYESCAN bash shell script: `code/shell_scripts/bayescan.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J bayescan # give the job a custom name
#SBATCH -o bayescan.out  # give the job output a custom name
#SBATCH -t 1-00:00:00  # two day time limit
#SBATCH --account=biosci
#SBATCH -N 1  # number of nodes
#SBATCH -n 21  # number of cores (AKA tasks)

# UNCOMMENT STARTING HERE

## Load modules needed
# module load rss/rss-2020
# module load bayescan/bayescan-2.1
```

#### 1b: Conduct genome scans in BAYESCAN for all hierarchical analyses
In this step, we are conducting genome scans for outlier Fst loci using the software program BAYESCAN.

We used the same parameter set for each hierarchical analysis, as follows: <br<

<b>Parameters set for BAYESCAN analysis</b>: <br>
Default parameters: <br>
 -n 5000 (number of MCMC iterations) <br>
 -thin 10 (number at which to thin MCMC iterations) <br>
 -nbp 20 (number of pilot runs) <br>
 -pilot 5000 (length of pilot runs) <br>
 -burni 5000 (length of burnin run) <br>
 
##### 1b.1. Run BAYESCAN for all black bass species (Spotted Bass, Neosho Bass, and Smallmouth Bass); copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on all black bass samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 1: all black bass samples
# bayescan 01_all -od ../../data/bayescan_output -o 01_all_output/01_all
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/01_all_output/`. The files are:

1) 01_all_AccRte.txt
2) 01_all_fst.txt
3) 01_all.sel
4) 01_all_Verif.txt

##### 1b.2. Run BAYESCAN for species complex samples (eosho Bass and Smallmouth Bass); copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on species complex samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 2: species complex samples (Neosho Bass and Smallmouth Bass)
# bayescan 02_species_complex -od ../../data/bayescan_output -o 02_species_complex
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/02_species_complex_output/`. The files are:

1) 02_species_complex_AccRte.txt
2) 02_species_complex_fst.txt
3) 02_species_complex.sel
4) 02_species_complex_Verif.txt

##### 1b.3. Run BAYESCAN for Neosho Bass only; copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on Neosho Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 3: Neosho Bass samples (Neosho Bass only)
# bayescan 03_neosho -od ../../data/bayescan_output -o 03_neosho
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/03_neosho_output/`. The files are:

1) 03_neosho_AccRte.txt
2) 03_neosho_fst.txt
3) 03_neosho.sel
4) 03_neosho.txt

##### 1b.4. Run BAYESCAN for Smallmouth Bass only; copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on Smallmouth Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 1: all black bass samples
# bayescan 04_smallmouth -od ../../data/bayescan_output -o 04_smallmouth
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/04_smallmouth_output/`. The files are:

1) 04_smallmouth_AccRte.txt
2) 04_smallmouth_fst.txt
3) 04_smallmouth.sel
4) 04_smallmouth.txt

### STEP 2: Identify SNP loci associated with outlier Fst inferred in BAYESCAN.
In this step, we are reading in the Fst results generated in the BAYESCAN analysis in Phase 2 Step 1 and identifying loci with outlier Fst values.

#### 2a: Read in Fst results for all hiearchical analyses; run the Rmd chunk below.

##### Read in Fst results for all analyses:
```{r}
# Read in data for all black bass samples (Spotted Bass, Neosho Bass, and Smallmouth Bass)
all_fst <- read.table("data/bayescan_output/01_all_output/01_all_fst.txt")

# Convert to dataframe
all_fst <- as.data.frame(all_fst)

# Modify column names
colnames(all_fst) <- c("probability", "log_po", "q", "alpha", "fst")


# Read in data for species complex samples (Neosho Bass and Smallmouth Bass)
species_complex_fst <- read.table("data/bayescan_output/02_species_complex_output/02_species_complex_fst.txt")

# Convert to dataframe
species_complex_fst <- as.data.frame(species_complex_fst)
  
# Modify column names
colnames(species_complex_fst) <- c("probability", "log_po", "q", "alpha", "fst")


# Read in data for Neosho Bass
neosho_fst <- read.table("data/bayescan_output/03_neosho_output/03_neosho_fst.txt")

# Convert to dataframe
neosho_fst <- as.data.frame(neosho_fst)

# Modify column names
colnames(neosho_fst) <- c("probability", "log_po", "q", "alpha", "fst")
  

# Read in data for Smallmouth Bass
smallmouth_fst <- read.table("data/bayescan_output/04_smallmouth_output/04_smallmouth_fst.txt")

# Convert to dataframe
smallmouth_fst <- as.data.frame(smallmouth_fst)

# Modify column names
colnames(smallmouth_fst) <- c("probability", "log_po", "q", "alpha", "fst")
```

#### 2b: Identify outlier SNP loci
In this step, we are identifying SNP loci with high probability of being under selection based on log10 of the posterior odds (log_po), which is given in column 2 of the BAYESCAN output data. Per the BAYESCAN user manual, any SNP with log10 posterior odds greater than or equal to 0.5 is deemed "substantially likely to be under selection". We therefore isolated all SNPs with log_po greater than 0.5 and designated them as "significant". All SNPs with log_po less than 0.5 were designated as "not significant".

We provided information on the level of significance for each "significant" SNP per to the BAYESCAN user manual (retrieved from: http://www.cmpg.unibe.ch/software/BayeScan/files/BayeScan2.0_manual.pdf):

<b>BAYESCAN levels of significance</b>: <br>
2.00 <= log_po < infinity: decisive <br>
1.50 <= log_po < 2.00: very strong <br>
1.00 <= log_po < 1.50: strong <br>
0.50 <= log_po < 1.00: substantial <br>
0.00 <= log_po < 0.50: barely worth mentioning <br>

##### 2b.1.  Generate metadata for SNP ID (RAD_kmer_...) and SNP position (nucleotide position on the kmer)
In this step, we are generating a list of SNP IDs and positions to append to the datasets below in order to determine the identity of outlier SNPs

###### 2b.1.1.Generate SNP position and metadata; run the Rmd chunk below:

##### Generate list of SNP ID and position:
```{r}
# Read in .bim file, which contains a list of RAD kmer names and associated positions
metadata_snps <- read_tsv("data/processed_bed/01_all_output/01_all.bim", col_names = F)
  
# Keep only SNP name and position columns
metadata_snps <- metadata_snps[,c(1,4)]

# Rename columns
colnames(metadata_snps) <- c("snp_id", "position")
```

##### 2b.2. Isolate significant and insignificant SNPs for all black bass samples; run the Rmd chunk below:

##### Outlier SNP identification for all black bass samples:
```{r}
# Append SNP IDs to data
all_fst <- cbind(metadata_snps, all_fst)

# Isolate SNPs with log_po greater than or equal to 0.5
all_significant <- all_fst %>% 
      filter(log_po >= 0.5) 

# Isolate SNPs with log_po less than 0.5
all_not_significant <- all_fst %>% 
      filter(log_po < 0.5) 

# Put log_po in descending order to analyze significance level 
all_significant <- all_significant %>%
  arrange(desc(log_po))

# count SNPs that are decisively under selection
all_significant %>% 
  filter(log_po >= 2) %>% 
  count()

# count SNPs that are under very strong selection
all_significant %>% 
  filter(log_po >= 1.5 & log_po < 2) %>% 
  count()

# count SNPs that are under strong selection
all_significant %>% 
  filter(log_po >= 1 & log_po < 1.5) %>% 
  count()

# count SNPs that are under very strong selection
all_significant %>% 
  filter(log_po >= 0.5 & log_po < 1) %>% 
  count()

# Append column for selection status ("selection"; significant or not signficant)
all_significant$selection <- c(rep("significant", times = 3))
all_not_significant$selection <- c(rep("insignificant", times = 50825))

# Append column for significance level ("sig_level"; decisive, very strong, substantial)
all_significant$sig_level <- c(rep("very_strong", times = 1),rep("substantial", times = 2))
all_not_significant$sig_level <- c(rep("not_significant", times = 50825))

#combine data into one dataframe
all_fst <- rbind(all_significant, all_not_significant)
```

##### 2b.3. Isolate significant and insignificant SNPs for species complex samples (Neosho Bass and Smallmouth Bass); run the Rmd chunk below:

##### Outlier SNP identification for all black bass samples:
```{r}
# Append SNP IDs to data
species_complex_fst <- cbind(metadata_snps, species_complex_fst)

# Isolate SNPs with log_po greater than or equal to 0.5
species_complex_significant <- species_complex_fst %>% 
      filter(log_po >= 0.5) 

# Isolate SNPs with log_po less than 0.5
species_complex_not_significant <- species_complex_fst %>% 
      filter(log_po < 0.5) 

# Put log_po in descending order to analyze significance level 
species_complex_significant <- species_complex_significant %>%
  arrange(desc(log_po))

# count SNPs that are decisively under selection
species_complex_significant %>% 
  filter(log_po >= 2) %>% 
  count()

# count SNPs that are under very strong selection
species_complex_significant %>% 
  filter(log_po >= 1.5 & log_po < 2) %>% 
  count()

# count SNPs that are under strong selection
species_complex_significant %>% 
  filter(log_po >= 1 & log_po < 1.5) %>% 
  count()

# count SNPs that are under very strong selection
species_complex_significant %>% 
  filter(log_po >= 0.5 & log_po < 1) %>% 
  count()

# Append column for selection status ("selection"; significant or not signficant)
species_complex_significant$selection <- c(rep("significant", times = 703))
species_complex_not_significant$selection <- c(rep("insignificant", times = 50125))

# Append column for significance level ("sig_level"; decisive, very strong, substantial)
species_complex_significant$sig_level <- c(rep("decisive", times = 118), 
                                                rep("very_strong", times = 86), 
                                                rep("strong", times = 164), 
                                                rep("substantial", times = 335))

species_complex_not_significant$sig_level <- c(rep("not_significant", times = 50125))

#combine data into one dataframe
species_complex_fst <- rbind(species_complex_significant, species_complex_not_significant)
```

##### 2b.4. Isolate significant and insignificant SNPs for Neosho Bass only; run the Rmd chunk below:

##### Outlier SNP identification for all black bass samples:
```{r}
# Append SNP IDs to data
neosho_fst <- cbind(metadata_snps, neosho_fst)

# Isolate SNPs with log_po greater than or equal to 0.5
neosho_significant <- neosho_fst %>% 
      filter(log_po >= 0.5) 

# Isolate SNPs with log_po less than 0.5
neosho_not_significant <- neosho_fst %>% 
      filter(log_po < 0.5) 

# Put log_po in descending order to analyze significance level 
neosho_significant <- neosho_significant %>%
  arrange(desc(log_po))

# count SNPs that are decisively under selection
neosho_significant %>% 
  filter(log_po >= 2) %>% 
  count()

# count SNPs that are under very strong selection
neosho_significant %>% 
  filter(log_po >= 1.5 & log_po < 2) %>% 
  count()

# count SNPs that are under strong selection
neosho_significant %>% 
  filter(log_po >= 1 & log_po < 1.5) %>% 
  count()

# count SNPs that are under very strong selection
neosho_significant %>% 
  filter(log_po >= 0.5 & log_po < 1) %>% 
  count()

# Append column for selection status ("selection"; significant or not signficant)
neosho_significant$selection <- c(rep("significant", times = 32))
neosho_not_significant$selection <- c(rep("insignificant", times = 50796))

# Append column for significance level ("sig_level"; decisive, very strong, substantial)
neosho_significant$sig_level <- c(rep("decisive", times = 2), 
                                                rep("very_strong", times = 5), 
                                                rep("strong", times = 4), 
                                                rep("substantial", times = 21))

neosho_not_significant$sig_level <- c(rep("not_significant", times = 50796))

#combine data into one dataframe
neosho_fst <- rbind(neosho_significant, neosho_not_significant)
```

##### 2b.5. Isolate significant and insignificant SNPs for  Smallmouth Bass only; run the Rmd chunk below:

##### Outlier SNP identification for all black bass samples:
```{r}
# Append SNP IDs to data
smallmouth_fst <- cbind(metadata_snps, smallmouth_fst)

# Isolate SNPs with log_po greater than or equal to 0.5
smallmouth_significant <- smallmouth_fst %>% 
      filter(log_po >= 0.5) 

# Isolate SNPs with log_po less than 0.5
smallmouth_not_significant <- smallmouth_fst %>% 
      filter(log_po < 0.5) 

# Put log_po in descending order to analyze significance level 
smallmouth_significant <- smallmouth_significant %>%
  arrange(desc(log_po))

# count SNPs that are decisively under selection
smallmouth_significant %>% 
  filter(log_po >= 2) %>% 
  count()

# count SNPs that are under very strong selection
smallmouth_significant %>% 
  filter(log_po >= 1.5 & log_po < 2) %>% 
  count()

# count SNPs that are under strong selection
smallmouth_significant %>% 
  filter(log_po >= 1 & log_po < 1.5) %>% 
  count()

# count SNPs that are under very strong selection
smallmouth_significant %>% 
  filter(log_po >= 0.5 & log_po < 1) %>% 
  count()

# Append column for selection status ("selection"; significant or not signficant)
smallmouth_significant$selection <- c(rep("significant", times = 6))
smallmouth_not_significant$selection <- c(rep("insignificant", times = 50822))

# Append column for significance level ("sig_level"; decisive, very strong, substantial)
smallmouth_significant$sig_level <- c(rep("substantial", times = 6))

smallmouth_not_significant$sig_level <- c(rep("not_significant", times = 50822))

#combine data into one dataframe
smallmouth_fst <- rbind(smallmouth_significant, smallmouth_not_significant)
```

#### 2c: Filter datasets to omit SNPs with log_po values of 1000 for clean visualization (because they distort the figure).

##### Omit SNPs with log_po greater than or equal to 1000; run the Rmd chunk below:

##### Omit SNPs with log_po greater than or equal to 1000:
```{r}
# Get SNPs with log_po = 1000 for all black bass samples
all_1000 <- all_fst %>% 
      filter(log_po >= 1000) 

# Get SNPs with log_po < 1000 for all black bass samples
all_clean <- all_fst %>% 
      filter(log_po < 1000) 

# Get SNPs with log_po = 1000 for species complex samples
species_complex_1000 <- species_complex_fst %>% 
      filter(log_po >= 1000) 

# Get SNPs with log_po < 1000 for all species complex samples
species_complex_clean <- species_complex_fst %>% 
      filter(log_po < 1000) 

# Get SNPs with log_po = 1000 for species complex samples
neosho_1000 <- neosho_fst %>% 
      filter(log_po >= 1000)

# Get SNPs with log_po < 1000 for Neosho Bass samples
neosho_clean <- neosho_fst %>% 
      filter(log_po < 1000) #extract only snps with log10 less than 1000

# Get SNPs with log_po = 1000 for Smallmouth Bass samples
smallmouth_1000 <- smallmouth_fst %>% 
      filter(log_po >= 1000) 

# Get SNPs with log_po < 1000 for Smallmouth Bass samples
smallmouth_clean <- smallmouth_fst %>% 
      filter(log_po < 1000) #extract only snps with log10 less than 1000

```

### STEP 3: Plot BAYESCAN Fst results
In this step, we are using the Fst data inferred from BAYESCAN to plot Fst as a function of log posterior odds, which shows the distribution of Fst values and their respective signficance.

#### 3a: Generate plots for each hierarchical analysis; run the Rmd chunk below:
We chose to include each plot as separate panels in one figure. The plots are named "a", "b", "c", and "d", and appear in that order in the final manuscript. We colored points and included dotted lines to indicate significance level.

##### Generate plot for all black bass samples: `figures/bayescan_figures/fst.pdf`
```{r}
# Plot for all black bass samples
a <- ggplot(all_clean, aes(x = log_po, y = fst, fill = sig_level)) + 
      geom_point(aes(fill = sig_level), alpha = 0.8, color = "black", pch = 21, size = 4, show.legend = F) +
      geom_vline(xintercept = 2, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1.5, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1, linetype = "longdash", color = "black") +
      geom_vline(xintercept = 0.5, linetype = "longdash", color = "black") + 
      theme_set(theme_cowplot(12)) + 
      scale_fill_manual(values = c("grey","#FCFFA4FF","#BB3754FF")) +
      labs(x = "Log10(Posterior Odds)", y = "FST") + 
      theme(axis.title = element_text(size = 20, color = "black")) +
      theme(axis.text = element_text(size = 15, color = "black")) + 
      theme(axis.line = element_line(color = "black")) +
      theme(axis.ticks = element_line(color = "black")) +
      theme(axis.title.x = element_blank()) +
      theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
      ylab(expression(F[ST])) +
      xlab(expression(log[10]~{("posterior odds")}))

# Plot for species complex samples
b <- ggplot(species_complex_clean, aes(x = log_po, y = fst, fill = sig_level)) +
      geom_point(aes(fill = sig_level), alpha = 0.8, color = "black", pch = 21, size = 4, show.legend = F) +
      geom_vline(xintercept = 2, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1.5, linetype = "longdash", color = "black") +
      geom_vline(xintercept = 1, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 0.5, linetype = "longdash", color = "black") + 
      theme_set(theme_cowplot(12)) + 
      scale_fill_manual(values = c("#56106EFF","grey","#F98C0AFF","#FCFFA4FF","#BB3754FF")) + 
      labs(x = "Log10(Posterior Odds)", y = "FST") + 
      theme(axis.title = element_text(size = 20, color = "black")) + 
      theme(axis.text = element_text(size = 15, color = "black")) + 
      theme(axis.line = element_line(color = "black")) +
      theme(axis.ticks = element_line(color = "black")) +
      theme(axis.title.x = element_blank()) +
      theme(axis.title.y = element_blank())  +
      theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
      ylab(expression(F[ST])) +
      xlab(expression(log[10]~{("posterior odds")}))

# Plot for Neosho BAss samples
c <- ggplot(neosho_clean, aes(x = log_po, y = fst, fill = sig_level)) + 
      geom_point(aes(fill = sig_level), alpha = 0.8, color = "black", pch = 21, size = 4, show.legend = F) + 
      geom_vline(xintercept = 2, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1.5, linetype = "longdash", color = "black") +
      geom_vline(xintercept = 1, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 0.5, linetype = "longdash", color = "black") + 
      theme_set(theme_cowplot(12)) +
      scale_fill_manual(values = c("#56106EFF","grey","#F98C0AFF","#FCFFA4FF","#BB3754FF")) + 
      labs(x = "Log10(Posterior Odds)", y = "FST") + 
      theme(axis.title = element_text(size = 20, color = "black")) +
      theme(axis.text = element_text(size = 15, color = "black")) + 
      theme(axis.line = element_line(color = "black")) +
      theme(axis.ticks = element_line(color = "black")) +
      theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
      ylab(expression(F[ST])) +
      xlab(expression(log[10]~{("posterior odds")}))

# Plot for Smallmouth Bass samples
d <- ggplot(smallmouth_clean, aes(x = log_po, y = fst, fill = sig_level)) + 
      geom_point(aes(fill = sig_level), alpha = 0.8, color = "black", pch = 21, size = 4, show.legend = F) + 
      geom_vline(xintercept = 2, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1.5, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 0.5, linetype = "longdash", color = "black") + 
      theme_set(theme_cowplot(12)) + 
      scale_fill_manual(values = c("grey","#FCFFA4FF")) + 
      labs(x = "Log10(Posterior Odds)", y = "FST") + 
      theme(axis.title = element_text(size = 20, color = "black")) + 
      theme(axis.text = element_text(size = 15, color = "black")) + 
      theme(axis.title.y = element_blank()) + 
      theme(axis.line = element_line(color = "black")) +
      theme(axis.ticks = element_line(color = "black"))  +
      theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
      ylab(expression(F[ST])) +
      xlab(expression(log[10]~{("posterior odds")}))

# Put plots together
pdf("figures/bayescan_figures/fst.pdf", width=13, height=10)

plot_grid(a,b,c,d, 
          nrow = 2, 
          align = "hv", 
          labels = c("a","b","c","d"), 
          label_size = 25)

dev.off()
```

This figure was used as the basis for Supplementary Figure 6 in our manuscript.

### ----------------------- END OF PHASE 2: OUTLIER ANALYSIS WITH BAYESCAN ----------------------- ###

## PHASE 3: OUTLIER ANALYSIS WITH PCADAPT
In this phase of the analysis, we are using the R package PCADAPT to conduct a genome scan for SNP loci with outlier Fst values to assess potential signatures of local directional selection and neutrality at various loci. We are conducting this analysis at four hierarchical levels, as listed in the description for Phase 1 of the analysis (see above). We are using input data for each hierarchical level of analysis as generated in Phase 1 of this analysis.

PCADAPT uses a multivariate framework (Principal Component Analysis; PCA) to account for population structure among populations and determine likely outlier SNPs driving differentiation between populations.

### STEP 1: Read in input data for PCADAPT, which are the .bed format files generated in Phase 1 above, and prepare sample metadata

#### 1a: Read in .bed files for all hierarchical analyses; run the Rmd chunk below:

###### Read in input data:
```{r, include=FALSE}
# Read in data for all black bass samples
all_bed <- read.pcadapt("data/processed_bed/01_all_output/01_all.bed", type = "bed") 

# Read in data for species complex samples
species_complex_bed <- read.pcadapt("data/processed_bed/02_species_complex_output/02_species_complex.bed", type = "bed") 

# Read in data for Neosho Bass samples
neosho_bed <- read.pcadapt("data/processed_bed/03_neosho_output/03_neosho.bed", type = "bed")

# Read in data for Smallmouth Bass samples
smallmouth_bed <- read.pcadapt("data/processed_bed/04_smallmouth_output/04_smallmouth.bed", type = "bed") 
```

#### 1b: Filter sample metadata to include only individuals and their corresponding populations in each hierarchical analysis. Population IDs will be used for later plotting; run the Rmd chunk below:

##### Generate sample metadata for plotting:
```{r}
# Load in raw metadata
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

# Generate metadata for all black bass samples
all_metadata <- metadata_populations_spb %>%
  filter(sample_id != "BFC10_1")

# Generate metadata for species complex samples
species_complex_metadata <- metadata_populations_spb %>%
  filter(sample_id != "BFC10_1") %>%
  filter(population != "SPB")

# Generate metadata for Neosho Bass samples
neosho_metadata <- metadata_populations_spb %>%
  filter(sample_id != "BFC10_1") %>%
  filter(population != "SPB") %>%
  filter(population != "MISS") %>%
  filter(population != "WHITE") %>%
  filter(population != "SKIA")

# Generate metadata for Smallmouth Bass samples
smallmouth_metadata <- metadata_populations_spb %>%
  filter(sample_id != "BFC10_1") %>%
  filter(population != "SPB") %>%
  filter(population != "MIDARK") %>%
  filter(population != "LMULB") %>%
  filter(population != "ELK") %>%
  filter(population != "ILLI") %>%
  filter(population != "BAYOU") %>%
  filter(population != "UPPARK")

# Convert population lists for each metadata file into vectors

# Make vector for all black bass populations
all_pops <- as.vector(all_metadata[,c(2)])

# Make vector for species complex populations
species_complex_pops <- as.vector(species_complex_metadata[,c(2)])

# Make vector for Neosho Bass populations
neosho_pops <- as.vector(neosho_metadata[,c(2)])

# Make vector for Smallmouth Bass populations
smallmouth_pops <- as.vector(smallmouth_metadata[,c(2)])
```

### STEP 2: Run PCADAPT Analysis on all hierarchical levels. 

#### 2a: Run PCAdapt analysis for a possible K = 1-20 and with a minimum allele frequency threshold of 0.0001. 
PCADAPT explicitly accounts for population structure in the data by testing different possible numbers of K clusters (similar in principle to the program ADMIXTURE). The minor allele frequency threshold is just a placeholder here for the the analysis to run

##### 2a.1. Run PCAdapt analysis; run the Rmd chunk below:

##### Run PCA through PCAdapt to identify outlier SNPs:
```{r}
#Run PCAdapt for all black bass samples 
all_pca_k20 <- pcadapt(all_bed, K = 20, min.maf = 0.0001) 

#Run PCAdapt for species complex samples 
species_complex_pca_k20 <- pcadapt(species_complex_bed, K = 20, min.maf = 0.0001)

#Run PCAdapt for Neosho Bass samples 
neosho_pca_k20 <- pcadapt(neosho_bed, K = 20, min.maf = 0.0001)

#Run PCAdapt for Smallmouth Bass samples 
smallmouth_pca_k20 <- pcadapt(smallmouth_bed, K = 20, min.maf = 0.0001)
```

##### 2a.2. Choose the optimal number of K PCAs to retain in downstream analyses by assessing Scree plots; run the Rmd chunk below:

##### Visualize Scree plots:
```{r}
#Scree plot for all black bass samples 
all_scree <- plot(all_pca_k20, option = "screeplot") 

#Scree plot for species complex samples 
species_complex_scree <- plot(species_complex_pca_k20, option = "screeplot") 

#Scree plot for Neosho Bass samples 
neosho_scree <- plot(neosho_pca_k20, option = "screeplot") 

#Scree plot for Smallmouth Bass samples 
smallmouth_scree <- plot(smallmouth_pca_k20, option = "screeplot") 
```
Here, we used Catell's Rule to determine the optimal number of clusters to retain in PC analysis. Thus, we chose the number of K PCs to retain based on where the Scree plot line began to plateau. We then reran PCADAPT analysis on the optimal number of K to determine the amount of variance explained by that number of PCs in downstream analyses.

##### 2a.3. Extract Scree plot variance explained information and generate figures.
In tis step, we are extracting information on the variance explained by each Principal Component in the PCAs calculated with K = 20 above and plotting these data.

###### 2a.3.1. Summarize variance information from each hierarchical analysis; run the Rmd chunk below:

##### Generate Scree plot figures for publication:
```{r}
## Generate variance data for all black bass samples at K = 20

# Get root variance information from PCA calculation above
all_pca_variance_k20 <- data.frame(root_variance = as.numeric(all_pca_k20$singular.values))

# Calculate variance 
all_pca_variance_k20 <- all_pca_variance_k20 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
all_pca_variance_k20 <- rownames_to_column(all_pca_variance_k20, "K")

# Convert K to numeric vector
all_pca_variance_k20 <- all_pca_variance_k20 %>% 
   mutate(K = as.numeric(K))


## Generate variance data for species complex samples at K = 20

# Get root variance information from PCA calculation above
species_complex_pca_variance_k20 <- data.frame(root_variance = as.numeric(species_complex_pca_k20$singular.values))

# Calculate variance 
species_complex_pca_variance_k20 <- species_complex_pca_variance_k20 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
species_complex_pca_variance_k20 <- rownames_to_column(species_complex_pca_variance_k20, "K")

# Convert K to numeric vector
species_complex_pca_variance_k20 <- species_complex_pca_variance_k20 %>% 
   mutate(K = as.numeric(K))


## Generate variance data for Neosho Bass samples at K = 20

# Get root variance information from PCA calculation above
neosho_pca_variance_k20 <- data.frame(root_variance = as.numeric(neosho_pca_k20$singular.values))

# Calculate variance 
neosho_pca_variance_k20 <- neosho_pca_variance_k20 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
neosho_pca_variance_k20 <- rownames_to_column(neosho_pca_variance_k20, "K")

# Convert K to numeric vector
neosho_pca_variance_k20 <- neosho_pca_variance_k20 %>% 
   mutate(K = as.numeric(K))


## Generate variance data for Smallmouth Bass samples at K = 20

# Get root variance information from PCA calculation above
smallmouth_pca_variance_k20 <- data.frame(root_variance = as.numeric(smallmouth_pca_k20$singular.values))

# Calculate variance 
smallmouth_pca_variance_k20 <- smallmouth_pca_variance_k20 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
smallmouth_pca_variance_k20 <- rownames_to_column(smallmouth_pca_variance_k20, "K")

# Convert K to numeric vector
smallmouth_pca_variance_k20 <- smallmouth_pca_variance_k20 %>% 
   mutate(K = as.numeric(K))

## Summarize information on total variance explained by 20 PCs for each dataset
sum(all_pca_variance_k20$variance) #96.19% 
sum(species_complex_pca_variance_k20$variance) #59.80% 
sum(neosho_pca_variance_k20$variance) #53.52% 
sum(smallmouth_pca_variance_k20$variance) #100.00% 
```

###### 2a.3.2. Generate variance explained figures; run the Rmd chunk below:
Here, we have chosen to include all individual Scree plots as panels in a single plot. Panels are labeled "a", "b", "c", and "d", and are presented in the figure in that order.

##### Generate Scree plot figure: `figures/pcadapt_figures/variance.pdf`
```{r}
## NOTE: Plots are named a,c,e,g because they are appended to the PCA plots generated below for the final publication. Those PCA plots have the missing letters (b,d,f,h)

# Plot for all black bass samples
a <- ggplot(all_pca_variance_k20, aes(x = K, y = variance)) + 
   geom_point(size = 3) + 
   geom_path(stat = "identity", size = 1) + 
   geom_vline(xintercept = 2, linetype = "longdash") +
   scale_x_continuous("Number of PCs Retained", labels = as.character(all_pca_variance_k20$K), breaks = all_pca_variance_k20$K) +
   labs(x = "Number of PCs Retained", y = "% Variance Explained") +
   theme_set(theme_cowplot(12)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for species complex samples
c <- ggplot(species_complex_pca_variance_k20, aes(x = K, y = variance)) + 
   geom_point(size = 3) + 
   geom_path(stat = "identity", size = 1) + 
   geom_vline(xintercept = 3, linetype = "longdash") +
   scale_x_continuous("Number of PCs Retained", labels = as.character(species_complex_pca_variance_k20$K), breaks = species_complex_pca_variance_k20$K) +
   labs(x = "Number of PCs Retained", y = "% Variance Explained") +
   theme_set(theme_cowplot(12)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(axis.title.x = element_text(face = "italic")) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for Neosho Bass samples
e <- ggplot(neosho_pca_variance_k20, aes(x = K, y = variance)) + 
   geom_point(size = 3) + 
   geom_path(stat = "identity", size = 1) + 
   geom_vline(xintercept = 4, linetype = "longdash") +
   scale_x_continuous("Number of PCs Retained", labels = as.character(neosho_pca_variance_k20$K), breaks = neosho_pca_variance_k20$K) +
   labs(x = "Number of PCs Retained", y = "% Variance Explained") +
   theme_set(theme_cowplot(12)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(axis.title.x = element_text(face = "italic")) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for Smallmouth Bass samples
g <- ggplot(smallmouth_pca_variance_k20, aes(x = K, y = variance)) + 
   geom_point(size = 3) + 
   geom_path(stat = "identity", size = 1) + 
   geom_vline(xintercept = 3, linetype = "longdash") +
   scale_x_continuous("Number of PCs Retained", labels = as.character(smallmouth_pca_variance_k20$K), breaks = smallmouth_pca_variance_k20$K) +
   labs(x = "Number of PCs Retained", y = "% Variance Explained") +
   theme_set(theme_cowplot(12)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot all figures together in a single pdf.
pdf("figures/pcadapt_figures/variance.pdf", width=7, height=17) 

plot_grid(a,c,e,g, nrow = 4, labels = c("a","c","e","g"), label_size = 30, label_y = 1.03)

dev.off()
```

This plot is later combined with the associated PCA plots for one composite figure in the manuscript (see below)

#### 2b: Re-run PCADAPT analysis for the number of K clusters inferred using Catell's rule.

##### 2b.1. Re-run PCADAPT for all hierarchical analyses; run the Rmd chunk below:

##### PCADAPT analyses for optimal number of K clusters/PCs:
```{r}
#Run PCAdapt for all black bass samples at K = 2
all_pca_k2 <- pcadapt(all_bed, K = 2, min.maf = 0.0001)

#Run PCAdapt for species complex samples at K = 2
species_complex_pca_k2 <- pcadapt(species_complex_bed, K = 2, min.maf = 0.0001)

#Run PCAdapt for Neosho Bass samples at K = 4
neosho_pca_k4 <- pcadapt(neosho_bed, K = 4, min.maf = 0.0001)

#Run PCAdapt for Smallmout Bass samples at K = 3
smallmouth_pca_k3 <- pcadapt(smallmouth_bed, K = 3, min.maf = 0.0001)
```

##### 2b.2. Extract variance explained information and generate figures.
In tis step, we are extracting information on the variance explained by each Principal Component in the PCAs calculated with optimal number of K PCs above and plotting these data.

###### 2b.2.1. Summarize variance information from each hierarchical analysis; run the Rmd chunk below:

##### Generate Scree plot figures for publication:
```{r}
# Get root variance information from PCA calculation above
all_pca_variance_k2 <- data.frame(root_variance = as.numeric(all_pca_k2$singular.values))

# Calculate variance 
all_pca_variance_k2 <- all_pca_variance_k2 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
all_pca_variance_k2 <- rownames_to_column(all_pca_variance_k2, "K")

# Convert K to numeric vector
all_pca_variance_k2 <- all_pca_variance_k2 %>% 
   mutate(K = as.numeric(K))
   
# Get root variance information from PCA calculation above
species_complex_pca_variance_k2 <- data.frame(root_variance = as.numeric(species_complex_pca_k2$singular.values))

# Convert K to numeric vector
species_complex_pca_variance_k2 <- species_complex_pca_variance_k2 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
species_complex_pca_variance_k2 <- rownames_to_column(species_complex_pca_variance_k2, "K")

# Convert K to numeric vector
species_complex_pca_variance_k2 <- species_complex_pca_variance_k2 %>% 
   mutate(K = as.numeric(K))
   
# Get root variance information from PCA calculation above
neosho_pca_variance_k4 <- data.frame(root_variance = as.numeric(neosho_pca_k4$singular.values))

# Convert K to numeric vector
neosho_pca_variance_k4 <- neosho_pca_variance_k4 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
neosho_pca_variance_k4 <- rownames_to_column(neosho_pca_variance_k4, "K")

# Convert K to numeric vector
neosho_pca_variance_k4 <- neosho_pca_variance_k4 %>% 
   mutate(K = as.numeric(K))

# Get root variance information from PCA calculation above
smallmouth_pca_variance_k3 <- data.frame(root_variance = as.numeric(smallmouth_pca_k3$singular.values))

# Convert K to numeric vector
smallmouth_pca_variance_k3 <- smallmouth_pca_variance_k3 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
smallmouth_pca_variance_k3 <- rownames_to_column(smallmouth_pca_variance_k3, "K")

# Convert K to numeric vector
smallmouth_pca_variance_k3 <- smallmouth_pca_variance_k3 %>% 
   mutate(K = as.numeric(K))

   
## Summarize information on total variance explained by 20 PCs for each dataset
sum(all_pca_variance_k2$variance) #68.68% 
sum(species_complex_pca_variance_k2$variance) #24.04% 
sum(neosho_pca_variance_k4$variance) #18.78% 
sum(smallmouth_pca_variance_k3$variance) #33.62% 
```

###### 2b.2.2. Generate PCA figures for optimal number of K; run the Rmd chunk below:

##### Generate PCA figure: `figures/pcadapt_figures/pca.pdf`
```{r}
## Extract PC information for all black bass samples

# Get PC scores
all_pca_k2_scores <- as.data.frame(all_pca_k2$scores)

# Append population names to PC scores
all_pca_k2_scores <- cbind(data.frame(all_pops), all_pca_k2_scores)

# Modify column names
colnames(all_pca_k2_scores) <- c("pop","PC1","PC2")


## Extract PC information for species complex samples

# Get PC scores
species_complex_pca_k2_scores <- as.data.frame(species_complex_pca_k2$scores)

# Append population names to PC scores
species_complex_pca_k2_scores <- cbind(data.frame(species_complex_pops), species_complex_pca_k2_scores)

# Modify column names
colnames(species_complex_pca_k2_scores) <- c("pop","PC1","PC2")


## Extract PC information for Neosho Bass samples

# Get PC scores
neosho_pca_k4_scores <- as.data.frame(neosho_pca_k4$scores)

# Append population names to PC scores
neosho_pca_k4_scores <- cbind(data.frame(neosho_pops), neosho_pca_k4_scores)

# Modify column names
colnames(neosho_pca_k4_scores) <- c("pop","PC1","PC2","PC3","PC4")


## Extract PC information for Neosho Bass samples

# Get PC scores
smallmouth_pca_k3_scores <- as.data.frame(smallmouth_pca_k3$scores)

# Append population names to PC scores
smallmouth_pca_k3_scores <- cbind(data.frame(smallmouth_pops), smallmouth_pca_k3_scores)

# Modify column names
colnames(smallmouth_pca_k3_scores) <- c("pop","PC1","PC2","PC3")


# Generate figure

# Plot for all black bass samples
b <- ggplot(all_pca_k2_scores, aes(x = PC1, y = PC2)) + 
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 4, show.legend = F) +
   labs(x = "PC1 (53.94 %)", y = "PC2 (14.74 %)", fill = "Species") +
   scale_fill_manual(values = c("lightgreen","sienna4","mediumpurple","forestgreen","deepskyblue","chocolate1","navyblue","goldenrod3","orchid1","deeppink2")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 15)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 15)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for species complex samples
d <- ggplot(species_complex_pca_k2_scores, aes(x = PC1, y = PC2)) + 
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 4, show.legend = F) +
   labs(x = "PC1 (18.50 %)", y = "PC2 (5.55 %)", fill = "Population") +
   scale_fill_manual(values = c("lightgreen","sienna4","mediumpurple","forestgreen","deepskyblue","chocolate1","navyblue","orchid1","deeppink2")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 15)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 15)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for Neosho Bass samples
f <- ggplot(neosho_pca_k4_scores, aes(x = PC1, y = PC2)) + 
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 4, show.legend = F) +
   labs(x = "PC1 (6.60 %)", y = "PC2 (5.22 %)", fill = "Population") +
   scale_fill_manual(values = c("lightgreen","sienna4","mediumpurple","forestgreen","deepskyblue","orchid1")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 15)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 15)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for Smallmouth Bass samples
h <- ggplot(smallmouth_pca_k3_scores, aes(x = PC1, y = PC2)) + 
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 4, show.legend = F) +
   labs(x = "PC1 (15.76 %)", y = "PC2 (11.25 %)", fill = "Population") +
   scale_fill_manual(values = c("chocolate1","navyblue","deeppink2")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 15)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 15)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Combine all PCA score plots 
pdf("figures/pcadapt_figures/pca.pdf", width=7, height=17) 

plot_grid(b,d,f,h, 
          nrow = 4, 
          labels = c("b","d","f","h"), 
          label_y = 1.03, 
          label_size = 30)

dev.off()
```

###### 2b.2.3. Generate Combined Scree and PCA figures for optimal number of K; run the Rmd chunk below:

##### Generate a combined Scree and PCA plot: `figures/pcadapt_figures/scree_pca.pdf`
```{r}
# Get a named version of the Scree plot figure
scree <-plot_grid(a,c,e,g, 
                  nrow = 4, 
                  labels = c("a","c","e","g"), 
                  label_size = 30, 
                  label_y = 1.03)

pca <- plot_grid(b,d,f,h, 
                 nrow = 4, 
                 labels = c("b","d","f","h"), 
                 label_y = 1.03, 
                 label_size = 30)


#Combine Scree and PCA plots
pdf("figures/pcadapt_figures/scree_pca.pdf", width=14, height=17) 

plot_grid(scree, 
          pca, 
          ncol = 2,
          align = "v")

dev.off()
```

### STEP 3: Identify outlier SNP loci.
In this step, we are identifying SNPs explaining the largest proportion of variance on each retained PC to determine SNPs potentially under selection.

#### 3a: 

## Get outlier SNPs using bonferroni p-value corrections
```{r}
all_p_vals_pca <- all_pca_K2$pvalues

#IMPORTANT NOTE: 4 SNPs were dropped here, because after removal of BFC10, 4 SNPs appear to be fixed for one allele (homozygous for a single SNP). 

#Adjust and clean p-values
all_p_vals_bonf <- p.adjust(all_p_vals_pca, method = "bonferroni") #adjust p-values for multiple test with bonferroni correction
all_p_vals_bonf <- as.data.frame(all_p_vals_bonf) #create dataframe from bonferroni corrected p-values
all_p_vals_bonf <- cbind(snp_ids_with_pos, all_p_vals_bonf) #append snp ids dataset to corrected p-values
all_p_vals_bonf <- all_p_vals_bonf[,c(1,3)]
colnames(all_p_vals_bonf) <- c("snp_id","p_val") #clean dataframe to include appropriate column lables
all_p_vals_bonf <- all_p_vals_bonf %>%
   drop_na() #50,824 SNPs left after removing fixed alleles

#Retrieve significant outlier snps
all_pcadapt_snps_significant <- all_p_vals_bonf %>% 
   filter(p_val < 0.05) #extract only snps with p-values less than 0.05

all_pcadapt_snps_not_significant <- all_p_vals_bonf %>% 
   filter(p_val >= 0.05) #extract only snps with p-values greater than or equal to 0.05

#Get the number of significant and non-significant SNPs from PCADAPT
dim(all_pcadapt_snps_significant) #16,358 SNPs
dim(all_pcadapt_snps_not_significant) #34,466 SNPs

all_bayescan_pcadapt_outlier_merged <- merge(all_pcadapt_snps_significant, bayescan_all_fst_significant, by = "snp_id")
all_bayescan_pcadapt_neutral_merged <- merge(all_pcadapt_snps_not_significant, bayescan_all_fst_not_significant, by = "snp_id")

#There are no shared outlier SNPs between datasets, so they will not be analyed further
#There are 34,463 neutral SNPs
```

## Outlier SNPs - SMB Samples Only

## Get outlier SNPs using bonferroni p-value corrections
```{r}
#Get outlier SNPs using various p-value corrections
smb_p_vals_pca <- smb_pca_K2$pvalues #extract p-values for each snp
smb_p_dropped <- as.data.frame(smb_p_vals_pca) %>% filter(is.na(smb_p_vals_pca)) # 7,951 dropped

###IMPORTANT NOTE: At this point, 7,951 SNPs were dropped from the analysis (and do not have p-values; NAs), because they are not true SNPs. They are fixed SNPs for all Smallmouth Bass samples. In other words, all 87 SMB individuals are homozygous for a single allele in this case.

###I thought that, at this point, it may be necessary to re-run my original, hierarchical datasets for SMB only, Neosho SMB only, and Northern SMB only, because minor allele frequency will change when any number of samples are dropped from a dataset. This will affect the number of SNPs that are filtered when different filter thresholds are set (for missing data, heterozygosity, minor allele frequency, etc.). However, I argue that this is NOT necessary, because my original filters were applied to the whole dataset, which is the dataset that was used to call SNPs in the first place. Minor allele frequency thresholds are typically used to filter out samples that have low minor allele frequencies due to sequencing error. Sequencing error should be evaluated at the level of the entire dataset (i.e. including every single sample). If samples are then removed from the dataset post-hoc, that will affect allele frequencies because the total number alleles in the dataset will change. But it will not affect the minor allele frequency due to sequencing errors. After post-hoc sample filtering, we should expect that minor allele frequencies below the originally established threshold are due to differences between the samples and potentially representative of biological differences.

#Adjust and clean p-values
smb_p_vals_bonf <- p.adjust(smb_p_vals_pca, method = "bonferroni") #adjust p-values for multiple test with bonferroni correction
smb_p_vals_bonf <- as.data.frame(smb_p_vals_bonf) #create dataframe from bonferroni corrected p-values
smb_p_vals_bonf <- cbind(snp_ids_with_pos, smb_p_vals_bonf) #append snp ids dataset to corrected p-values
smb_p_vals_bonf <- smb_p_vals_bonf[,c(1,3)]
colnames(smb_p_vals_bonf) <- c("snp_id","p_val") #clean dataframe to include appropriate column lables
smb_p_vals_bonf <- smb_p_vals_bonf %>%
   drop_na() #42,877 SNPs left after removing fixed alleles

#Retrieve significant outlier snps
smb_pcadapt_snps_significant <- smb_p_vals_bonf %>% 
   filter(p_val < 0.05) #extract only snps with p-values less than 0.05

smb_pcadapt_snps_not_significant <- smb_p_vals_bonf %>% 
   filter(p_val >= 0.05) #extract only snps with p-values greater than or equal to 0.05

#Get the number of significant and non-significant SNPs from PCADAPT
dim(smb_pcadapt_snps_significant) #1006 SNPs
dim(smb_pcadapt_snps_not_significant) #41,871 SNPs
```

## MERGE DATASETS
## Merge datasets for outlier SNPs and neutral SNPs for BAYESCAN and PCADAPT
```{r}
#Merge datasets for outlier SNPs and neutral SNPs for BAYESCAN and PCADAPT
smb_bayescan_pcadapt_outlier_merged <- merge(smb_pcadapt_snps_significant, bayescan_smb_lineages_fst_significant, by = "snp_id")
smb_bayescan_pcadapt_neutral_merged <- merge(smb_pcadapt_snps_not_significant, bayescan_smb_lineages_fst_not_significant, by = "snp_id")

#########This is where PCAdapt and Bayescan overlap#############

# 156 SNPs (signficant in both pcadapt analysis and bayescan)
# 41,324 SNPs (non-significant in both pcadapt analysis and bayescan)
```

###The Merge Datasets section combines the tabular output of both Bayescan and PCAdapt to identify individual SNPs that are signicant outliers in both types of analyses. SNPs that are identified as outliers in both types of analysis are considered to have stronger support as actual outliers. There are no separate subsections for this section. 
```{r}
#Write out tables with merged datasets to be used for making new vcfs with only outliers and only neutral SNPs
write.table(smb_bayescan_pcadapt_outlier_merged,"~/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/analysis/outlier_fst_analysis/by_lineages/smb_merged_datasets/smb_bayescan_pcadapt_outlier_merged.txt", sep="\t") #this is the combined dataset with significant snps, written out as a .txt file
write.table(smb_bayescan_pcadapt_neutral_merged,"~/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/analysis/outlier_fst_analysis/by_lineages/smb_merged_datasets/smb_bayescan_pcadapt_neutral_merged.txt", sep="\t") #this is the combined dataset with non-significant snps, written out as a .txt file

#Create table for significant snps (including snp id and position)
smb_sig_snps <- as.data.frame(smb_bayescan_pcadapt_outlier_merged[,c(1)]) #This dataset includes appended the names of each individual SNP
colnames(smb_sig_snps) <- c("snp_id")
smb_sig_snps_pos <- merge(smb_sig_snps, snp_ids_with_pos, by = "snp_id")

#Create table for neutral snps (including snp id and position)
smb_insig_snps <- as.data.frame(smb_bayescan_pcadapt_neutral_merged[,c(1)])
colnames(smb_insig_snps) <- c("snp_id")
smb_insig_snps_pos <- merge(smb_insig_snps, snp_ids_with_pos, by = "snp_id")
```

## Write out separate tables with outlier and neutral snps, respectively, for later analysis
```{r}
#Write out separate tables with outlier and neutral snps, respectively, for later analysis
write.table(smb_sig_snps_pos,"~/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/analysis/outlier_fst_analysis/by_lineages/smb_snps/smb_sig_snps.txt", sep="\t") #this is the dataset with only significant snps, including unique SNP ids
write.table(smb_insig_snps_pos,"~/Desktop/Grad_School_Stuff/Research/Projects/Smallmouth_Bass_Genomics/analysis/outlier_fst_analysis/by_lineages/smb_snps/smb_insig_snps.txt", sep="\t") #this is the dataset with only significant snps, including unique SNP ids

#IMPORTANT NOTE: both of these tables need to be further edited in excel so that they are compatible with vcftools for later editing. The first column (column identifiers) needs to be omitted, and the RAD_kmer_ tag on each SNP needs to be removed. Also, column headers need to be removed. 
```

## Outlier SNPs - Neosho Smallmouth Bass

## Get outlier SNPs using various p-value corrections
```{r}
#Get outlier SNPs using various p-value corrections
neosho_p_vals_pca <- neosho_pca_K4$pvalues #extract p-values for each snp

###IMPORTANT NOTE: At this point, 14,483 SNPs were dropped from the analysis (and do not have p-values; NAs), because they are not true SNPs. They are fixed SNPs for all Neosho Smallmouth Bass samples. In other words, all 63 Neosho individuals are homozygous for a single allele in this case.

#Adjust and clean p-values
neosho_p_vals_bonf <- p.adjust(neosho_p_vals_pca, method = "bonferroni") #adjust p-values for multiple test with bonferroni correction
neosho_p_vals_bonf <- as.data.frame(neosho_p_vals_bonf) #create dataframe from bonferroni corrected p-values
neosho_p_vals_bonf <- cbind(filtered_vcf_snp_ids, neosho_p_vals_bonf) #append snp ids dataset to corrected p-values
colnames(neosho_p_vals_bonf) <- c("snp_id","p_val") #clean dataframe to include appropriate column lables
neosho_p_vals_bonf <- neosho_p_vals_bonf %>%
   drop_na() #36,345 SNPs left after removing fixed alleles

#Retrieve significant outlier snps
neosho_pcadapt_snps_significant <- neosho_p_vals_bonf %>% 
   filter(p_val < 0.05) #extract only snps with p-values less than 0.05

neosho_pcadapt_snps_not_significant <- neosho_p_vals_bonf %>% 
   filter(p_val >= 0.05) #extract only snps with p-values greater than or equal to 0.05


#Get the number of significant and non-significant SNPs from PCADAPT
dim(neosho_pcadapt_snps_significant) #1304 SNPs
dim(neosho_pcadapt_snps_not_significant) #35,041 SNPs
```



### ----------------------- END OF PHASE 3: OUTLIER ANALYSIS WITH PCADAPT ----------------------- ###

## PHASE 4: OUTLIER MAPPING
In this phase of the analysis, we are conducting a multivariate analysis on SNPs either inferred to be significant outliers or neutral in both the BAYESCAN and PCADAPT genome scan analyses. Specifically, we are mapping <i>a priori</i> populations (determined in Analysis 4 (population inference)) onto multivariate space using outlier and neutral SNPs as response variables in Discriminant Analysis of Principal Components (DAPC).


### ----------------------- END OF PHASE 4: OUTLIER MAPPING ----------------------- ###


