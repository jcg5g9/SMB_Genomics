---
title: 'Analysis 6: Directional Selection Analysis'
author: "Joe Gunn"
date: "2022-09-03"
output: html_document
---

# Project: Population genomic analysis of Smallmouth Bass and Neosho Bass in the Central Interior Highlands
We investigated the extent of genomic divergence, local directional selection, and admixture between the Smallmouth Bass (<i>Micropterus dolomieu</i>) and the Neosho Bass (<i>M. velox</i>) in the Central Interior Highlands (CIH) ecoregion of central north America. Specifically, we used ddRADseq data to assessed the phylogenomic relationship between and within species, characterizing inter- and intraspecific diversity and SNPs potentially under local directional selection at the population level. Additionally, we inferred the relative timing of admxiture in Neosho Bass streams where there is known introgressive hybridization with Smallmouth Bass to understand the influence of natural, historic geographic factors on mixing (stream capture or transient flooding) vs. anthropogenic factors (i.e., non-native introductions through stocking), which is known to have occurred widely in these economically valuable species. We ultimately hoped to provide novel insights into the diversity of endemic, ecologically important and popular sport fish in the CIH.

## Specific Aim: Directional selection analysis
In this analysis, we used the popgen.vcf data generated in Analysis 2 (SNP Filtering...) to scan for signatures of directional selection on SNP loci with outlier Fst (high outlier Fst: directional selection; low Fst: balancing selection). We used two software programs with different underlying statistical frameworks to detect outliers and then used any outliers commonly detected in both analyses as canditates for being under strong selection. Specifically, we used the software program BAYESCAN (based in Bayesian analysis) and the R package PCAdapt principal component analysis (based in multivariate principal component analysis). We then employed DAPC in R to map patterns of population differentiation at any shared outlier and neutral loci to detect populations that may be under differential selection pressures and to detect signatures of genetic drift, respectively.

## Phases of analysis:
### Phase 1: Data preparation
### Phase 2: Outlier Fst analysis with BAYESCAN
### Phase 3: Outlier Fst analysis with PCADAPT
### Phase 4: Outlier mapping

## Libraries needed for analysis
```{r setup, echo = FALSE, include=FALSE}
library(readxl)
library(tidyverse)
library(cowplot)
library(devtools)
library(vcfR)
library(pcadapt)
library(adegenet)
library(viridis)
```

## PHASE 1: DATA PREPARATION
In this phase of the analysis, we are converting the fully filtered, thinned dataset excluding Spotted Bass and the Spotted Bass hybrid (`admixture_phylogenomics_analysis/data/processed_vcf/03_popgen_spb.vcf`) into input files compatible with the software programs BAYESCAN and the R package PCAdapt. For BAYESCAN, we are using the intermediate conversion software PGDSPIDER to generate input files, and for PCAdapt, we are again using the program PLINK.

For the outlier Fst analysis, we are conducing scans for outlier loci hiearchically at the black bass species level (between Spotted Bass, Smallmouth Bass, and Neosho Bass), among species within the Smallmouth Bass species complex (Smallmouth Bass and Neosho Bass), and among populations within black bass species. The goal with this structure is to reduce false positive detection due to population structure and to detect potentially selected SNPs at each hierarchical level.

With this analysis structure, we conducted scans with the following sets of data: 

1) All black bass samples, including Spotted Bass, Smallmouth Bass, and Neosho Bass (excluding the Spotted Bass hybrid)
2) All Smallmouth Bass and Neosho Bass samples, excluding Spotted Bass
3) All Neosho Bass populations only
4) All Smallmouth Bass populations only

All analyses conducted by calling commands in bash shell scripts were performed on the Lewis high-performance computing cluster at the University of Missouri <br>

<b>Programs needed</b>: <br><br>

PGDSPIDER v.2.1.1.5 (Lischer and Excoffier 2012) <br>

<b>Citation</b>:<br>

Lischer, H. E. L., E& Excoffier, L. (2012). PGDSpider: an automated data conversion tool fo connecting population genetics and genomics programs. Bionformatics, 28, 298-299. doi:/10.1093/bioinformatics/btr642


PLINK v.1.90p (high-contig build; Change et al. 2015) <br>

<b>Citation</b>:<br>

Chang, C. C., Chow, C. C., Tellier, L. C. A. M., Vattikuti, S., Purcell, S. M., & Lee, J. J. (2015). Second-generation PLINK: Rising to the challenge of larger and richer datasets. GigaScience, 4, 1–16. doi:10.1186/s13742-015-0047-8

### STEP 1: Prepare input data for BAYESCAN.
In this step, we are using the conversion software PGDSPIDER to prepare all input data for the software program BAYESCAN.

#### 1a: Filter fully filtered, thinned VCF file (excluding Spotted Bass hybrid) for each analysis level 
In this step, we are generating filtered VCF data to to run each level of the outlier Fst analysis (see above for the four hierarchical levels of analysis)  

##### 1a.1. Generate a general bash shell script header for all VCF filtering steps commands
In this step, we are generating a universal bash shell script to run all filtering commands in VCFTOOLS (See Phase 1 in Analysis 2 for programs needed and citation information). Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all VCFTOOLS code is called "vcftools.sh".

###### 1a.1.1. Copy and paste the code below in a new shell script file:

##### Generate VCFTOOLS bash shell script: `code/shell_scripts/vcftools.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J filter_admixed  # give the job a custom name
#SBATCH -o filtering_missing.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

## UNCOMMENT LINES STARTING HERE 

## Load VCFtools module
# module load rss/rss-2020
# module load vcftools/vcftools-v0.1.14
```

##### 1a.2. Generate lists of individuals to use for all filtering steps.
In this step, we are generating lists of individuals to filter from the VCF dataset. For the first level of analysis (all black bass samples, we are not excluding any samples). For the second level of analysis, we are excluding Spotted Bass. For the third level of analysis, we are excluding all Smallmouth Bass to retain only Neosho Bass. For the fourth analysis, we are excluding all Neosho Bass to retain only Smallmouth Bass.

###### 1a.2.1. Generate a list of Spotted Bass to omit from analyses 2, 3, and 4.

##### Generate list file: `data/filtering_data/spotted_bass.txt`
```{r}
# Load in full metadata
load("../raw_data/metadata.Rda")

# Filter all individuals but Spotted Bass
spotted_bass <- metadata %>%
  filter(species == "Spotted_Bass")

# Convert to dataframe
spotted_bass <- data.frame(spotted_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(spotted_bass, 
          file = "data/filtering_data/spotted_bass.txt", 
          col_names = FALSE)

# Turn column into vector without column name to save as un-headered list for downstream filtering
spotted_bass <- as.vector(spotted_bass$sample_id)

# Save the list of bad samples as a .Rda file without column names
save(spotted_bass, file = "data/filtering_data/spotted_bass.Rda")
```

###### 1a.2.2. Generate a list of Smallmouth Bass to omit from analysis 3.

##### Generate list file: `data/filtering_data/smallmouth_bass.txt`
```{r}
# Filter all individuals but Spotted Bass
smallmouth_bass <- metadata %>%
  filter(species == "Smallmouth_Bass")

# Convert to dataframe
smallmouth_bass <- data.frame(smallmouth_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(smallmouth_bass, 
          file = "data/filtering_data/smallmouth_bass.txt", 
          col_names = FALSE)

# Turn column into vector without column name to save as un-headered list for downstream filtering
smallmouth_bass <- as.vector(smallmouth_bass$sample_id)

# Save the list of bad samples as a .Rda file without column names
save(smallmouth_bass, file = "data/filtering_data/smallmouth_bass.Rda")
```

###### 1a.2.3. Generate a list of Neosho Bass to omit from analysis 4.

##### Generate list file: `data/filtering_data/neosho_bass.txt`
```{r}
# Filter all individuals but Spotted Bass
neosho_bass <- metadata %>%
  filter(species == "Neosho_Bass")

# Convert to dataframe
neosho_bass <- data.frame(neosho_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(neosho_bass, 
          file = "data/filtering_data/neosho_bass.txt", 
          col_names = FALSE)

# Turn column into vector without column name to save as un-headered list for downstream filtering
neosho_bass <- as.vector(neosho_bass$sample_id)

# Save the list of bad samples as a .Rda file without column names
save(neosho_bass, file = "data/filtering_data/neosho_bass.Rda")
```

#### 1a.3. Filter VCF files.

##### 1a.3.1. Filter out Spotted Bass to generate VCF for species complex samples (Smallmouth Bass and Neosho Bass); copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 01: omit Spotted Bass individuals to get samples at the species complex level (Smallmouth Bass and Neosho Bass only)
#vcftools --vcf ../../data/processed_vcf/01_popgen_spb_hybrid.vcf --remove ../../data/filtering_data/spotted_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/02_popgen_species_complex
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/02_popgen_species_complex.vcf`.

##### 1a.3.2. Filter out Smallmouth Bass to generate VCF for Neosho Bass samples (Neosho Bass only); copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 02: omit Smallmouth Bass samples to get only Neosho samples for the Neosho Bass population level
#vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --remove ../../data/filtering_data/smallmouth_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/03_popgen_neosho
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/03_popgen_neosho.vcf`.

##### 1a.3.3. Filter out Smallmouth Bass to generate VCF for Smallmouth Bass samples (Smallmouth Bass only); copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 03: omit Neosho Bass samples to get only Smallmouth Bass samples for the Smallmouth Bass population level
#vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --remove ../../data/filtering_data/neosho_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/04_popgen_smallmouth
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/03_popgen_neosho.vcf`.

#### 1b: Generate PGDSPIDER accompanying SPID files
In this step, we are generating text scripts for an accompanying file needed for PGDSPIDER conversions called a "spid" file. This file includes specific parameters that must to be completed for each file conversion in order to generate the correct output.

##### 1b.1. Generate a general text script for PGDSPIDER SPID file
Here, we only provide the base script without any parameters filled in. In subsequent steps, we include the completed version for each file conversion with specific parameters. The base script is called "spid.spid".

###### 1b.1.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/spid.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=
```

##### 1b.2. Generate a PGDSPIDER SPID file for the black bass level genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the Black Bass level genome scan, which includes all Spotted Bass, Smallmouth Bass, and Neosho Bass.

###### 1b.2.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/01_all.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/01_all_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

##### 1b.3. Generate a PGDSPIDER SPID file for the Smallmouth Bass species complex genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the species complex level genome scan, which includes all Smallmouth Bass and Neosho Bass.

###### 1b.3.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/02_species_complex.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/02_species_complex_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

##### 1b.4. Generate a PGDSPIDER SPID file for the Neosho Bass genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the Neosho Bass population level genome scan, which includes all Neosho Bass only

###### 1b.4.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/03_neosho.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/03_neosho_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

##### 1b.5. Generate a PGDSPIDER SPID file for the Neosho Bass genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the Smallmouth Bass population level genome scan, which includes all Smallmouth Bass only

###### 1b.5.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/04_smallmouth.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/04_smallmouth_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

#### 1c: Generate population designation files (read by SPID files)
In this step, we are generating text files listing all samples in at each genome scan level and their corresponding population designations as inferred in Analysis 4 (population inference). Our inferred populations were named according to their general geographic locations (see Phase 4 of population_analysis, "MIDARK", "ELK", "BAYOU", etc.), but PGDSPIDER expects input populations in a specific format (i.e., "pop_1", "pop_2", etc.). We generate population files according to this naming convention

##### 1c.1. Read in sample metadata and generate lists of populations for the black bass species level.

###### 1c.1.1 Generate population file for all black bass samples (Spotted Bass, Smallmouth Bass, and Neosho Bass); run the Rmd chunk below:

##### Generate population file: `data/pop_files/01_all_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

# Convert factors to characters
metadata_populations_spb <- metadata_populations_spb %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_spb$population[metadata_populations_spb$population == "MIDARK"] <- "pop_1"
metadata_populations_spb$population[metadata_populations_spb$population == "MISS"] <- "pop_2"
metadata_populations_spb$population[metadata_populations_spb$population == "SKIA"] <- "pop_3"
metadata_populations_spb$population[metadata_populations_spb$population == "LMULB"] <- "pop_4"
metadata_populations_spb$population[metadata_populations_spb$population == "WHITE"] <- "pop_5"
metadata_populations_spb$population[metadata_populations_spb$population == "ELK"] <- "pop_6"
metadata_populations_spb$population[metadata_populations_spb$population == "ILLI"] <- "pop_7"
metadata_populations_spb$population[metadata_populations_spb$population == "UPPARK"] <- "pop_8"
metadata_populations_spb$population[metadata_populations_spb$population == "BAYOU"] <- "pop_9"
metadata_populations_spb$population[metadata_populations_spb$population == "SPB"] <- "pop_10"

# Generate text file
write_delim(metadata_populations_spb, 
          delim = " ",
          file = "data/pop_files/01_all_pops.txt", 
          col_names = FALSE)
```

##### 1c.2. Read in sample metadata and generate lists of populations for the species complex level.

###### 1c.2.1 Generate population file for species complex samples (Smallmouth Bass and Neosho Bass); run the Rmd chunk below:

##### Generate population file: `data/pop_files/02_species_complex_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

# Filter out Spotted Bass
metadata_populations_complex <- metadata_populations_spb %>%
  filter(population != "SPB")

# Convert factors to characters
metadata_populations_complex <- metadata_populations_complex %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_complex$population[metadata_populations_complex$population == "MIDARK"] <- "pop_1"
metadata_populations_complex$population[metadata_populations_complex$population == "MISS"] <- "pop_2"
metadata_populations_complex$population[metadata_populations_complex$population == "SKIA"] <- "pop_3"
metadata_populations_complex$population[metadata_populations_complex$population == "LMULB"] <- "pop_4"
metadata_populations_complex$population[metadata_populations_complex$population == "WHITE"] <- "pop_5"
metadata_populations_complex$population[metadata_populations_complex$population == "ELK"] <- "pop_6"
metadata_populations_complex$population[metadata_populations_complex$population == "ILLI"] <- "pop_7"
metadata_populations_complex$population[metadata_populations_complex$population == "UPPARK"] <- "pop_8"
metadata_populations_complex$population[metadata_populations_complex$population == "BAYOU"] <- "pop_9"

# Generate text file
write_delim(metadata_populations_complex, 
          delim = " ",
          file = "data/pop_files/02_species_complex_pops.txt", 
          col_names = FALSE)
```

##### 1c.3. Read in sample metadata and generate lists of populations for the Neosho Bass level.

###### 1c.3.1 Generate population file for Neosho Bass samples (Neosho Bass only); run the Rmd chunk below:

##### Generate population file: `data/pop_files/03_neosho_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

# Filter out Spotted Bass and Smallmouth Bass
metadata_populations_neosho <- metadata_populations_spb %>%
  filter(population != "SPB") %>%
  filter(population != "MISS") %>%
  filter(population != "SKIA") %>%
  filter(population != "WHITE")

# Convert factors to characters
metadata_populations_neosho <- metadata_populations_neosho %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_neosho$population[metadata_populations_neosho$population == "MIDARK"] <- "pop_1"
metadata_populations_neosho$population[metadata_populations_neosho$population == "LMULB"] <- "pop_2"
metadata_populations_neosho$population[metadata_populations_neosho$population == "ELK"] <- "pop_3"
metadata_populations_neosho$population[metadata_populations_neosho$population == "ILLI"] <- "pop_4"
metadata_populations_neosho$population[metadata_populations_neosho$population == "UPPARK"] <- "pop_5"
metadata_populations_neosho$population[metadata_populations_neosho$population == "BAYOU"] <- "pop_6"

# Generate text file
write_delim(metadata_populations_neosho, 
          delim = " ",
          file = "data/pop_files/03_neosho_pops.txt", 
          col_names = FALSE)
```

##### 1c.4. Read in sample metadata and generate lists of populations for the Smallmouth Bass level.

###### 1c.4.1 Generate population file for Smallmouth Bass samples (Smallmouth Bass only); run the Rmd chunk below:

##### Generate population file: `data/pop_files/04_neosho_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

# Filter out Spotted Bass and Neosho Bass
metadata_populations_smallmouth <- metadata_populations_spb %>%
  filter(population != "SPB") %>%
  filter(population != "MIDARK") %>%
  filter(population != "ELK") %>%
  filter(population != "ILLI") %>%
  filter(population != "LMULB") %>%
  filter(population != "BAYOU") %>%
  filter(population != "UPPARK")

# Convert factors to characters
metadata_populations_smallmouth <- metadata_populations_smallmouth %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_smallmouth$population[metadata_populations_smallmouth$population == "WHITE"] <- "pop_1"
metadata_populations_smallmouth$population[metadata_populations_smallmouth$population == "MISS"] <- "pop_2"
metadata_populations_smallmouth$population[metadata_populations_smallmouth$population == "SKIA"] <- "pop_3"

# Generate text file
write_delim(metadata_populations_smallmouth, 
          delim = " ",
          file = "data/pop_files/04_smallmouth_pops.txt", 
          col_names = FALSE)
```

#### 1d: Generate a general bash shell script header for all PGDSPIDER conversion commands.
In this step, we are generating a universal bash shell script to run all file type conversions in PGDSPIDER. Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all PGDSPIDER code is called "pgdspider.sh".

##### 1d.1: Copy and paste the code below in a new shell script file:

##### Generate PGDSPIDER bash shell script: `code/shell_scripts/pgdspider.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J pgd_coversion  # give the job a custom name
#SBATCH -o pgd_results-%j.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit
#SBATCH --mem-per-cpu=8G

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

# UNCOMMENT STARTING HERE

## Commands here run only on the first core
# module load rss/rss-2020
# module load pgdspider/pgdspider-2.1.1.5
```

#### 1e: Convert VCF files to BAYESCAN format.
In this step, we are using the general bash script for PGDSPIDER in addition to the four unique spid files for each analysis level to generate input files for BAYESCAN.

##### 1e.1. Convert VCF to BAYESCAN format for all black bass samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for all samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 01: all black bass samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/01_popgen_spb_hybrid.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/01_all -outputformat GESTE_BAYE_SCAN -spid ../spid_files/01_all.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/01_all`

##### 1e.2. Convert VCF to BAYESCAN format for all species complex samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for speices complex samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 02: species complex samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/02_popgen_species_complex.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/02_species_complex -outputformat GESTE_BAYE_SCAN -spid ../spid_files/02_species_complex.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/02_species_complex`

##### 1e.3. Convert VCF to BAYESCAN format for Neosho Bass samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for Neosho Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 03: Neosho Bass samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/03_popgen_neosho.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/03_neosho -outputformat GESTE_BAYE_SCAN -spid ../spid_files/03_neosho.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/03_neosho`

##### 1e.4. Convert VCF to BAYESCAN format for Smallmouth Bass samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for Smallmouth Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 04: Smallmouth Bass samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/04_popgen_smallmouth.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/04_smallmouth -outputformat GESTE_BAYE_SCAN -spid ../spid_files/04_smallmouth.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/04_smallmouth`

### STEP 2: Prepare input data for PCADAPT
In this step, we are preparing all input data for the R program PCADAPT. PCADAPT reads .bed files (generated in the software program PLINK) as input, along with accompanying .bim and .fam files.

#### 2a: Generate a general bash shell script header for all PLINK commands
In this step, we are generating a universal bash shell script to run all file type conversions in PLINK. Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all PLINK code is called "plink.sh".

##### 2a.1. Copy and paste the code below in a new shell script file:

##### Generate PLINK bash shell script: `code/shell_scripts/plink.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J plink # give the job a custom name
#SBATCH -o plink.out  # give the job output a custom name
#SBATCH -t 0-01:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

## Commands here run only on the first core

# (UNCOMMENT THIS LINE TO RUN THE CODE)

## Modules to load

# module load rss/rss-2020
# module load plink/plink-high-contig-1.90p 
```

#### 2b: Convert VCF data into .bed format for PCADAPT analysis.

##### 2a.1. Convert VCF data for all black bass samples; copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 01: Convert VCF data for all black bass samples (excluding Spotted Bass hybrid, BFC10) to .bed format
#plink --vcf ../../data/processed_vcf/01_popgen_spb_hybrid.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/01_all_output/01_all
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/01_all_output/01_all.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.

##### 2a.2. Convert VCF data for species complex samples (Neosho Bass and Smallmouth Bass); copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 02: Convert VCF data for species complex samples (Neosho Bass and Smallmouth Bass) to .bed format
#plink --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/02_species_complex_output/02_species_complex
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/02_species_complex_output/02_species_complex.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.

##### 2a.3. Convert VCF data for Neosho Bass samples only; copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 03: Convert VCF data for Neosho Bass only to .bed format
#plink --vcf ../../data/processed_vcf/03_popgen_neosho.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/03_neosho_output/03_neosho
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/03_neosho_output/03_neosho.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.

##### 2a.4. Convert VCF data for Smallmouth Bass samples only; copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 04: Convert VCF data for Smallmouth Bass only to .bed format
#plink --vcf ../../data/processed_vcf/04_popgen_smallmouth.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/04_smallmouth_output/04_smallmouth
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/04_smallmouth_output/04_smallmouth.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.


### ----------------------- END OF PHASE 1: DATA PREPARATION ----------------------- ###

## PHASE 2: OUTLIER ANALYSIS WITH BAYESCAN
In this phase of the analysis, we are using the software program BAYESCAN to conduct a genome scan for SNP loci with outlier Fst values to assess potential signatures of local directional selection and neutrality at various loci. We are conducting this analysis at four hierarchical levels, as listed in the description for Phase 1 of the analysis (see above). We are using input data for each hierarchical level of analysis as generated in Phase 1 of this analysis.

BAYESCAN uses a Bayesian framework to calculate probabilities of outlier loci across the genome.

All analyses conducted by calling commands in bash shell scripts were performed on the Lewis high-performance computing cluster at the University of Missouri <br>

 
 <b>Programs needed</b>: <br><br>

BAYESCAN v.2.1 (Foll & Gaggiotti 2008) <br>

<b>Citation</b>:<br>

Foll, M., & Gaggiotti, O. (2008). A genome-scan method to identify selected loci appropriate for both dominant and codominant markers: A Bayesian perspective. Genetics, 180, 977–993. doi:10.1534/genetics.108.092221


### STEP 1: Generate a general bash shell script header for all BAYESCAN runs.
In this step, we are generating a universal bash shell script to run all analyses in BAYESCAN Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each analysis and the associated lines of code in Rmd chunks. The shell script for running all BAYESCAN code is called "bayescan.sh".

#### 1a: Copy and paste the code below in a new shell script file:

##### Generate BAYESCAN bash shell script: `code/shell_scripts/bayescan.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J bayescan # give the job a custom name
#SBATCH -o bayescan.out  # give the job output a custom name
#SBATCH -t 1-00:00:00  # two day time limit
#SBATCH --account=biosci
#SBATCH -N 1  # number of nodes
#SBATCH -n 21  # number of cores (AKA tasks)

# UNCOMMENT STARTING HERE

## Load modules needed
# module load rss/rss-2020
# module load bayescan/bayescan-2.1
```

#### 1b: Conduct genome scans in BAYESCAN for all hierarchical analyses
In this step, we are conducting genome scans for outlier Fst loci using the software program BAYESCAN.

We used the same parameter set for each hierarchical analysis, as follows: <br<

<b>Parameters set for BAYESCAN analysis</b>: <br>
Default parameters: <br>
 -n 5000 (number of MCMC iterations) <br>
 -thin 10 (number at which to thin MCMC iterations) <br>
 -nbp 20 (number of pilot runs) <br>
 -pilot 5000 (length of pilot runs) <br>
 -burni 5000 (length of burnin run) <br>
 
##### 1b.1. Run BAYESCAN for all black bass species (Spotted Bass, Neosho Bass, and Smallmouth Bass); copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on all black bass samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 1: all black bass samples
# bayescan 01_all -od ../../data/bayescan_output -o 01_all_output/01_all
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/01_all_output/`. The files are:

1) 01_all_AccRte.txt
2) 01_all_fst.txt
3) 01_all.sel
4) 01_all_Verif.txt

##### 1b.2. Run BAYESCAN for species complex samples (eosho Bass and Smallmouth Bass); copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on species complex samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 2: species complex samples (Neosho Bass and Smallmouth Bass)
# bayescan 02_species_complex -od ../../data/bayescan_output -o 02_species_complex
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/02_species_complex_output/`. The files are:

1) 02_species_complex_AccRte.txt
2) 02_species_complex_fst.txt
3) 02_species_complex.sel
4) 02_species_complex_Verif.txt

##### 1b.3. Run BAYESCAN for Neosho Bass only; copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on Neosho Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 3: Neosho Bass samples (Neosho Bass only)
# bayescan 03_neosho -od ../../data/bayescan_output -o 03_neosho
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/03_neosho_output/`. The files are:

1) 03_neosho_AccRte.txt
2) 03_neosho_fst.txt
3) 03_neosho.sel
4) 03_neosho.txt

##### 1b.4. Run BAYESCAN for Smallmouth Bass only; copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on Smallmouth Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 1: all black bass samples
# bayescan 04_smallmouth -od ../../data/bayescan_output -o 04_smallmouth
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/04_smallmouth_output/`. The files are:

1) 04_smallmouth_AccRte.txt
2) 04_smallmouth_fst.txt
3) 04_smallmouth.sel
4) 04_smallmouth.txt

### STEP 2: Identify SNP loci associated with outlier Fst inferred in BAYESCAN.
In this step, we are reading in the Fst results generated in the BAYESCAN analysis in Phase 2 Step 1 and identifying loci with outlier Fst values.

#### 2a: Read in Fst results for all hiearchical analyses; run the Rmd chunk below.

##### Read in Fst results for all analyses:
```{r}
# Read in data for all black bass samples (Spotted Bass, Neosho Bass, and Smallmouth Bass)
all_fst <- read.table("data/bayescan_output/01_all_output/01_all_fst.txt")

# Convert to dataframe
all_fst <- as.data.frame(all_fst)

# Modify column names
colnames(all_fst) <- c("probability", "log_po", "q", "alpha", "fst")


# Read in data for species complex samples (Neosho Bass and Smallmouth Bass)
species_complex_fst <- read.table("data/bayescan_output/02_species_complex_output/02_species_complex_fst.txt")

# Convert to dataframe
species_complex_fst <- as.data.frame(species_complex_fst)
  
# Modify column names
colnames(species_complex_fst) <- c("probability", "log_po", "q", "alpha", "fst")


# Read in data for Neosho Bass
neosho_fst <- read.table("data/bayescan_output/03_neosho_output/03_neosho_fst.txt")

# Convert to dataframe
neosho_fst <- as.data.frame(neosho_fst)

# Modify column names
colnames(neosho_fst) <- c("probability", "log_po", "q", "alpha", "fst")
  

# Read in data for Smallmouth Bass
smallmouth_fst <- read.table("data/bayescan_output/04_smallmouth_output/04_smallmouth_fst.txt")

# Convert to dataframe
smallmouth_fst <- as.data.frame(smallmouth_fst)

# Modify column names
colnames(smallmouth_fst) <- c("probability", "log_po", "q", "alpha", "fst")
```

#### 2b: Identify outlier SNP loci
In this step, we are identifying SNP loci with high probability of being under selection based on log10 of the posterior odds (log_po), which is given in column 2 of the BAYESCAN output data. Per the BAYESCAN user manual, any SNP with log10 posterior odds greater than or equal to 0.5 is deemed "substantially likely to be under selection". We therefore isolated all SNPs with log_po greater than 0.5 and designated them as "significant". All SNPs with log_po less than 0.5 were designated as "not significant".

We provided information on the level of significance for each "significant" SNP per to the BAYESCAN user manual (retrieved from: http://www.cmpg.unibe.ch/software/BayeScan/files/BayeScan2.0_manual.pdf):

<b>BAYESCAN levels of significance</b>: <br>
2.00 <= log_po < infinity: decisive <br>
1.50 <= log_po < 2.00: very strong <br>
1.00 <= log_po < 1.50: strong <br>
0.50 <= log_po < 1.00: substantial <br>
0.00 <= log_po < 0.50: barely worth mentioning <br>

##### 2b.1.  Generate metadata for SNP ID (RAD_kmer_...) and SNP position (nucleotide position on the kmer)
In this step, we are generating a list of SNP IDs and positions to append to the datasets below in order to determine the identity of outlier SNPs

###### 2b.1.1.Generate SNP position and metadata; run the Rmd chunk below:

##### Generate list of SNP ID and position:
```{r}
# Read in .bim file, which contains a list of RAD kmer names and associated positions
metadata_snps <- read_tsv("data/processed_bed/01_all_output/01_all.bim", col_names = F)
  
# Keep only SNP name and position columns
metadata_snps <- metadata_snps[,c(1,4)]

# Rename columns
colnames(metadata_snps) <- c("snp_id", "position")
```

##### 2b.2. Isolate significant and insignificant SNPs for all black bass samples; run the Rmd chunk below:

##### Outlier SNP identification for all black bass samples:
```{r}
# Append SNP IDs to data
all_fst <- cbind(metadata_snps, all_fst)

# Isolate SNPs with log_po greater than or equal to 0.5
all_significant_bayescan <- all_fst %>% 
      filter(log_po >= 0.5) 

# Isolate SNPs with log_po less than 0.5
all_not_significant_bayescan <- all_fst %>% 
      filter(log_po < 0.5) 

# Put log_po in descending order to analyze significance level 
all_significant_bayescan <- all_significant_bayescan %>%
  arrange(desc(log_po))

# count SNPs that are decisively under selection
all_significant_bayescan %>% 
  filter(log_po >= 2) %>% 
  count()

# count SNPs that are under very strong selection
all_significant_bayescan %>% 
  filter(log_po >= 1.5 & log_po < 2) %>% 
  count()

# count SNPs that are under strong selection
all_significant_bayescan %>% 
  filter(log_po >= 1 & log_po < 1.5) %>% 
  count()

# count SNPs that are under very strong selection
all_significant_bayescan %>% 
  filter(log_po >= 0.5 & log_po < 1) %>% 
  count()

# Append column for selection status ("selection"; significant or not signficant)
all_significant_bayescan$selection <- c(rep("significant", times = 3))
all_not_significant_bayescan$selection <- c(rep("insignificant", times = 50825))

# Append column for significance level ("sig_level"; decisive, very strong, substantial)
all_significant_bayescan$sig_level <- c(rep("very_strong", times = 1),rep("substantial", times = 2))
all_not_significant_bayescan$sig_level <- c(rep("not_significant", times = 50825))

#combine data into one dataframe
all_fst <- rbind(all_significant_bayescan, all_not_significant_bayescan)
```

##### 2b.3. Isolate significant and insignificant SNPs for species complex samples (Neosho Bass and Smallmouth Bass); run the Rmd chunk below:

##### Outlier SNP identification for all black bass samples:
```{r}
# Append SNP IDs to data
species_complex_fst <- cbind(metadata_snps, species_complex_fst)

# Isolate SNPs with log_po greater than or equal to 0.5
species_complex_significant_bayescan <- species_complex_fst %>% 
      filter(log_po >= 0.5) 

# Isolate SNPs with log_po less than 0.5
species_complex_not_significant_bayescan <- species_complex_fst %>% 
      filter(log_po < 0.5) 

# Put log_po in descending order to analyze significance level 
species_complex_significant_bayescan <- species_complex_significant_bayescan %>%
  arrange(desc(log_po))

# count SNPs that are decisively under selection
species_complex_significant_bayescan %>% 
  filter(log_po >= 2) %>% 
  count()

# count SNPs that are under very strong selection
species_complex_significant_bayescan %>% 
  filter(log_po >= 1.5 & log_po < 2) %>% 
  count()

# count SNPs that are under strong selection
species_complex_significant_bayescan %>% 
  filter(log_po >= 1 & log_po < 1.5) %>% 
  count()

# count SNPs that are under very strong selection
species_complex_significant_bayescan %>% 
  filter(log_po >= 0.5 & log_po < 1) %>% 
  count()

# Append column for selection status ("selection"; significant or not signficant)
species_complex_significant_bayescan$selection <- c(rep("significant", times = 703))
species_complex_not_significant_bayescan$selection <- c(rep("insignificant", times = 50125))

# Append column for significance level ("sig_level"; decisive, very strong, substantial)
species_complex_significant_bayescan$sig_level <- c(rep("decisive", times = 118), 
                                                rep("very_strong", times = 86), 
                                                rep("strong", times = 164), 
                                                rep("substantial", times = 335))

species_complex_not_significant_bayescan$sig_level <- c(rep("not_significant", times = 50125))

#combine data into one dataframe
species_complex_fst <- rbind(species_complex_significant_bayescan, species_complex_not_significant_bayescan)
```

##### 2b.4. Isolate significant and insignificant SNPs for Neosho Bass only; run the Rmd chunk below:

##### Outlier SNP identification for all black bass samples:
```{r}
# Append SNP IDs to data
neosho_fst <- cbind(metadata_snps, neosho_fst)

# Isolate SNPs with log_po greater than or equal to 0.5
neosho_significant_bayescan <- neosho_fst %>% 
      filter(log_po >= 0.5) 

# Isolate SNPs with log_po less than 0.5
neosho_not_significant_bayescan <- neosho_fst %>% 
      filter(log_po < 0.5) 

# Put log_po in descending order to analyze significance level 
neosho_significant_bayescan <- neosho_significant_bayescan %>%
  arrange(desc(log_po))

# count SNPs that are decisively under selection
neosho_significant_bayescan %>% 
  filter(log_po >= 2) %>% 
  count()

# count SNPs that are under very strong selection
neosho_significant_bayescan %>% 
  filter(log_po >= 1.5 & log_po < 2) %>% 
  count()

# count SNPs that are under strong selection
neosho_significant_bayescan %>% 
  filter(log_po >= 1 & log_po < 1.5) %>% 
  count()

# count SNPs that are under very strong selection
neosho_significant_bayescan %>% 
  filter(log_po >= 0.5 & log_po < 1) %>% 
  count()

# Append column for selection status ("selection"; significant or not signficant)
neosho_significant_bayescan$selection <- c(rep("significant", times = 32))
neosho_not_significant_bayescan$selection <- c(rep("insignificant", times = 50796))

# Append column for significance level ("sig_level"; decisive, very strong, substantial)
neosho_significant_bayescan$sig_level <- c(rep("decisive", times = 2), 
                                                rep("very_strong", times = 5), 
                                                rep("strong", times = 4), 
                                                rep("substantial", times = 21))

neosho_not_significant_bayescan$sig_level <- c(rep("not_significant", times = 50796))

#combine data into one dataframe
neosho_fst <- rbind(neosho_significant_bayescan, neosho_not_significant_bayescan)
```

##### 2b.5. Isolate significant and insignificant SNPs for  Smallmouth Bass only; run the Rmd chunk below:

##### Outlier SNP identification for all black bass samples:
```{r}
# Append SNP IDs to data
smallmouth_fst <- cbind(metadata_snps, smallmouth_fst)

# Isolate SNPs with log_po greater than or equal to 0.5
smallmouth_significant_bayescan <- smallmouth_fst %>% 
      filter(log_po >= 0.5) 

# Isolate SNPs with log_po less than 0.5
smallmouth_not_significant_bayescan <- smallmouth_fst %>% 
      filter(log_po < 0.5) 

# Put log_po in descending order to analyze significance level 
smallmouth_significant_bayescan <- smallmouth_significant_bayescan %>%
  arrange(desc(log_po))

# count SNPs that are decisively under selection
smallmouth_significant_bayescan %>% 
  filter(log_po >= 2) %>% 
  count()

# count SNPs that are under very strong selection
smallmouth_significant_bayescan %>% 
  filter(log_po >= 1.5 & log_po < 2) %>% 
  count()

# count SNPs that are under strong selection
smallmouth_significant_bayescan %>% 
  filter(log_po >= 1 & log_po < 1.5) %>% 
  count()

# count SNPs that are under very strong selection
smallmouth_significant_bayescan %>% 
  filter(log_po >= 0.5 & log_po < 1) %>% 
  count()

# Append column for selection status ("selection"; significant or not signficant)
smallmouth_significant_bayescan$selection <- c(rep("significant", times = 6))
smallmouth_not_significant_bayescan$selection <- c(rep("insignificant", times = 50822))

# Append column for significance level ("sig_level"; decisive, very strong, substantial)
smallmouth_significant_bayescan$sig_level <- c(rep("substantial", times = 6))

smallmouth_not_significant_bayescan$sig_level <- c(rep("not_significant", times = 50822))

#combine data into one dataframe
smallmouth_fst <- rbind(smallmouth_significant_bayescan, smallmouth_not_significant_bayescan)
```

#### 2c: Filter datasets to omit SNPs with log_po values of 1000 for clean visualization (because they distort the figure).

##### Omit SNPs with log_po greater than or equal to 1000; run the Rmd chunk below:

##### Omit SNPs with log_po greater than or equal to 1000:
```{r}
# Get SNPs with log_po = 1000 for all black bass samples
all_1000 <- all_fst %>% 
      filter(log_po >= 1000) 

# Get SNPs with log_po < 1000 for all black bass samples
all_clean <- all_fst %>% 
      filter(log_po < 1000) 

# Get SNPs with log_po = 1000 for species complex samples
species_complex_1000 <- species_complex_fst %>% 
      filter(log_po >= 1000) 

# Get SNPs with log_po < 1000 for all species complex samples
species_complex_clean <- species_complex_fst %>% 
      filter(log_po < 1000) 

# Get SNPs with log_po = 1000 for species complex samples
neosho_1000 <- neosho_fst %>% 
      filter(log_po >= 1000)

# Get SNPs with log_po < 1000 for Neosho Bass samples
neosho_clean <- neosho_fst %>% 
      filter(log_po < 1000) #extract only snps with log10 less than 1000

# Get SNPs with log_po = 1000 for Smallmouth Bass samples
smallmouth_1000 <- smallmouth_fst %>% 
      filter(log_po >= 1000) 

# Get SNPs with log_po < 1000 for Smallmouth Bass samples
smallmouth_clean <- smallmouth_fst %>% 
      filter(log_po < 1000) #extract only snps with log10 less than 1000
```

### STEP 3: Plot BAYESCAN Fst results
In this step, we are using the Fst data inferred from BAYESCAN to plot Fst as a function of log posterior odds, which shows the distribution of Fst values and their respective signficance.

#### 3a: Generate plots for each hierarchical analysis; run the Rmd chunk below:
We chose to include each plot as separate panels in one figure. The plots are named "a", "b", "c", and "d", and appear in that order in the final manuscript. We colored points and included dotted lines to indicate significance level.

##### Generate plot for all black bass samples: `figures/bayescan_figures/fst.pdf`
```{r}
# Plot for all black bass samples
a <- ggplot(all_clean, aes(x = log_po, y = fst, fill = sig_level)) + 
      geom_point(aes(fill = sig_level), alpha = 0.8, color = "black", pch = 21, size = 4, show.legend = F) +
      geom_vline(xintercept = 2, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1.5, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1, linetype = "longdash", color = "black") +
      geom_vline(xintercept = 0.5, linetype = "longdash", color = "black") + 
      theme_set(theme_cowplot(12)) + 
      scale_fill_manual(values = c("grey","#FCFFA4FF","#BB3754FF")) +
      labs(x = "Log10(Posterior Odds)", y = "FST") + 
      theme(axis.title = element_text(size = 20, color = "black")) +
      theme(axis.text = element_text(size = 15, color = "black")) + 
      theme(axis.line = element_line(color = "black")) +
      theme(axis.ticks = element_line(color = "black")) +
      theme(axis.title.x = element_blank()) +
      theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
      ylab(expression(F[ST])) +
      xlab(expression(log[10]~{("posterior odds")}))

# Plot for species complex samples
b <- ggplot(species_complex_clean, aes(x = log_po, y = fst, fill = sig_level)) +
      geom_point(aes(fill = sig_level), alpha = 0.8, color = "black", pch = 21, size = 4, show.legend = F) +
      geom_vline(xintercept = 2, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1.5, linetype = "longdash", color = "black") +
      geom_vline(xintercept = 1, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 0.5, linetype = "longdash", color = "black") + 
      theme_set(theme_cowplot(12)) + 
      scale_fill_manual(values = c("#56106EFF","grey","#F98C0AFF","#FCFFA4FF","#BB3754FF")) + 
      labs(x = "Log10(Posterior Odds)", y = "FST") + 
      theme(axis.title = element_text(size = 20, color = "black")) + 
      theme(axis.text = element_text(size = 15, color = "black")) + 
      theme(axis.line = element_line(color = "black")) +
      theme(axis.ticks = element_line(color = "black")) +
      theme(axis.title.x = element_blank()) +
      theme(axis.title.y = element_blank())  +
      theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
      ylab(expression(F[ST])) +
      xlab(expression(log[10]~{("posterior odds")}))

# Plot for Neosho BAss samples
c <- ggplot(neosho_clean, aes(x = log_po, y = fst, fill = sig_level)) + 
      geom_point(aes(fill = sig_level), alpha = 0.8, color = "black", pch = 21, size = 4, show.legend = F) + 
      geom_vline(xintercept = 2, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1.5, linetype = "longdash", color = "black") +
      geom_vline(xintercept = 1, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 0.5, linetype = "longdash", color = "black") + 
      theme_set(theme_cowplot(12)) +
      scale_fill_manual(values = c("#56106EFF","grey","#F98C0AFF","#FCFFA4FF","#BB3754FF")) + 
      labs(x = "Log10(Posterior Odds)", y = "FST") + 
      theme(axis.title = element_text(size = 20, color = "black")) +
      theme(axis.text = element_text(size = 15, color = "black")) + 
      theme(axis.line = element_line(color = "black")) +
      theme(axis.ticks = element_line(color = "black")) +
      theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
      ylab(expression(F[ST])) +
      xlab(expression(log[10]~{("posterior odds")}))

# Plot for Smallmouth Bass samples
d <- ggplot(smallmouth_clean, aes(x = log_po, y = fst, fill = sig_level)) + 
      geom_point(aes(fill = sig_level), alpha = 0.8, color = "black", pch = 21, size = 4, show.legend = F) + 
      geom_vline(xintercept = 2, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1.5, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 1, linetype = "longdash", color = "black") + 
      geom_vline(xintercept = 0.5, linetype = "longdash", color = "black") + 
      theme_set(theme_cowplot(12)) + 
      scale_fill_manual(values = c("grey","#FCFFA4FF")) + 
      labs(x = "Log10(Posterior Odds)", y = "FST") + 
      theme(axis.title = element_text(size = 20, color = "black")) + 
      theme(axis.text = element_text(size = 15, color = "black")) + 
      theme(axis.title.y = element_blank()) + 
      theme(axis.line = element_line(color = "black")) +
      theme(axis.ticks = element_line(color = "black"))  +
      theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
      ylab(expression(F[ST])) +
      xlab(expression(log[10]~{("posterior odds")}))

# Put plots together
pdf("figures/bayescan_figures/fst.pdf", width=13, height=10)

plot_grid(a,b,c,d, 
          nrow = 2, 
          align = "hv", 
          labels = c("a","b","c","d"), 
          label_size = 25)

dev.off()
```

This figure was used as the basis for Supplementary Figure 6 in our manuscript.

### ----------------------- END OF PHASE 2: OUTLIER ANALYSIS WITH BAYESCAN ----------------------- ###

## PHASE 3: OUTLIER ANALYSIS WITH PCADAPT
In this phase of the analysis, we are using the R package PCADAPT to conduct a genome scan for SNP loci with outlier Fst values to assess potential signatures of local directional selection and neutrality at various loci. We are conducting this analysis at four hierarchical levels, as listed in the description for Phase 1 of the analysis (see above). We are using input data for each hierarchical level of analysis as generated in Phase 1 of this analysis.

PCADAPT uses a multivariate framework (Principal Component Analysis; PCA) to account for population structure among populations and determine likely outlier SNPs driving differentiation between populations.

### STEP 1: Read in input data for PCADAPT, which are the .bed format files generated in Phase 1 above, and prepare sample metadata

#### 1a: Read in .bed files for all hierarchical analyses; run the Rmd chunk below:

###### Read in input data:
```{r, include=FALSE}
# Read in data for all black bass samples
all_bed <- read.pcadapt("data/processed_bed/01_all_output/01_all.bed", type = "bed") 

# Read in data for species complex samples
species_complex_bed <- read.pcadapt("data/processed_bed/02_species_complex_output/02_species_complex.bed", type = "bed") 

# Read in data for Neosho Bass samples
neosho_bed <- read.pcadapt("data/processed_bed/03_neosho_output/03_neosho.bed", type = "bed")

# Read in data for Smallmouth Bass samples
smallmouth_bed <- read.pcadapt("data/processed_bed/04_smallmouth_output/04_smallmouth.bed", type = "bed") 
```

#### 1b: Filter sample metadata to include only individuals and their corresponding populations in each hierarchical analysis. Population IDs will be used for later plotting; run the Rmd chunk below:

##### Generate sample metadata for plotting:
```{r}
# Load in raw metadata
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

# Generate metadata for all black bass samples
all_metadata <- metadata_populations_spb %>%
  filter(sample_id != "BFC10_1")

# Generate metadata for species complex samples
species_complex_metadata <- metadata_populations_spb %>%
  filter(sample_id != "BFC10_1") %>%
  filter(population != "SPB")

# Generate metadata for Neosho Bass samples
neosho_metadata <- metadata_populations_spb %>%
  filter(sample_id != "BFC10_1") %>%
  filter(population != "SPB") %>%
  filter(population != "MISS") %>%
  filter(population != "WHITE") %>%
  filter(population != "SKIA")

# Generate metadata for Smallmouth Bass samples
smallmouth_metadata <- metadata_populations_spb %>%
  filter(sample_id != "BFC10_1") %>%
  filter(population != "SPB") %>%
  filter(population != "MIDARK") %>%
  filter(population != "LMULB") %>%
  filter(population != "ELK") %>%
  filter(population != "ILLI") %>%
  filter(population != "BAYOU") %>%
  filter(population != "UPPARK")

# Convert population lists for each metadata file into vectors

# Make vector for all black bass populations
all_pops <- as.vector(all_metadata[,c(2)])

# Make vector for species complex populations
species_complex_pops <- as.vector(species_complex_metadata[,c(2)])

# Make vector for Neosho Bass populations
neosho_pops <- as.vector(neosho_metadata[,c(2)])

# Make vector for Smallmouth Bass populations
smallmouth_pops <- as.vector(smallmouth_metadata[,c(2)])
```

### STEP 2: Run PCADAPT Analysis on all hierarchical levels. 

#### 2a: Run PCAdapt analysis for a possible K = 1-20 and with a minimum allele frequency threshold of 0.0001. 
PCADAPT explicitly accounts for population structure in the data by testing different possible numbers of K clusters (similar in principle to the program ADMIXTURE). The minor allele frequency threshold is just a placeholder here for the the analysis to run

##### 2a.1. Run PCAdapt analysis; run the Rmd chunk below:

##### Run PCA through PCAdapt to identify outlier SNPs:
```{r}
#Run PCAdapt for all black bass samples 
all_pca_k20 <- pcadapt(all_bed, K = 20, min.maf = 0.0001) 

#Run PCAdapt for species complex samples 
species_complex_pca_k20 <- pcadapt(species_complex_bed, K = 20, min.maf = 0.0001)

#Run PCAdapt for Neosho Bass samples 
neosho_pca_k20 <- pcadapt(neosho_bed, K = 20, min.maf = 0.0001)

#Run PCAdapt for Smallmouth Bass samples 
smallmouth_pca_k20 <- pcadapt(smallmouth_bed, K = 20, min.maf = 0.0001)
```

##### 2a.2. Choose the optimal number of K PCAs to retain in downstream analyses by assessing Scree plots; run the Rmd chunk below:

##### Visualize Scree plots:
```{r}
#Scree plot for all black bass samples 
all_scree <- plot(all_pca_k20, option = "screeplot") 

#Scree plot for species complex samples 
species_complex_scree <- plot(species_complex_pca_k20, option = "screeplot") 

#Scree plot for Neosho Bass samples 
neosho_scree <- plot(neosho_pca_k20, option = "screeplot") 

#Scree plot for Smallmouth Bass samples 
smallmouth_scree <- plot(smallmouth_pca_k20, option = "screeplot") 
```
Here, we used Catell's Rule to determine the optimal number of clusters to retain in PC analysis. Thus, we chose the number of K PCs to retain based on where the Scree plot line began to plateau. We then reran PCADAPT analysis on the optimal number of K to determine the amount of variance explained by that number of PCs in downstream analyses.

##### 2a.3. Extract Scree plot variance explained information and generate figures.
In tis step, we are extracting information on the variance explained by each Principal Component in the PCAs calculated with K = 20 above and plotting these data.

###### 2a.3.1. Summarize variance information from each hierarchical analysis; run the Rmd chunk below:

##### Generate Scree plot figures for publication:
```{r}
## Generate variance data for all black bass samples at K = 20

# Get root variance information from PCA calculation above
all_pca_variance_k20 <- data.frame(root_variance = as.numeric(all_pca_k20$singular.values))

# Calculate variance 
all_pca_variance_k20 <- all_pca_variance_k20 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
all_pca_variance_k20 <- rownames_to_column(all_pca_variance_k20, "K")

# Convert K to numeric vector
all_pca_variance_k20 <- all_pca_variance_k20 %>% 
   mutate(K = as.numeric(K))


## Generate variance data for species complex samples at K = 20

# Get root variance information from PCA calculation above
species_complex_pca_variance_k20 <- data.frame(root_variance = as.numeric(species_complex_pca_k20$singular.values))

# Calculate variance 
species_complex_pca_variance_k20 <- species_complex_pca_variance_k20 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
species_complex_pca_variance_k20 <- rownames_to_column(species_complex_pca_variance_k20, "K")

# Convert K to numeric vector
species_complex_pca_variance_k20 <- species_complex_pca_variance_k20 %>% 
   mutate(K = as.numeric(K))


## Generate variance data for Neosho Bass samples at K = 20

# Get root variance information from PCA calculation above
neosho_pca_variance_k20 <- data.frame(root_variance = as.numeric(neosho_pca_k20$singular.values))

# Calculate variance 
neosho_pca_variance_k20 <- neosho_pca_variance_k20 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
neosho_pca_variance_k20 <- rownames_to_column(neosho_pca_variance_k20, "K")

# Convert K to numeric vector
neosho_pca_variance_k20 <- neosho_pca_variance_k20 %>% 
   mutate(K = as.numeric(K))


## Generate variance data for Smallmouth Bass samples at K = 20

# Get root variance information from PCA calculation above
smallmouth_pca_variance_k20 <- data.frame(root_variance = as.numeric(smallmouth_pca_k20$singular.values))

# Calculate variance 
smallmouth_pca_variance_k20 <- smallmouth_pca_variance_k20 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
smallmouth_pca_variance_k20 <- rownames_to_column(smallmouth_pca_variance_k20, "K")

# Convert K to numeric vector
smallmouth_pca_variance_k20 <- smallmouth_pca_variance_k20 %>% 
   mutate(K = as.numeric(K))

## Summarize information on total variance explained by 20 PCs for each dataset
sum(all_pca_variance_k20$variance) #96.19% 
sum(species_complex_pca_variance_k20$variance) #59.80% 
sum(neosho_pca_variance_k20$variance) #53.52% 
sum(smallmouth_pca_variance_k20$variance) #100.00% 
```

###### 2a.3.2. Generate variance explained figures; run the Rmd chunk below:
Here, we have chosen to include all individual Scree plots as panels in a single plot. Panels are labeled "a", "b", "c", and "d", and are presented in the figure in that order.

##### Generate Scree plot figure: `figures/pcadapt_figures/variance.pdf`
```{r}
## NOTE: Plots are named a,c,e,g because they are appended to the PCA plots generated below for the final publication. Those PCA plots have the missing letters (b,d,f,h)

# Plot for all black bass samples
a <- ggplot(all_pca_variance_k20, aes(x = K, y = variance)) + 
   geom_point(size = 3) + 
   geom_path(stat = "identity", size = 1) + 
   geom_vline(xintercept = 2, linetype = "longdash") +
   scale_x_continuous("Number of PCs Retained", labels = as.character(all_pca_variance_k20$K), breaks = all_pca_variance_k20$K) +
   labs(x = "Number of PCs Retained", y = "% Variance Explained") +
   theme_set(theme_cowplot(12)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for species complex samples
c <- ggplot(species_complex_pca_variance_k20, aes(x = K, y = variance)) + 
   geom_point(size = 3) + 
   geom_path(stat = "identity", size = 1) + 
   geom_vline(xintercept = 3, linetype = "longdash") +
   scale_x_continuous("Number of PCs Retained", labels = as.character(species_complex_pca_variance_k20$K), breaks = species_complex_pca_variance_k20$K) +
   labs(x = "Number of PCs Retained", y = "% Variance Explained") +
   theme_set(theme_cowplot(12)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(axis.title.x = element_text(face = "italic")) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for Neosho Bass samples
e <- ggplot(neosho_pca_variance_k20, aes(x = K, y = variance)) + 
   geom_point(size = 3) + 
   geom_path(stat = "identity", size = 1) + 
   geom_vline(xintercept = 4, linetype = "longdash") +
   scale_x_continuous("Number of PCs Retained", labels = as.character(neosho_pca_variance_k20$K), breaks = neosho_pca_variance_k20$K) +
   labs(x = "Number of PCs Retained", y = "% Variance Explained") +
   theme_set(theme_cowplot(12)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(axis.title.x = element_text(face = "italic")) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for Smallmouth Bass samples
g <- ggplot(smallmouth_pca_variance_k20, aes(x = K, y = variance)) + 
   geom_point(size = 3) + 
   geom_path(stat = "identity", size = 1) + 
   geom_vline(xintercept = 3, linetype = "longdash") +
   scale_x_continuous("Number of PCs Retained", labels = as.character(smallmouth_pca_variance_k20$K), breaks = smallmouth_pca_variance_k20$K) +
   labs(x = "Number of PCs Retained", y = "% Variance Explained") +
   theme_set(theme_cowplot(12)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot all figures together in a single pdf.
pdf("figures/pcadapt_figures/variance.pdf", width=7, height=17) 

plot_grid(a,c,e,g, nrow = 4, labels = c("a","c","e","g"), label_size = 30, label_y = 1.03)

dev.off()
```

This plot is later combined with the associated PCA plots for one composite figure in the manuscript (see below)

#### 2b: Re-run PCADAPT analysis for the number of K clusters inferred using Catell's rule.

##### 2b.1. Re-run PCADAPT for all hierarchical analyses; run the Rmd chunk below:

##### PCADAPT analyses for optimal number of K clusters/PCs:
```{r}
#Run PCAdapt for all black bass samples at K = 2
all_pca_k2 <- pcadapt(all_bed, K = 2, min.maf = 0.0001)

#Run PCAdapt for species complex samples at K = 2
species_complex_pca_k2 <- pcadapt(species_complex_bed, K = 2, min.maf = 0.0001)

#Run PCAdapt for Neosho Bass samples at K = 4
neosho_pca_k4 <- pcadapt(neosho_bed, K = 4, min.maf = 0.0001)

#Run PCAdapt for Smallmout Bass samples at K = 3
smallmouth_pca_k3 <- pcadapt(smallmouth_bed, K = 3, min.maf = 0.0001)
```

##### 2b.2. Extract variance explained information and generate figures.
In tis step, we are extracting information on the variance explained by each Principal Component in the PCAs calculated with optimal number of K PCs above and plotting these data.

###### 2b.2.1. Summarize variance information from each hierarchical analysis; run the Rmd chunk below:

##### Generate Scree plot figures for publication:
```{r}
# Get root variance information from PCA calculation above
all_pca_variance_k2 <- data.frame(root_variance = as.numeric(all_pca_k2$singular.values))

# Calculate variance 
all_pca_variance_k2 <- all_pca_variance_k2 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
all_pca_variance_k2 <- rownames_to_column(all_pca_variance_k2, "K")

# Convert K to numeric vector
all_pca_variance_k2 <- all_pca_variance_k2 %>% 
   mutate(K = as.numeric(K))
   
# Get root variance information from PCA calculation above
species_complex_pca_variance_k2 <- data.frame(root_variance = as.numeric(species_complex_pca_k2$singular.values))

# Convert K to numeric vector
species_complex_pca_variance_k2 <- species_complex_pca_variance_k2 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
species_complex_pca_variance_k2 <- rownames_to_column(species_complex_pca_variance_k2, "K")

# Convert K to numeric vector
species_complex_pca_variance_k2 <- species_complex_pca_variance_k2 %>% 
   mutate(K = as.numeric(K))
   
# Get root variance information from PCA calculation above
neosho_pca_variance_k4 <- data.frame(root_variance = as.numeric(neosho_pca_k4$singular.values))

# Convert K to numeric vector
neosho_pca_variance_k4 <- neosho_pca_variance_k4 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
neosho_pca_variance_k4 <- rownames_to_column(neosho_pca_variance_k4, "K")

# Convert K to numeric vector
neosho_pca_variance_k4 <- neosho_pca_variance_k4 %>% 
   mutate(K = as.numeric(K))

# Get root variance information from PCA calculation above
smallmouth_pca_variance_k3 <- data.frame(root_variance = as.numeric(smallmouth_pca_k3$singular.values))

# Convert K to numeric vector
smallmouth_pca_variance_k3 <- smallmouth_pca_variance_k3 %>%
   mutate(variance = (root_variance)^2)

# Convert rownames to column
smallmouth_pca_variance_k3 <- rownames_to_column(smallmouth_pca_variance_k3, "K")

# Convert K to numeric vector
smallmouth_pca_variance_k3 <- smallmouth_pca_variance_k3 %>% 
   mutate(K = as.numeric(K))

   
## Summarize information on total variance explained by 20 PCs for each dataset
sum(all_pca_variance_k2$variance) #68.68% 
sum(species_complex_pca_variance_k2$variance) #24.04% 
sum(neosho_pca_variance_k4$variance) #18.78% 
sum(smallmouth_pca_variance_k3$variance) #33.62% 
```

###### 2b.2.2. Generate PCA figures for optimal number of K; run the Rmd chunk below:

##### Generate PCA figure: `figures/pcadapt_figures/pca.pdf`
```{r}
## Extract PC information for all black bass samples

# Get PC scores
all_pca_k2_scores <- as.data.frame(all_pca_k2$scores)

# Append population names to PC scores
all_pca_k2_scores <- cbind(data.frame(all_pops), all_pca_k2_scores)

# Modify column names
colnames(all_pca_k2_scores) <- c("pop","PC1","PC2")


## Extract PC information for species complex samples

# Get PC scores
species_complex_pca_k2_scores <- as.data.frame(species_complex_pca_k2$scores)

# Append population names to PC scores
species_complex_pca_k2_scores <- cbind(data.frame(species_complex_pops), species_complex_pca_k2_scores)

# Modify column names
colnames(species_complex_pca_k2_scores) <- c("pop","PC1","PC2")


## Extract PC information for Neosho Bass samples

# Get PC scores
neosho_pca_k4_scores <- as.data.frame(neosho_pca_k4$scores)

# Append population names to PC scores
neosho_pca_k4_scores <- cbind(data.frame(neosho_pops), neosho_pca_k4_scores)

# Modify column names
colnames(neosho_pca_k4_scores) <- c("pop","PC1","PC2","PC3","PC4")


## Extract PC information for Neosho Bass samples

# Get PC scores
smallmouth_pca_k3_scores <- as.data.frame(smallmouth_pca_k3$scores)

# Append population names to PC scores
smallmouth_pca_k3_scores <- cbind(data.frame(smallmouth_pops), smallmouth_pca_k3_scores)

# Modify column names
colnames(smallmouth_pca_k3_scores) <- c("pop","PC1","PC2","PC3")


# Generate figure

# Plot for all black bass samples
b <- ggplot(all_pca_k2_scores, aes(x = PC1, y = PC2)) + 
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 4, show.legend = F) +
   labs(x = "PC1 (53.94 %)", y = "PC2 (14.74 %)", fill = "Species") +
   scale_fill_manual(values = c("lightgreen","sienna4","mediumpurple","forestgreen","deepskyblue","chocolate1","navyblue","goldenrod3","orchid1","deeppink2")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 15)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 15)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for species complex samples
d <- ggplot(species_complex_pca_k2_scores, aes(x = PC1, y = PC2)) + 
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 4, show.legend = F) +
   labs(x = "PC1 (18.50 %)", y = "PC2 (5.55 %)", fill = "Population") +
   scale_fill_manual(values = c("lightgreen","sienna4","mediumpurple","forestgreen","deepskyblue","chocolate1","navyblue","orchid1","deeppink2")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 15)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 15)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for Neosho Bass samples
f <- ggplot(neosho_pca_k4_scores, aes(x = PC1, y = PC2)) + 
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 4, show.legend = F) +
   labs(x = "PC1 (6.60 %)", y = "PC2 (5.22 %)", fill = "Population") +
   scale_fill_manual(values = c("lightgreen","sienna4","mediumpurple","forestgreen","deepskyblue","orchid1")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 15)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 15)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for Smallmouth Bass samples
h <- ggplot(smallmouth_pca_k3_scores, aes(x = PC1, y = PC2)) + 
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 4, show.legend = F) +
   labs(x = "PC1 (15.76 %)", y = "PC2 (11.25 %)", fill = "Population") +
   scale_fill_manual(values = c("chocolate1","navyblue","deeppink2")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 15)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 15)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 15)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Combine all PCA score plots 
pdf("figures/pcadapt_figures/pca.pdf", width=7, height=17) 

plot_grid(b,d,f,h, 
          nrow = 4, 
          labels = c("b","d","f","h"), 
          label_y = 1.03, 
          label_size = 30)

dev.off()
```

###### 2b.2.3. Generate Combined Scree and PCA figures for optimal number of K; run the Rmd chunk below:

##### Generate a combined Scree and PCA plot: `figures/pcadapt_figures/scree_pca.pdf`
```{r}
# Get a named version of the Scree plot figure
scree <-plot_grid(a,c,e,g, 
                  nrow = 4, 
                  labels = c("a","c","e","g"), 
                  label_size = 30, 
                  label_y = 1.03)

pca <- plot_grid(b,d,f,h, 
                 nrow = 4, 
                 labels = c("b","d","f","h"), 
                 label_y = 1.03, 
                 label_size = 30)


#Combine Scree and PCA plots
pdf("figures/pcadapt_figures/scree_pca.pdf", width=14, height=17) 

plot_grid(scree, 
          pca, 
          ncol = 2,
          align = "v")

dev.off()
```

### STEP 3: Identify outlier SNP loci.
In this step, we are identifying SNPs explaining the largest proportion of variance on each retained PC to determine SNPs potentially under selection.

#### 3a: Identify outlier loci in all hierarchical analyses and append to SNP ID metadata.

### IMPORTANT NOTE: Any "SNP" loci that are homozygous for one variant across all individuals are removed from these data, because they are not real SNPs. They appear as "NAs" in the dataframe and are omitted in the code.

##### 3a.1. Idenitfy outlier loci for all black bass samples (Spotted Bass, Neosho Bass, and Smallmouth Bass); run the Rmd chunk below: 

## Get outlier SNPs using bonferroni p-value corrections
```{r}
# Get p values for SNPs 
all_pvals <- all_pca_k2$pvalues

# Correct p values for multiple tests using bonferroni correction
all_pvals_bonf <- p.adjust(all_pvals, method = "bonferroni")  

# Convert to dataframe
all_pvals_bonf <- as.data.frame(all_pvals_bonf) 

# Append SNP IDs to corrected p values
all_pvals_bonf <- cbind(metadata_snps, all_pvals_bonf)

# Modify column labels
colnames(all_pvals_bonf) <- c("snp_id", "position", "p_val") 

# Drop NAs (see Important Not above)
all_pvals_bonf <- all_pvals_bonf %>%
   drop_na() 

#Retrieve significant outlier SNPs
all_significant_pcadapt <- all_pvals_bonf %>% 
   filter(p_val < 0.05) 

#Retrieve non-significant SNPs
all_not_significant_pcadapt <- all_pvals_bonf %>% 
   filter(p_val >= 0.05) 
```

##### 3a.2. Idenitfy outlier loci for species complex samples (Neosho Bass and Smallmouth Bass); run the Rmd chunk below: 
## Get outlier SNPs using bonferroni p-value corrections
```{r}
# Get p values for SNPs 
species_complex_pvals <- species_complex_pca_k2$pvalues

# Correct p values for multiple tests using bonferroni correction
species_complex_pvals_bonf <- p.adjust(species_complex_pvals, method = "bonferroni")  

# Convert to dataframe
species_complex_pvals_bonf <- as.data.frame(species_complex_pvals_bonf) 

# Append SNP IDs to corrected p values
species_complex_pvals_bonf <- cbind(metadata_snps, species_complex_pvals_bonf)

# Modify column labels
colnames(species_complex_pvals_bonf) <- c("snp_id", "position", "p_val") 

# Drop NAs (see Important Not above)
species_complex_pvals_bonf <- species_complex_pvals_bonf %>%
   drop_na() 

#Retrieve significant outlier SNPs
species_complex_significant_pcadapt <- species_complex_pvals_bonf %>% 
   filter(p_val < 0.05) 

#Retrieve non-significant SNPs
species_complex_not_significant_pcadapt <- species_complex_pvals_bonf %>% 
   filter(p_val >= 0.05) 
```

##### 3a.3. Idenitfy outlier loci for Neosho Bass samples (Neosho Bass and Smallmouth Bass); run the Rmd chunk below: 

## Get outlier SNPs using bonferroni p-value corrections
```{r}
# Get p values for SNPs 
neosho_pvals <- neosho_pca_k4$pvalues

# Correct p values for multiple tests using bonferroni correction
neosho_pvals_bonf <- p.adjust(neosho_pvals, method = "bonferroni")  

# Convert to dataframe
neosho_pvals_bonf <- as.data.frame(neosho_pvals_bonf) 

# Append SNP IDs to corrected p values
neosho_pvals_bonf <- cbind(metadata_snps, neosho_pvals_bonf)

# Modify column labels
colnames(neosho_pvals_bonf) <- c("snp_id", "position", "p_val") 

# Drop NAs (see Important Not above)
neosho_pvals_bonf <- neosho_pvals_bonf %>%
   drop_na() 

#Retrieve significant outlier SNPs
neosho_significant_pcadapt <- neosho_pvals_bonf %>% 
   filter(p_val < 0.05) 

#Retrieve non-significant SNPs
neosho_not_significant_pcadapt <- neosho_pvals_bonf %>% 
   filter(p_val >= 0.05) 
```

##### 3a.3. Idenitfy outlier loci for Neosho Bass samples (Neosho Bass and Smallmouth Bass); run the Rmd chunk below: 

## Get outlier SNPs using bonferroni p-value corrections
```{r}
# Get p values for SNPs 
smallmouth_pvals <- smallmouth_pca_k3$pvalues

# Correct p values for multiple tests using bonferroni correction
smallmouth_pvals_bonf <- p.adjust(smallmouth_pvals, method = "bonferroni")  

# Convert to dataframe
smallmouth_pvals_bonf <- as.data.frame(smallmouth_pvals_bonf) 

# Append SNP IDs to corrected p values
smallmouth_pvals_bonf <- cbind(metadata_snps, smallmouth_pvals_bonf)

# Modify column labels
colnames(smallmouth_pvals_bonf) <- c("snp_id", "position", "p_val") 

# Drop NAs (see Important Not above)
smallmouth_pvals_bonf <- smallmouth_pvals_bonf %>%
   drop_na() 

#Retrieve significant outlier SNPs
smallmouth_significant_pcadapt <- smallmouth_pvals_bonf %>% 
   filter(p_val < 0.05) 

#Retrieve non-significant SNPs
smallmouth_not_significant_pcadapt <- smallmouth_pvals_bonf %>% 
   filter(p_val >= 0.05) 
```

### ----------------------- END OF PHASE 3: OUTLIER ANALYSIS WITH PCADAPT ----------------------- ###

## PHASE 4: OUTLIER MAPPING
In this phase of the analysis, we are conducting a multivariate analysis on SNPs either inferred to be significant outliers or neutral in both the BAYESCAN and PCADAPT genome scan analyses. Specifically, we are mapping <i>a priori</i> populations (determined in Analysis 4 (population inference)) onto multivariate space using outlier and neutral SNPs as response variables in Discriminant Analysis of Principal Components (DAPC).

### STEP 1: Merge data from BAYESCAN (Phase 2) and PCADAPT (Phase 3) to obtain overlapping lists of significant outlier Fsts (under selection) and non-significant, non-outlier Fsts (neutral).

#### 1a: Merge datasets for all hierarchical analyses

##### 1a.1. Merge significant and non-significant SNPs for all black bass samples; run the Rmd chunk below: 

##### Merge datasets for all black bass samples:
```{r}
# Merge outlier loci
all_outlier_snps <- merge(all_significant_bayescan, all_significant_pcadapt, by = "snp_id")

# Select only SNP ID and position columns for downstream data filtering
all_outlier_snps <- all_outlier_snps %>%
  select(snp_id, position.x)

# Merge neutral loci
all_neutral_snps <- merge(all_not_significant_bayescan, all_not_significant_pcadapt, by = "snp_id")

# Select only SNP ID and position columns for downstream data filtering
all_neutral_snps <- all_neutral_snps %>%
  select(snp_id, position.x)

# Generate lists of RAD kmer IDs and associated positions for downstream data filtering

# Get list of shared significant SNPs
write_tsv(all_outlier_snps, 
          file = "data/filtering_data/all_outlier_snps.txt", 
          col_names = FALSE)

# Get list of shared significant SNPs
write_tsv(all_neutral_snps, 
          file = "data/filtering_data/all_neutral_snps.txt", 
          col_names = FALSE)
```

This code generates two files: `all_outlier_snps.txt` and `all_neutral_snps.txt`, which contain lists of signficant and neutral (respectively) SNP IDs and corresponding positions. These files are saved here: `data/filtering_data/` and should be used to filter the full VCF dataset in downstream analyses.

##### 1a.2. Merge significant and non-significant SNPs for species complex samples; run the Rmd chunk below: 

##### Merge datasets for species complex samples:
```{r}
# Merge outlier loci
species_complex_outlier_snps <- merge(species_complex_significant_bayescan, species_complex_significant_pcadapt, by = "snp_id")

# Select only SNP ID and position columns for downstream data filtering
species_complex_outlier_snps <- species_complex_outlier_snps %>%
  select(snp_id, position.x)

# Merge neutral loci
species_complex_neutral_snps <- merge(species_complex_not_significant_bayescan, species_complex_not_significant_pcadapt, by = "snp_id")

# Select only SNP ID and position columns for downstream data filtering
species_complex_neutral_snps<- species_complex_neutral_snps %>%
  select(snp_id, position.x)

# Generate lists of RAD kmer IDs and associated positions for downstream data filtering

# Get list of shared significant SNPs
write_tsv(species_complex_outlier_snps, 
          file = "data/filtering_data/species_complex_outlier_snps.txt", 
          col_names = FALSE)

# Get list of shared significant SNPs
write_tsv(species_complex_neutral_snps, 
          file = "data/filtering_data/species_complex_neutral_snps.txt", 
          col_names = FALSE)
```

This code generates two files: `species_complex_outlier_snps.txt` and `species_complex_neutral_snps.txt`, which contain lists of signficant and neutral (respectively) SNP IDs and corresponding positions. These files are saved here: `data/filtering_data/` and should be used to filter the full VCF dataset in downstream analyses.

##### 1a.3. Merge significant and non-significant SNPs for Neosho Bass samples; run the Rmd chunk below: 

##### Merge datasets for Neosho Bass samples:
```{r}
# Merge outlier loci
neosho_outlier_snps <- merge(neosho_significant_bayescan, neosho_significant_pcadapt, by = "snp_id")

# Select only SNP ID and position columns for downstream data filtering
neosho_outlier_snps <- neosho_outlier_snps %>%
  select(snp_id, position.x)

# Merge neutral loci
neosho_neutral_snps <- merge(neosho_not_significant_bayescan, neosho_not_significant_pcadapt, by = "snp_id")

# Select only SNP ID and position columns for downstream data filtering
neosho_neutral_snps<- neosho_neutral_snps %>%
  select(snp_id, position.x)

# Generate lists of RAD kmer IDs and associated positions for downstream data filtering

# Get list of shared significant SNPs
write_tsv(neosho_outlier_snps, 
          file = "data/filtering_data/neosho_outlier_snps.txt", 
          col_names = FALSE)

# Get list of shared significant SNPs
write_tsv(neosho_neutral_snps, 
          file = "data/filtering_data/neosho_neutral_snps.txt", 
          col_names = FALSE)
```

This code generates two files: `neosho_outlier_snps.txt` and `neosho_neutral_snps.txt`, which contain lists of signficant and neutral (respectively) SNP IDs and corresponding positions. These files are saved here: `data/filtering_data/` and should be used to filter the full VCF dataset in downstream analyses.

##### 1a.4. Merge significant and non-significant SNPs for Smallmouth Bass samples; run the Rmd chunk below: 

##### Merge datasets for Smallmouth Bass samples:
```{r}
# Merge outlier loci
smallmouth_outlier_snps <- merge(smallmouth_significant_bayescan, smallmouth_significant_pcadapt, by = "snp_id")

# Select only SNP ID and position columns for downstream data filtering
smallmouth_outlier_snps <- smallmouth_outlier_snps %>%
  select(snp_id, position.x)

# Merge neutral loci
smallmouth_neutral_snps <- merge(smallmouth_not_significant_bayescan, smallmouth_not_significant_pcadapt, by = "snp_id")

# Select only SNP ID and position columns for downstream data filtering
smallmouth_neutral_snps<- smallmouth_neutral_snps %>%
  select(snp_id, position.x)

# Generate lists of RAD kmer IDs and associated positions for downstream data filtering

# Get list of shared significant SNPs
write_tsv(smallmouth_outlier_snps, 
          file = "data/filtering_data/smallmouth_outlier_snps.txt", 
          col_names = FALSE)

# Get list of shared significant SNPs
write_tsv(smallmouth_neutral_snps, 
          file = "data/filtering_data/smallmouth_neutral_snps.txt", 
          col_names = FALSE)
```

This code generates two files: `smallmouth_outlier_snps.txt` and `smallmouth_neutral_snps.txt`, which contain lists of signficant and neutral (respectively) SNP IDs and corresponding positions. These files are saved here: `data/filtering_data/` and should be used to filter the full VCF dataset in downstream analyses.

### STEP 2: Filter VCF files for each hierarchical analysis, one file to only retain outlier SNPs and a second file to only retain netural SNPs.

#### 2a: Filter VCF files for all black bass samples (Spotted Bass, Smallmouth Bass, and Neosho Bass) 

##### 2a.1. Get VCF with only outlier SNPs; copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 04A: Get outlier SNPs for all black bass samples
#vcftools --vcf ../../data/processed_vcf/01_popgen_spb_hybrid.vcf --positions ../../data/filtering_data/all_outlier_snps.txt --recode --recode-INFO-all --out ../../data/processed_vcf/01_popgen_all_outlier_snps
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/01_popgen_all_outlier_snps.vcf`.

##### 2a.2. Get VCF with only neutral SNPs; copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 04B: Get neutral SNPs for all black bass samples
#vcftools --vcf ../../data/processed_vcf/01_popgen_spb_hybrid.vcf --positions ../../data/filtering_data/all_neutral_snps.txt --recode --recode-INFO-all --out ../../data/processed_vcf/01_popgen_all_neutral_snps
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/01_popgen_all_neutral_snps.vcf`.

#### 2b: Filter VCF files for species complex samples (Smallmouth Bass and Neosho Bass)

##### 2a.1. Get VCF with only outlier SNPs; copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 05A: Get outlier SNPs for species complex samples
#vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --positions ../../data/filtering_data/species_complex_outlier_snps.txt --recode --recode-INFO-all --out ../../data/processed_vcf/02_popgen_species_complex_outlier_snps
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/02_popgen_species_complex_outlier_snps.vcf`.

##### 2b.2. Get VCF with only neutral SNPs; copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 05B: Get neutral SNPs for species complex samples
#vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --positions ../../data/filtering_data/species_complex_neutral_snps.txt --recode --recode-INFO-all --out ../../data/processed_vcf/02_popgen_species_complex_neutral_snps
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/02_popgen_species_complex_neutral_snps.vcf`.

#### 2c: Filter VCF files for Neosho Bass samples

##### 2c.1. Get VCF with only outlier SNPs; copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 06A: Get outlier SNPs for Neosho Bass samples
#vcftools --vcf ../../data/processed_vcf/03_popgen_neosho.vcf --positions ../../data/filtering_data/neosho_outlier_snps.txt --recode --recode-INFO-all --out ../../data/processed_vcf/03_popgen_neosho_outlier_snps
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/03_popgen_neosho_outlier_snps.vcf`.

##### 2c.2. Get VCF with only neutral SNPs; copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 06B: Get neutral SNPs for Neosho Bass samples
#vcftools --vcf ../../data/processed_vcf/03_popgen_neosho.vcf --positions ../../data/filtering_data/neosho_neutral_snps.txt --recode --recode-INFO-all --out ../../data/processed_vcf/03_popgen_neosho_neutral_snps
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/03_popgen_neosho_neutral_snps.vcf`.

#### 2d: Filter VCF files for Smallmouth Bass samples

##### 2d.1. Get VCF with only outlier SNPs; copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 07A: Get outlier SNPs for Smallmouth Bass samples
#vcftools --vcf ../../data/processed_vcf/04_popgen_smallmouth.vcf --positions ../../data/filtering_data/smallmouth_outlier_snps.txt --recode --recode-INFO-all --out ../../data/processed_vcf/04_popgen_smallmouth_outlier_snps
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/04_popgen_smallmouth_outlier_snps.vcf`.

##### 2d.2. Get VCF with only neutral SNPs; copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 07B: Get neutral SNPs for Smallmouth Bass samples
#vcftools --vcf ../../data/processed_vcf/04_popgen_smallmouth.vcf --positions ../../data/filtering_data/smallmouth_neutral_snps.txt --recode --recode-INFO-all --out ../../data/processed_vcf/04_popgen_smallmouth_neutral_snps
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/04_popgen_smallmouth_neutral_snps.vcf`.

### STEP 3: Conduct DAPC Analysis
In this step, we are reading in the filtered VCF files for all hierarchical analyses generated in Step 2 and mapping both neutral and outlier SNPs onto our a priori inferred populations using Discriminant Analysis of Principal Components (DAPC).

#### 3a: Read in and modify VCF files for all hierarchical analyses.

##### 3a.1. Read in input data; run the Rmd chunk below:

## Read-in VCF data for DAPC
```{r}
# Read in VCF data for all black bass samples

# Read in outlier snps
all_outliers <- read.vcfR("data/processed_vcf/01_popgen_all_outlier_snps.vcf")

# Read in neutral snps
all_neutral <- read.vcfR("data/processed_vcf/01_popgen_all_neutral_snps.vcf")

# Read in VCF data for species complex samples

# Read in outlier snps
species_complex_outliers <- read.vcfR("data/processed_vcf/02_popgen_species_complex_outlier_snps.vcf")

# Read in neutral snps
species_complex_neutral <- read.vcfR("data/processed_vcf/02_popgen_species_complex_neutral_snps.vcf")

# Read in VCF data for Neosho Bass samples

# Read in outlier snps
neosho_outliers <- read.vcfR("data/processed_vcf/03_popgen_neosho_outlier_snps.vcf")

# Read in neutral snps
neosho_neutral <- read.vcfR("data/processed_vcf/03_popgen_neosho_neutral_snps.vcf")

# Read in VCF data for Smallmouth Bass samples

# Read in outlier snps
smallmouth_outliers <- read.vcfR("data/processed_vcf/04_popgen_smallmouth_outlier_snps.vcf")

# Read in neutral snps
smallmouth_neutral <- read.vcfR("data/processed_vcf/04_popgen_smallmouth_neutral_snps.vcf")
```

##### 3a.2. Convert VCF files to genind objects, which are the preferred input type for DAPC, and include population designations in the object:

## Convert VCF to genind format for DAPC:
```{r}
## Convert files to genind objects

# Convert files for all black bass samples
# all_outliers_genind <- vcfR2genind(all_outliers) # No SNPs to work with (this code will not run)
all_neutral_genind <- vcfR2genind(all_neutral)

# Convert files for species complex samples
species_complex_outliers_genind <- vcfR2genind(species_complex_outliers)
species_complex_neutral_genind <- vcfR2genind(species_complex_neutral)

# Convert files for Neosho Bass samples
neosho_outliers_genind <- vcfR2genind(neosho_outliers)
neosho_neutral_genind <- vcfR2genind(neosho_neutral)

# Convert files for Smallmouth Bass samples
# smallmouth_outliers_genind <- vcfR2genind(smallmouth_outliers)  # No SNPs to work with (this code will not run)
smallmouth_neutral_genind <- vcfR2genind(smallmouth_neutral)

## Include population designations in genind objects

# Include populations for all black bass samples 
# all_outliers_genind@pop <- as.factor(all_pops) # No SNPs to work with (this code will not run)
all_neutral_genind@pop <- as.factor(all_pops)

# Include populations for species complex samples 
species_complex_outliers_genind@pop <- as.factor(species_complex_pops)
species_complex_neutral_genind@pop <- as.factor(species_complex_pops)

# Include populations for Neosho Bass samples 
neosho_outliers_genind@pop <- as.factor(neosho_pops)
neosho_neutral_genind@pop <- as.factor(neosho_pops)

# Include populations for Smallmouth Bass samples 
# smallmouth_outliers_genind@pop <- as.factor(smallmouth_pops) # No SNPs to work with (this code will not run)
smallmouth_neutral_genind@pop <- as.factor(smallmouth_pops)
```

Since there are no shared outlier SNPs for the black bass species combined dataset and for the Smallmouth Bass only dataset, we are at this point only moving forward with analysis on the species complex samples (Neosho Bass and Smallmouth Bass) and are not further analyzing all black bass species or only Smallmouth Bass.

#### 3b: Scale and impute missing data in genind objects.
In this step, we are calibrating all genomic data and imputing missing values so that DAPC will run. We are using the "mean" method of imputation, where the value of the genotype is computed based on a population mean.

##### 3b.1. Scale and impute data for species complex samples (Neosho Bass and Smallmouth Bass) and Neosho Bass samples only; run the Rmd chunk below:

##### Scale and impute data:
```{r}
## Scale data for species complex samples

# Scale outlier SNPs
species_complex_outliers_genind <- scaleGen(species_complex_outliers_genind, 
                                          center = TRUE, 
                                          scale = TRUE, 
                                          NA.method = c("mean"), 
                                          truenames = TRUE)

# Scale neutral SNPs
species_complex_neutral_genind <- scaleGen(species_complex_neutral_genind, 
                                          center = TRUE, 
                                          scale = TRUE, 
                                          NA.method = c("mean"), 
                                          truenames = TRUE)

## Scale data for Neosho Bass samples

# Scale outlier SNPs
neosho_outliers_genind <- scaleGen(neosho_outliers_genind, 
                                           center = TRUE, 
                                           scale = TRUE, 
                                           NA.method = c("mean"), 
                                           truenames = TRUE)
# Scale neutral SNPs
neosho_neutral_genind <- scaleGen(neosho_neutral_genind, 
                                          center = TRUE, 
                                          scale = TRUE, 
                                          NA.method = c("mean"), 
                                          truenames = TRUE)
```

#### 3c: Run cross validation analysis on species complex samples (Neosho Bass and Smallmouth Bass) and Neosho Bass samples only.
In this step, we are running a cross-validation analysis, using 90% of samples in the data as a training set and 10% of data as a test set, maximum number of pcs at 300, and 30 replicates per PC value tested, to choose the number of PCs to use in each analysis. We are choosing hte number of PCs that maximizes successful assignment to our a priori defined populations, which will then give us the optimal clustering patterns of the data.

##### 3c.1. Run cross validation tests on all hierarchical analyses; run the Rmd chunk below:

##### Run cross validation for DAPC:
```{r}
## Run cross validation for species complex samples

# Run analysis for outlier SNPs
species_complex_outliers_xval<- xvalDapc(species_complex_outliers_genind,
                                species_complex_pops,
                                n.pca.max = 300, 
                                training.set = 0.9,
                                result = "groupMean",
                                center = TRUE, 
                                scale = FALSE, 
                                n.pca = NULL,
                                n.rep = 30, 
                                xval.plot = TRUE)

# Run analysis for neutral SNPs
species_complex_neutral_xval <- xvalDapc(species_complex_neutral_genind, 
                               species_complex_pops,
                               n.pca.max = 300, 
                               training.set = 0.9,
                               result = "groupMean",
                               center = TRUE, 
                               scale = FALSE, 
                               n.pca = NULL,
                               n.rep = 30, 
                               xval.plot = TRUE)

## Run cross validation for Neosho Bass samples

# Run analysis for outlier SNPs
neosho_outliers_xval <- xvalDapc(neosho_outliers_genind,
                                neosho_pops,
                                n.pca.max = 300, 
                                training.set = 0.9,
                                result = "groupMean",
                                center = TRUE, 
                                scale = FALSE, 
                                n.pca = NULL,
                                n.rep = 30, 
                                xval.plot = TRUE)

# Run analysis for neutral SNPs
neosho_neutral_xval <- xvalDapc(neosho_neutral_genind, 
                               neosho_pops,
                               n.pca.max = 300, 
                               training.set = 0.9,
                               result = "groupMean",
                               center = TRUE, 
                               scale = FALSE, 
                               n.pca = NULL,
                               n.rep = 30, 
                               xval.plot = TRUE)
```

##### 3c.2. Generate plots to display results of cross validation; run the Rmd chunk below to create figure.

###### 3c.2.1. Extract cross validation statistics data from analyses run in Step 3c.1.

##### Extract cross-validaiton data:
```{r}
## Extract cross validation data from species complex samples

# Get xval data for outlier SNPs
species_complex_outliers_xval_data <- as.data.frame(species_complex_outliers_xval$`Cross-Validation Results`) 

# Get averages of assignment success to determine optimal number of PCs and for plotting
species_complex_outliers_xval_aves <- species_complex_outliers_xval_data %>%
   group_by(n.pca) %>%
   summarize(mean_success = mean(success))

# Get standard deviation of assignment success for plotting
species_complex_outliers_xval_sd <- species_complex_outliers_xval_data %>%
   group_by(n.pca) %>%
   summarize(sd_success = sd(success))

# Get xval data for neutral SNPs
species_complex_neutral_xval_data <- as.data.frame(species_complex_neutral_xval$`Cross-Validation Results`) 

# Get averages of assignment success to determine optimal number of PCs and for plotting
species_complex_neutral_xval_aves <- species_complex_neutral_xval_data %>%
   group_by(n.pca) %>%
   summarize(mean_success = mean(success))

# Get standard deviation of assignment success for plotting
species_complex_neutral_xval_sd <- species_complex_neutral_xval_data %>%
   group_by(n.pca) %>%
   summarize(sd_success = sd(success))

## Extract cross validation data from Neosho samples

# Get xval data for outlier SNPs
neosho_outliers_xval_data <- as.data.frame(neosho_outliers_xval$`Cross-Validation Results`) 

# Get averages of assignment success to determine optimal number of PCs and for plotting
neosho_outliers_xval_aves <- neosho_outliers_xval_data %>%
   group_by(n.pca) %>%
   summarize(mean_success = mean(success))

# Get standard deviation of assignment success for plotting
neosho_outliers_xval_sd <- neosho_outliers_xval_data %>%
   group_by(n.pca) %>%
   summarize(sd_success = sd(success))

# Get xval data for neutral SNPs
neosho_neutral_xval_data <- as.data.frame(neosho_neutral_xval$`Cross-Validation Results`) 

# Get averages of assignment success to determine optimal number of PCs and for plotting
neosho_neutral_xval_aves <- neosho_neutral_xval_data %>%
   group_by(n.pca) %>%
   summarize(mean_success = mean(success))

# Get standard deviation of assignment success for plotting
neosho_neutral_xval_sd <- neosho_neutral_xval_data %>%
   group_by(n.pca) %>%
   summarize(sd_success = sd(success))

# Merge averages and standard deviation for plotting
species_complex_outliers_xval_data <- merge(species_complex_outliers_xval_aves, species_complex_outliers_xval_sd, by = "n.pca")
species_complex_neutral_xval_data <- merge(species_complex_neutral_xval_aves, species_complex_neutral_xval_sd, by = "n.pca")
neosho_outliers_xval_data <- merge(neosho_outliers_xval_aves, neosho_outliers_xval_sd, by = "n.pca")
neosho_neutral_xval_data <- merge(neosho_neutral_xval_aves, neosho_neutral_xval_sd, by = "n.pca")
```

###### 3c.2.2. Generate plots for cross validation results; run the Rmd chunk below:

##### Generate figure for cross validation results: `figures/dapc_figures/xval.pdf`
```{r}
# Plot for species complex outlier SNPs
a <- ggplot(species_complex_outliers_xval_data, aes(x = n.pca, y = mean_success)) +
   geom_errorbar(aes(ymin = mean_success - sd_success, ymax = mean_success + sd_success), width=2) +
   geom_point(fill = "grey", color = "black", pch = 21, size = 6, show.legend = F) +
   theme_set(theme_cowplot(12)) +
   labs(x = "PCs retained", y = "Average CV success (%)") +
   theme(axis.text = element_text(size = 20)) +
   theme(axis.title = element_text(size = 20)) +
   scale_x_continuous("PCs retained", labels = as.character(species_complex_outliers_xval_data$n.pca), breaks = species_complex_outliers_xval_data$n.pca) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for species complex neutral SNPs
b <- ggplot(species_complex_neutral_xval_data, aes(x = n.pca, y = mean_success)) +
   geom_errorbar(aes(ymin = mean_success - sd_success, ymax = mean_success + sd_success), width=2) +
   geom_point(fill = "grey", color = "black", pch = 21, size = 6, show.legend = F) +
   theme_set(theme_cowplot(12)) +
   labs(x = "PCs retained", y = "Average CV success (%)") +
   theme(axis.text = element_text(size = 20)) +
   theme(axis.title = element_text(size = 20)) +
   scale_x_continuous("PCs retained", labels = as.character(species_complex_neutral_xval_data$n.pca), breaks = species_complex_neutral_xval_data$n.pca) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for neosho outlier SNPs
c <- ggplot(neosho_outliers_xval_data, aes(x = n.pca, y = mean_success)) +
   geom_errorbar(aes(ymin = mean_success - sd_success, ymax = mean_success + sd_success), width=2) +
   geom_point(fill = "grey", color = "black", pch = 21, size = 6, show.legend = F) +
   theme_set(theme_cowplot(12)) +
   labs(x = "PCs retained", y = "Average CV success (%)") +
   theme(axis.text = element_text(size = 20)) +
   theme(axis.title = element_text(size = 20)) +
   scale_x_continuous("PCs retained", labels = as.character(neosho_outliers_xval_data$n.pca), breaks = neosho_outliers_xval_data$n.pca) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot for neosho neutral SNPs
d <- ggplot(neosho_neutral_xval_data, aes(x = n.pca, y = mean_success)) +
   geom_errorbar(aes(ymin = mean_success - sd_success, ymax = mean_success + sd_success), width=2) +
   geom_point(fill = "grey", color = "black", pch = 21, size = 6, show.legend = F) +
   theme_set(theme_cowplot(12)) +
   labs(x = "PCs retained", y = "Average CV success (%)") +
   theme(axis.text = element_text(size = 20)) +
   theme(axis.title = element_text(size = 20)) +
   scale_x_continuous("PCs retained", labels = as.character(neosho_neutral_xval_data$n.pca), breaks = neosho_neutral_xval_data$n.pca) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

pdf("figures/dapc_figures/xval.pdf", width=13, height=14)

plot_grid(a,b,c,d, 
          nrows = 2, 
          ncol = 2)

dev.off()
```

This figure is the basis for Supplementary Figure 8 in our manuscript.

#### 3d: Run DAPC analysis on species complex samples (Neosho Bass and Smallmouth Bass) and Neosho Bass only; run the Rmd chunk below. 
For this analysis, it is necessary to pay attention to the console, because it will prompt you to enter the desired number of PCs (determined above) and Discriminant functions. For all analyses, we are retaining only two discriminant functions for ease of visualization.

## Run DAPC analyses:
```{r}
#Run DAPC on species complex outlier SNPs
species_complex_outliers_dapc <- dapc(species_complex_outliers_genind, species_complex_pops) # 25 PCs 

#Run DAPC on species complex neutral SNPs
species_complex_neutral_dapc <- dapc(species_complex_neutral_genind, smb_pops) # 5 PCs


#Run DAPC on Neosho Bass outlier SNPs
neosho_outliers_dapc <- dapc(neosho_outliers_genind, neosho_pops) # 6 PCs

#Run DAPC on Neosho Bass outlier SNPs
neosho_neutrals_dapc <- dapc(neosho_neutral_genind, neosho_pops) # 10 PCs
```

##### 3d.1. Extract PC and Discriminant Functions plots (insets in the scatter() dapc function), which give information on the number of PCs used and the number of Discriminant functions retained.
We generated individual scatter plots for our DAPC analyses above and manually extracted the PC and DF plots by cropping and manipulating in PowerPoint. Individual plots are printed here and can be further manipulated as needed.

###### 3d.1.1. Generate individual DAPC scatter plots for extracting PC and DF mini-plots:
```{r}
##Get the little PCA-explained and LDs used graphs from species complex outliers 
pdf("figures/dapc_figures/pcld_species_complex_outliers.pdf", width=11, height=9)

scatter(species_complex_outliers_dapc, 
        posi.da = "topright", 
        scree.pca = TRUE, 
        posi.pca = "bottomright")

dev.off()

##Get the little PCA-explained and LDs used graphs from species complex neutral
pdf("figures/dapc_figures/pcld_species_complex_neutral.pdf", width=11, height=9)

scatter(species_complex_neutral_dapc, 
        posi.da = "bottomright", 
        scree.pca = TRUE, 
        posi.pca = "topright")

dev.off()

##Get the little PCA-explained and LDs used graphs from Neosho Bass outliers 
pdf("figures/dapc_figures/pcld_neosho_outliers.pdf", width=11, height=9)

scatter(neosho_outliers_dapc, 
        posi.da = "topright", 
        scree.pca = TRUE, 
        posi.pca = "bottomright")

dev.off()

##Get the little PCA-explained and LDs used graphs from Neosho BAss neutral
pdf("figures/dapc_figures/pcld_neosho_neutral.pdf", width=11, height=9)

scatter(neosho_neutral_dapc, 
        posi.da = "bottomright", 
        scree.pca = TRUE, 
        posi.pca = "topright")

dev.off()
```

These figures are the basis for Supplementary Figure 9 in our manuscript.

#### 3e: Plot results from DAPC analyses for species complex samples (Neosho Bass and Smallmouth Bass) and Neosho Bass only.
In this step, we are plotting all results from DAPC analysis.

##### 3e.1. Extract LD information and append population designations for plotting; run the Rmd chunk below:

##### Extract LD information:
```{r}
## Get LD and population information from species complex sample outlier SNPs

# Get lds
species_complex_outliers_ld <- as.data.frame(species_complex_outliers_dapc$ind.coord)

# Bind lds with population data
species_complex_outliers_ld <- cbind(data.frame(species_complex_pops), species_complex_outliers_ld)

# Modify column names
colnames(species_complex_outliers_ld) <- c("pop","LD1","LD2")

## Get LD and population information from species complex sample neutral SNPs

# Get lds
species_complex_neutral_ld <- as.data.frame(species_complex_neutral_dapc$ind.coord)

# Bind lds with population data
species_complex_neutral_ld <- cbind(data.frame(species_complex_pops), species_complex_neutral_ld)

# Modify column names
colnames(species_complex_neutral_ld) <- c("pop","LD1","LD2")


## Get LD and population information from Neosho Bass sample outlier SNPs

# Get lds
neosho_outliers_ld <- as.data.frame(neosho_outliers_dapc$ind.coord)

# Bind lds with population data
neosho_outliers_ld <- cbind(data.frame(neosho_pops), neosho_outliers_ld)

# Modify column names
colnames(neosho_outliers_ld) <- c("pop","LD1","LD2")

## Get LD and population information from Neosho Bass sample neutral SNPs

# Get lds
neosho_neutral_ld <- as.data.frame(neosho_neutral_dapc$ind.coord)

# Bind lds with population data
neosho_neutral_ld <- cbind(data.frame(neosho_pops), neosho_neutral_ld)

# Modify column names
colnames(neosho_neutral_ld) <- c("pop","LD1","LD2")
```

##### 3e.2. Plot DAPC results; run the Rmd chunk below:
We have chosen to combine each DAPC analysis as an individual panel into a single plot. Plots are named "a", "b", "c", "d" and are included in that order in the manuscript. 

##### Extract LD information:

```{r}
# Plot species complex outlier SNPs
a <- ggplot(species_complex_outliers_ld, aes(x = LD1, y = LD2, fill = pop)) +
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 6, show.legend = F) +
   labs(x = "LD1", y = "LD2", fill = "Population") +
   scale_fill_manual(values = c("lightgreen", "sienna4","mediumpurple","forestgreen" ,"deepskyblue", "chocolate1", "navyblue","orchid1","deeppink2","deeppink2","orchid1")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 20)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 15)) +
   theme(legend.position = c(0.7,0.26)) +
   theme(legend.background = element_rect(color = "black", size = 0.5)) + 
   theme(legend.margin = margin(5, 5, 5, 5)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 20)) +
   theme(axis.title.x = element_blank()) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot species complex neutral SNPs
b <- ggplot(species_complex_neutral_ld, aes(x = LD1, y = LD2, fill = pop)) +
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 6, show.legend = F) +
   labs(x = "LD1", y = "LD2", fill = "Population") +
   scale_fill_manual(values = c("lightgreen", "sienna4","mediumpurple","forestgreen" ,"deepskyblue", "chocolate1", "navyblue","orchid1","deeppink2","deeppink2","orchid1")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 25)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 25)) +
   theme(legend.position = c(0.5,0.4)) +
   theme(legend.background = element_rect(color = "black", size = 0.5)) + 
   theme(legend.margin = margin(5, 5, 5, 5)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 20)) + 
   theme(axis.title = element_blank()) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot Neosho Bass outlier SNPs
c <- ggplot(neosho_neutral_ld, aes(x = LD1, y = LD2, fill = pop)) +
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 6, show.legend = F) +
   labs(x = "LD1", y = "LD2", fill = "Population") +
   scale_fill_manual(values = c("lightgreen", "sienna4", "mediumpurple", "forestgreen","deepskyblue","orchid1")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 20)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 20)) +
   theme(legend.position = c(0.7,0.26)) +
   theme(legend.background = element_rect(color = "black", size = 0.5)) + 
   theme(legend.margin = margin(5, 5, 5, 5)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 20)) +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Plot Neosho Bass neutral SNPs
d <- ggplot(neosho_neutral_ld, aes(x = LD1, y = LD2, fill = pop)) +
   geom_point(aes(fill = pop), color = "black", pch = 21, size = 6, show.legend = F) +
   labs(x = "LD1", y = "LD2", fill = "Population") +
   scale_fill_manual(values = c("lightgreen", "sienna4", "mediumpurple", "forestgreen","deepskyblue","orchid1")) +
   theme_set(theme_cowplot(12)) +
   theme(legend.title = element_text(size = 20)) +
   theme(legend.title = element_text(face = "bold")) +
   theme(legend.text = element_text(size = 20)) +
   theme(legend.position = c(0.7,0.26)) +
   theme(legend.background = element_rect(color = "black", size = 0.5)) + 
   theme(legend.margin = margin(5, 5, 5, 5)) +
   theme(axis.title = element_text(size = 20)) +
   theme(axis.text = element_text(size = 20)) +
   theme(axis.title.y = element_blank())  +
   theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

# Combine all plots
pdf("figures/dapc_figures/dapc.pdf", width=11, height=9)

plot_grid(a,b,c,d, 
          nrow = 2)

dev.off()
```

This figure is the basis for Figure 3 in the maintext of our manuscript.

### ----------------------- END OF PHASE 4: OUTLIER MAPPING ----------------------- ###


