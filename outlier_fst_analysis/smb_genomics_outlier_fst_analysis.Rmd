---
title: 'Analysis 6: Directional Selection Analysis'
author: "Joe Gunn"
date: "2022-09-03"
output: html_document
---

# Project: Population genomic analysis of Smallmouth Bass and Neosho Bass in the Central Interior Highlands
We investigated the extent of genomic divergence, local directional selection, and admixture between the Smallmouth Bass (<i>Micropterus dolomieu</i>) and the Neosho Bass (<i>M. velox</i>) in the Central Interior Highlands (CIH) ecoregion of central north America. Specifically, we used ddRADseq data to assessed the phylogenomic relationship between and within species, characterizing inter- and intraspecific diversity and SNPs potentially under local directional selection at the population level. Additionally, we inferred the relative timing of admxiture in Neosho Bass streams where there is known introgressive hybridization with Smallmouth Bass to understand the influence of natural, historic geographic factors on mixing (stream capture or transient flooding) vs. anthropogenic factors (i.e., non-native introductions through stocking), which is known to have occurred widely in these economically valuable species. We ultimately hoped to provide novel insights into the diversity of endemic, ecologically important and popular sport fish in the CIH.

## Specific Aim: Directional selection analysis
In this analysis, we used the popgen.vcf data generated in Analysis 2 (SNP Filtering...) to scan for signatures of directional selection on SNP loci with outlier Fst (high outlier Fst: directional selection; low Fst: balancing selection). We used two software programs with different underlying statistical frameworks to detect outliers and then used any outliers commonly detected in both analyses as canditates for being under strong selection. Specifically, we used the software program BAYESCAN (based in Bayesian analysis) and the R package PCAdapt principal component analysis (based in multivariate principal component analysis). We then employed DAPC in R to map patterns of population differentiation at any shared outlier and neutral loci to detect populations that may be under differential selection pressures and to detect signatures of genetic drift, respectively.

## Phases of analysis:
### Phase 1: Data preparation
### Phase 2: Outlier Fst analysis with BAYESCAN
### Phase 3: Outlier Fst analysis with PCADAPT
### Phase 4: Outlier mapping

## Libraries needed for analysis
```{r setup, echo = FALSE, include=FALSE}
library(readxl)
library(tidyverse)
library(cowplot)
library(devtools)
library(SNPRelate)
library(vcfR)
library(pophelper)
library(PopGenome)
library(pcadapt)
library(viridis)
```

## PHASE 1: DATA PREPARATION
In this phase of the analysis, we are converting the fully filtered, thinned dataset excluding Spotted Bass and the Spotted Bass hybrid (`admixture_phylogenomics_analysis/data/processed_vcf/03_popgen_spb.vcf`) into input files compatible with the software programs BAYESCAN and the R package PCAdapt. For BAYESCAN, we are using the intermediate conversion software PGDSPIDER to generate input files, and for PCAdapt, we are again using the program PLINK.

For the outlier Fst analysis, we are conducing scans for outlier loci hiearchically at the black bass species level (between Spotted Bass, Smallmouth Bass, and Neosho Bass), among species within the Smallmouth Bass species complex (Smallmouth Bass and Neosho Bass), and among populations within black bass species. The goal with this structure is to reduce false positive detection due to population structure and to detect potentially selected SNPs at each hierarchical level.

With this analysis structure, we conducted scans with the following sets of data: 

1) All black bass samples, including Spotted Bass, Smallmouth Bass, and Neosho Bass (excluding the Spotted Bass hybrid)
2) All Smallmouth Bass and Neosho Bass samples, excluding Spotted Bass
3) All Neosho Bass populations only
4) All Smallmouth Bass populations only

All analyses conducted by calling commands in bash shell scripts were performed on the Lewis high-performance computing cluster at the University of Missouri <br>

<b>Programs needed</b>: <br><br>

PGDSPIDER v.2.1.1.5 (Lischer and Excoffier 2012) <br>

<b>Citation</b>:<br>

Lischer, H. E. L., E& Excoffier, L. (2012). PGDSpider: an automated data conversion tool fo connecting population genetics and genomics programs. Bionformatics, 28, 298-299. doi:/10.1093/bioinformatics/btr642


PLINK v.1.90p (high-contig build; Change et al. 2015) <br>

<b>Citation</b>:<br>

Chang, C. C., Chow, C. C., Tellier, L. C. A. M., Vattikuti, S., Purcell, S. M., & Lee, J. J. (2015). Second-generation PLINK: Rising to the challenge of larger and richer datasets. GigaScience, 4, 1–16. doi:10.1186/s13742-015-0047-8

### STEP 1: Prepare input data for BAYESCAN.
In this step, we are using the conversion software PGDSPIDER to prepare all input data for the software program BAYESCAN.

#### 1a: Filter fully filtered, thinned VCF file (excluding Spotted Bass hybrid) for each analysis level 
In this step, we are generating filtered VCF data to to run each level of the outlier Fst analysis (see above for the four hierarchical levels of analysis)  

##### 1a.1. Generate a general bash shell script header for all VCF filtering steps commands
In this step, we are generating a universal bash shell script to run all filtering commands in VCFTOOLS (See Phase 1 in Analysis 2 for programs needed and citation information) Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all VCFTOOLS code is called "vcftools.sh".

###### 1a.1.1 Copy and paste the code below in a new shell script file:

##### Generate VCFTOOLS bash shell script: `code/shell_scripts/vcftools.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J filter_admixed  # give the job a custom name
#SBATCH -o filtering_missing.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

## UNCOMMENT LINES STARTING HERE 

## Load VCFtools module
# module load rss/rss-2020
# module load vcftools/vcftools-v0.1.14
```

##### 1a.2. Generate lists of individuals to use for all filtering steps.
In this step, we are generating lists of individuals to filter from the VCF dataset. For the first level of analysis (all black bass samples, we are not excluding any samples). For the second level of analysis, we are excluding Spotted Bass. For the third level of analysis, we are excluding all Smallmouth Bass to retain only Neosho Bass. For the fourth analysis, we are excluding all Neosho Bass to retain only Smallmouth Bass.

###### 1a.2.1. Generate a list of Spotted Bass to omit from analyses 2, 3, and 4.

##### Generate list file: `data/filtering_data/spotted_bass.txt`
```{r}
# Load in full metadata
load("../raw_data/metadata.Rda")

# Filter all individuals but Spotted Bass
spotted_bass <- metadata %>%
  filter(species == "Spotted_Bass")

# Convert to dataframe
spotted_bass <- data.frame(spotted_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(spotted_bass, 
          file = "data/filtering_data/spotted_bass.txt", 
          col_names = FALSE)

# Turn column into vector without column name to save as un-headered list for downstream filtering
spotted_bass <- as.vector(spotted_bass$sample_id)

# Save the list of bad samples as a .Rda file without column names
save(spotted_bass, file = "data/filtering_data/spotted_bass.Rda")
```

###### 1a.2.2. Generate a list of Smallmouth Bass to omit from analysis 3.

##### Generate list file: `data/filtering_data/smallmouth_bass.txt`
```{r}
# Filter all individuals but Spotted Bass
smallmouth_bass <- metadata %>%
  filter(species == "Smallmouth_Bass")

# Convert to dataframe
smallmouth_bass <- data.frame(smallmouth_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(smallmouth_bass, 
          file = "data/filtering_data/smallmouth_bass.txt", 
          col_names = FALSE)

# Turn column into vector without column name to save as un-headered list for downstream filtering
smallmouth_bass <- as.vector(smallmouth_bass$sample_id)

# Save the list of bad samples as a .Rda file without column names
save(smallmouth_bass, file = "data/filtering_data/smallmouth_bass.Rda")
```

###### 1a.2.3. Generate a list of Neosho Bass to omit from analysis 4.

##### Generate list file: `data/filtering_data/neosho_bass.txt`
```{r}
# Filter all individuals but Spotted Bass
neosho_bass <- metadata %>%
  filter(species == "Neosho_Bass")

# Convert to dataframe
neosho_bass <- data.frame(neosho_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(neosho_bass, 
          file = "data/filtering_data/neosho_bass.txt", 
          col_names = FALSE)

# Turn column into vector without column name to save as un-headered list for downstream filtering
neosho_bass <- as.vector(neosho_bass$sample_id)

# Save the list of bad samples as a .Rda file without column names
save(neosho_bass, file = "data/filtering_data/neosho_bass.Rda")
```

#### 1a.3. Filter VCF files.

##### 1a.3.1. Filter out Spotted Bass to generate VCF for species complex samples (Smallmouth Bass and Neosho Bass); copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 01: omit Spotted Bass individuals to get samples at the species complex level (Smallmouth Bass and Neosho Bass only)
#vcftools --vcf ../../data/processed_vcf/01_popgen_spb_hybrid.vcf --remove ../../data/filtering_data/spotted_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/02_popgen_species_complex
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/02_popgen_species_complex.vcf`.

##### 1a.3.2. Filter out Smallmouth Bass to generate VCF for Neosho Bass samples (Neosho Bass only); copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 02: omit Smallmouth Bass samples to get only Neosho samples for the Neosho Bass population level
#vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --remove ../../data/filtering_data/smallmouth_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/03_popgen_neosho
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/03_popgen_neosho.vcf`.

##### 1a.3.3. Filter out Smallmouth Bass to generate VCF for Smallmouth Bass samples (Smallmouth Bass only); copy and paste the code below in the shell file generated in Step 1a.1.1 above, which will generate a filtered VCF:

##### Command line code for filtering VCF. UNCOMMENT this code in the shell script:
```{bash}
## filter 03: omit Neosho Bass samples to get only Smallmouth Bass samples for the Smallmouth Bass population level
#vcftools --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --remove ../../data/filtering_data/neosho_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/04_popgen_smallmouth
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_vcf/03_popgen_neosho.vcf`.

#### 1b: Generate PGDSPIDER accompanying SPID files
In this step, we are generating text scripts for an accompanying file needed for PGDSPIDER conversions called a "spid" file. This file includes specific parameters that must to be completed for each file conversion in order to generate the correct output.

##### 1b.1. Generate a general text script for PGDSPIDER SPID file
Here, we only provide the base script without any parameters filled in. In subsequent steps, we include the completed version for each file conversion with specific parameters. The base script is called "spid.spid".

###### 1b.1.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/spid.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=
```

##### 1b.2. Generate a PGDSPIDER SPID file for the black bass level genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the Black Bass level genome scan, which includes all Spotted Bass, Smallmouth Bass, and Neosho Bass.

###### 1b.2.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/01_all.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/01_all_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

##### 1b.3. Generate a PGDSPIDER SPID file for the Smallmouth Bass species complex genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the species complex level genome scan, which includes all Smallmouth Bass and Neosho Bass.

###### 1b.3.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/02_species_complex.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/02_species_complex_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

##### 1b.4. Generate a PGDSPIDER SPID file for the Neosho Bass genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the Neosho Bass population level genome scan, which includes all Neosho Bass only

###### 1b.4.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/03_neosho.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/03_neosho_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

##### 1b.5. Generate a PGDSPIDER SPID file for the Neosho Bass genome scan
Here, we are filling in the parameters necessary to generate a spid file to convert input data to BAYESCAN format the Smallmouth Bass population level genome scan, which includes all Smallmouth Bass only

###### 1b.5.1. Copy and paste the code below in a new shell script file:

##### Generate base SPID text script: `code/spid_files/04_smallmouth.spid`. UNCOMMENT every other (all caps) line and fill in with the necessary parameters for each file conversion.
```{bash}
# VCF Parser questions
#PARSER_FORMAT=VCF

# Do you want to include a file with population definitions?
#VCF_PARSER_POP_QUESTION=true
# Only input following regions (refSeqName:start:end, multiple regions: whitespace separated):
#VCF_PARSER_REGION_QUESTION=
# What is the ploidy of the data?
#VCF_PARSER_PLOIDY_QUESTION=DIPLOID
# Only output following individuals (ind1, ind2, ind4, ...):
#VCF_PARSER_IND_QUESTION=
# Output genotypes as missing if the read depth of a position for the sample is below:
#VCF_PARSER_READ_QUESTION=
# Take most likely genotype if "PL" or "GL" is given in the genotype field?
#VCF_PARSER_PL_QUESTION=false
# Do you want to exclude loci with only missing data?
#VCF_PARSER_EXC_MISSING_LOCI_QUESTION=false
# Select population definition file:
#VCF_PARSER_POP_FILE_QUESTION=../../data/pop_files/04_smallmouth_pops.txt
# Only output SNPs with a phred-scaled quality of at least:
#VCF_PARSER_QUAL_QUESTION=
# Do you want to include non-polymorphic SNPs?
#VCF_PARSER_MONOMORPHIC_QUESTION=false
# Output genotypes as missing if the phred-scale genotype quality is below:
#VCF_PARSER_GTQUAL_QUESTION=

# BayeScan Parser Questions
#WRITER_FORMAT=GESTE_BAYE_SCAN

# What type of data are we dealing with?
#GESTE_BAYE_SCAN_WRITER_DATA_TYPE_QUESTION=SNP
```

#### 1c: Generate population designation files (read by SPID files)
In this step, we are generating text files listing all samples in at each genome scan level and their corresponding population designations as inferred in Analysis 4 (population inference). Our inferred populations were named according to their general geographic locations (see Phase 4 of population_analysis, "MIDARK", "ELK", "BAYOU", etc.), but PGDSPIDER expects input populations in a specific format (i.e., "pop_1", "pop_2", etc.). We generate population files according to this naming convention

##### 1c.1. Read in sample metadata and generate lists of populations for the black bass species level.

###### 1c.1.1 Generate population file for all black bass samples (Spotted Bass, Smallmouth Bass, and Neosho Bass):

##### Generate population file: `data/pop_files/01_all_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

metadata_populations_spb <- metadata_populations_spb %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_spb$population[metadata_populations_spb$population == "MIDARK"] <- "pop_1"
metadata_populations_spb$population[metadata_populations_spb$population == "MISS"] <- "pop_2"
metadata_populations_spb$population[metadata_populations_spb$population == "SKIA"] <- "pop_3"
metadata_populations_spb$population[metadata_populations_spb$population == "LMULB"] <- "pop_4"
metadata_populations_spb$population[metadata_populations_spb$population == "WHITE"] <- "pop_5"
metadata_populations_spb$population[metadata_populations_spb$population == "ELK"] <- "pop_6"
metadata_populations_spb$population[metadata_populations_spb$population == "ILLI"] <- "pop_7"
metadata_populations_spb$population[metadata_populations_spb$population == "UPPARK"] <- "pop_8"
metadata_populations_spb$population[metadata_populations_spb$population == "BAYOU"] <- "pop_9"
metadata_populations_spb$population[metadata_populations_spb$population == "SPB"] <- "pop_10"

# Generate text file
write_delim(metadata_populations_spb, 
          delim = " ",
          file = "data/pop_files/01_all_pops.txt", 
          col_names = FALSE)
```

##### 1c.2. Read in sample metadata and generate lists of populations for the species complex level.

###### 1c.2.1 Generate population file for species complex samples (Smallmouth Bass and Neosho Bass):

##### Generate population file: `data/pop_files/02_species_complex_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

metadata_populations_complex <- metadata_populations_spb %>%
  filter(population != "SPB")

metadata_populations_complex <- metadata_populations_complex %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_complex$population[metadata_populations_complex$population == "MIDARK"] <- "pop_1"
metadata_populations_complex$population[metadata_populations_complex$population == "MISS"] <- "pop_2"
metadata_populations_complex$population[metadata_populations_complex$population == "SKIA"] <- "pop_3"
metadata_populations_complex$population[metadata_populations_complex$population == "LMULB"] <- "pop_4"
metadata_populations_complex$population[metadata_populations_complex$population == "WHITE"] <- "pop_5"
metadata_populations_complex$population[metadata_populations_complex$population == "ELK"] <- "pop_6"
metadata_populations_complex$population[metadata_populations_complex$population == "ILLI"] <- "pop_7"
metadata_populations_complex$population[metadata_populations_complex$population == "UPPARK"] <- "pop_8"
metadata_populations_complex$population[metadata_populations_complex$population == "BAYOU"] <- "pop_9"

# Generate text file
write_delim(metadata_populations_complex, 
          delim = " ",
          file = "data/pop_files/02_species_complex_pops.txt", 
          col_names = FALSE)
```

##### 1c.3. Read in sample metadata and generate lists of populations for the Neosho Bass level.

###### 1c.3.1 Generate population file for Neosho Bass samples (Neosho Bass only):

##### Generate population file: `data/pop_files/03_neosho_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

metadata_populations_neosho <- metadata_populations_spb %>%
  filter(population != "SPB") %>%
  filter(population != "MISS") %>%
  filter(population != "SKIA") %>%
  filter(population != "WHITE")

metadata_populations_neosho <- metadata_populations_neosho %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_neosho$population[metadata_populations_neosho$population == "MIDARK"] <- "pop_1"
metadata_populations_neosho$population[metadata_populations_neosho$population == "LMULB"] <- "pop_2"
metadata_populations_neosho$population[metadata_populations_neosho$population == "ELK"] <- "pop_3"
metadata_populations_neosho$population[metadata_populations_neosho$population == "ILLI"] <- "pop_4"
metadata_populations_neosho$population[metadata_populations_neosho$population == "UPPARK"] <- "pop_5"
metadata_populations_neosho$population[metadata_populations_neosho$population == "BAYOU"] <- "pop_6"

# Generate text file
write_delim(metadata_populations_neosho, 
          delim = " ",
          file = "data/pop_files/03_neosho_pops.txt", 
          col_names = FALSE)
```

##### 1c.4. Read in sample metadata and generate lists of populations for the Smallmouth Bass level.

###### 1c.4.1 Generate population file for Smallmouth Bass samples (Smallmouth Bass only):

##### Generate population file: `data/pop_files/04_neosho_pops.txt`
```{r}
# Load in full sample metadata file with population designations (inferred in Analysis 4, population_analysis)
load("../population_analysis/data/metadata/metadata_populations_spb.Rda")

metadata_populations_smallmouth <- metadata_populations_spb %>%
  filter(population != "SPB") %>%
  filter(population != "MIDARK") %>%
  filter(population != "ELK") %>%
  filter(population != "ILLI") %>%
  filter(population != "LMULB") %>%
  filter(population != "BAYOU") %>%
  filter(population != "UPPARK")

metadata_populations_smallmouth <- metadata_populations_smallmouth %>%
  mutate(population = as.character(population))

# Rename population designations in SPID format ("pop_1", "pop_2", etc.)
metadata_populations_smallmouth$population[metadata_populations_smallmouth$population == "WHITE"] <- "pop_1"
metadata_populations_smallmouth$population[metadata_populations_smallmouth$population == "MISS"] <- "pop_2"
metadata_populations_smallmouth$population[metadata_populations_smallmouth$population == "SKIA"] <- "pop_3"

# Generate text file
write_delim(metadata_populations_smallmouth, 
          delim = " ",
          file = "data/pop_files/04_smallmouth_pops.txt", 
          col_names = FALSE)
```

#### 1d: Generate a general bash shell script header for all PGDSPIDER conversion commands
In this step, we are generating a universal bash shell script to run all file type conversions in PGDSPIDER. Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all PGDSPIDER code is called "pgdspider.sh".

##### 1d.1: Copy and paste the code below in a new shell script file:

##### Generate PGDSPIDER bash shell script: `code/shell_scripts/pgdspider.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J pgd_coversion  # give the job a custom name
#SBATCH -o pgd_results-%j.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit
#SBATCH --mem-per-cpu=8G

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

# UNCOMMENT STARTING HERE

## Commands here run only on the first core
# module load rss/rss-2020
# module load pgdspider/pgdspider-2.1.1.5
```

#### 1e: Convert VCF files to BAYESCAN format.
In this step, we are using the general bash script for PGDSPIDER in addition to the four unique spid files for each analysis level to generate input files for BAYESCAN.

##### 1e.1. Convert VCF to BAYESCAN format for all black bass samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for all samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 01: all black bass samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/01_popgen_spb_hybrid.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/01_all -outputformat GESTE_BAYE_SCAN -spid ../spid_files/01_all.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/01_all`

##### 1e.2. Convert VCF to BAYESCAN format for all species complex samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for speices complex samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 02: species complex samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/02_popgen_species_complex.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/02_species_complex -outputformat GESTE_BAYE_SCAN -spid ../spid_files/02_species_complex.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/02_species_complex`

##### 1e.3. Convert VCF to BAYESCAN format for Neosho Bass samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for Neosho Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 03: Neosho Bass samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/03_popgen_neosho.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/03_neosho -outputformat GESTE_BAYE_SCAN -spid ../spid_files/03_neosho.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/03_neosho`

##### 1e.4. Convert VCF to BAYESCAN format for Smallmouth Bass samples; copy and paste the code below in the shell file generated in Step 1d.1 above, which will generate a BAYESCAN file:

##### Command line code for generating BAYESCAN file for Smallmouth Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## conversion 04: Smallmouth Bass samples
#java -Xmx8g -Xms8g -jar ${PGDSPIDER_ROOT}/PGDSpider2-cli.jar -inputfile ../../data/processed_vcf/04_popgen_smallmouth.vcf -inputformat VCF -outputfile ../../data/processed_bayescan/04_smallmouth -outputformat GESTE_BAYE_SCAN -spid ../spid_files/04_smallmouth.spid
```

Run: `sbatch pgdspider.sh`

This code generates the file: `data/processed_bayescan/04_smallmouth`

### STEP 2: Prepare input data for PCADAPT
In this step, we are preparing all input data for the R program PCADAPT. PCADAPT reads .bed files (generated in the software program PLINK) as input, along with accompanying .bim and .fam files.

#### 2a: Generate a general bash shell script header for all PLINK commands
In this step, we are generating a universal bash shell script to run all file type conversions in PLINK. Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion and the associated lines of code in Rmd chunks. The shell script for running all PLINK code is called "plink.sh".

##### 2a.1. Copy and paste the code below in a new shell script file:

##### Generate PLINK bash shell script: `code/shell_scripts/plink.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J plink # give the job a custom name
#SBATCH -o plink.out  # give the job output a custom name
#SBATCH -t 0-01:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

## Commands here run only on the first core

# (UNCOMMENT THIS LINE TO RUN THE CODE)

## Modules to load

# module load rss/rss-2020
# module load plink/plink-high-contig-1.90p 
```

#### 2b: Convert VCF data into .bed format for PCADAPT analysis.

##### 2a.1. Convert VCF data for all black bass samples; copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 01: Convert VCF data for all black bass samples (excluding Spotted Bass hybrid, BFC10) to .bed format
#plink --vcf ../../data/processed_vcf/01_popgen_spb_hybrid.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/01_all_output/01_all
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/01_all_output/01_all.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.

##### 2a.2. Convert VCF data for species complex samples (Neosho Bass and Smallmouth Bass); copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 02: Convert VCF data for species complex samples (Neosho Bass and Smallmouth Bass) to .bed format
#plink --vcf ../../data/processed_vcf/02_popgen_species_complex.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/02_species_complex_output/02_species_complex
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/02_species_complex_output/02_species_complex.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.

##### 2a.3. Convert VCF data for Neosho Bass samples only; copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 03: Convert VCF data for Neosho Bass only to .bed format
#plink --vcf ../../data/processed_vcf/03_popgen_neosho.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/03_neosho_output/03_neosho
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/03_neosho_output/03_neosho.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.

##### 2a.4. Convert VCF data for Smallmouth Bass samples only; copy and paste the code below in the shell file generated in Step 2a above, which will generate a .bed, along with .bim, .fam, .log, and .nosex files:

<b>We use the following flags in the code</b>: <br>
    --allow-extra-chr: this flag is necessary due to the data being in the format of contigs rather than chromosomes
    --vcf-half-call m: this flag treats any half genotype calls (e.g., '0/.' or './1') as missing data
    --make-bed: this specifies output format of .bed

##### Command line code for converting VCF to BED. UNCOMMENT this code in the shell script:
```{bash}
## Conversion 04: Convert VCF data for Smallmouth Bass only to .bed format
#plink --vcf ../../data/processed_vcf/04_popgen_smallmouth.vcf --allow-extra-chr --vcf-half-call m --make-bed --out ../../data/processed_bed/04_smallmouth_output/04_smallmouth
```

Run: `sbatch plink.sh`

This code generates the file: `data/processed_bed/04_smallmouth_output/04_smallmouth.bed`, along with accompanying file types. This file should be used as input for PCADAPT analysis.


### ----------------------- END OF PHASE 1: DATA PREPARATION ----------------------- ###

## PHASE 2: OUTLIER ANALYSIS WITH BAYESCAN
In this phase of the analysis, we are using the software program BAYESCAN to conduct a genome scan for SNP loci with outlier Fst values to assess potential signatures of local directional selection and neutrality at various loci. We are conducting this analysis at four hierarchical levels, as listed in the description for Phase 1 of the analysis (see above). We are using input data for each hierarchical level of analysis as generated in Phase 1 of this analysis.

BAYESCAN uses a Bayesian framework to calculate probabilities of outlier loci across the genome.

All analyses conducted by calling commands in bash shell scripts were performed on the Lewis high-performance computing cluster at the University of Missouri <br>

 
 <b>Programs needed</b>: <br><br>

BAYESCAN v.2.1 (Foll & Gaggiotti 2008) <br>

<b>Citation</b>:<br>

Foll, M., & Gaggiotti, O. (2008). A genome-scan method to identify selected loci appropriate for both dominant and codominant markers: A Bayesian perspective. Genetics, 180, 977–993. doi:10.1534/genetics.108.092221


### STEP 1: Generate a general bash shell script header for all BAYESCAN runs.
In this step, we are generating a universal bash shell script to run all analyses in BAYESCAN Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each analysis and the associated lines of code in Rmd chunks. The shell script for running all BAYESCAN code is called "bayescan.sh".

#### 1a: Copy and paste the code below in a new shell script file:

##### Generate BAYESCAN bash shell script: `code/shell_scripts/bayescan.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J bayescan # give the job a custom name
#SBATCH -o bayescan.out  # give the job output a custom name
#SBATCH -t 1-00:00:00  # two day time limit
#SBATCH --account=biosci
#SBATCH -N 1  # number of nodes
#SBATCH -n 21  # number of cores (AKA tasks)

# UNCOMMENT STARTING HERE

## Load modules needed
# module load rss/rss-2020
# module load bayescan/bayescan-2.1
```

#### 1b: Conduct genome scans in BAYESCAN for all hierarchical analyses
In this step, we are conducting genome scans for outlier Fst loci using the software program BAYESCAN.

We used the same parameter set for each hierarchical analysis, as follows: <br<

<b>Parameters set for BAYESCAN analysis</b>: <br>
Default parameters: <br>
 -n 5000 (number of MCMC iterations) <br>
 -thin 10 (number at which to thin MCMC iterations) <br>
 -nbp 20 (number of pilot runs) <br>
 -pilot 5000 (length of pilot runs) <br>
 -burni 5000 (length of burnin run) <br>
 
##### 1b.1. Run BAYESCAN for all black bass species (Spotted Bass, Neosho Bass, and Smallmouth Bass); copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on all black bass samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 1: all black bass samples
# bayescan 01_all -od ../../data/bayescan_output -o 01_all_output/01_all
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/01_all_output/`. The files are:

1) 01_all_AccRte.txt
2) 01_all_fst.txt
3) 01_all.sel
4) 01_all_Verif.txt

##### 1b.2. Run BAYESCAN for species complex samples (eosho Bass and Smallmouth Bass); copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on species complex samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 2: species complex samples (Neosho Bass and Smallmouth Bass)
# bayescan 02_species_complex -od ../../data/bayescan_output -o 02_species_complex
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/02_species_complex_output/`. The files are:

1) 02_species_complex_AccRte.txt
2) 02_species_complex_fst.txt
3) 02_species_complex.sel
4) 02_species_complex_Verif.txt

##### 1b.3. Run BAYESCAN for Neosho Bass only; copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on Neosho Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 3: Neosho Bass samples (Neosho Bass only)
# bayescan 03_neosho -od ../../data/bayescan_output -o 03_neosho
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/03_neosho_output/`. The files are:

1) 03_neosho_AccRte.txt
2) 03_neosho_fst.txt
3) 03_neosho.sel
4) 03_neosho.txt

##### 1b.4. Run BAYESCAN for Smallmouth Bass only; copy and paste the code below in the shell file generated in Step 1a above, which will generate output files:

##### Command line code for running BAYESCAN on Smallmouth Bass samples. UNCOMMENT this code in the shell script:
```{bash}
## analysis 1: all black bass samples
# bayescan 04_smallmouth -od ../../data/bayescan_output -o 04_smallmouth
```

Run: `sbatch bayescan.sh`

This code generates four oupt files here: `data/bayescan_output/04_smallmouth_output/`. The files are:

1) 04_smallmouth_AccRte.txt
2) 04_smallmouth_fst.txt
3) 04_smallmouth.sel
4) 04_smallmouth.txt

### ----------------------- END OF PHASE 2: OUTLIER ANALYSIS WITH BAYESCAN ----------------------- ###

## PHASE 3: OUTLIER ANALYSIS WITH PCADAPT
In this phase of the analysis, we are using the R package PCADAPT to conduct a genome scan for SNP loci with outlier Fst values to assess potential signatures of local directional selection and neutrality at various loci. We are conducting this analysis at four hierarchical levels, as listed in the description for Phase 1 of the analysis (see above). We are using input data for each hierarchical level of analysis as generated in Phase 1 of this analysis.

PCADAPT uses a multivariate framework (Principal Component Analysis; PCA) to account for population structure among populations and determine likely outlier SNPs driving differentiation between populations.



### ----------------------- END OF PHASE 3: OUTLIER ANALYSIS WITH PCADAPT ----------------------- ###

## PHASE 4: OUTLIER MAPPING
In this phase of the analysis, we are conducting a multivariate analysis on SNPs either inferred to be significant outliers or neutral in both the BAYESCAN and PCADAPT genome scan analyses. Specifically, we are mapping <i>a priori</i> populations (determined in Analysis 4 (population inference)) onto multivariate space using outlier and neutral SNPs as response variables in Discriminant Analysis of Principal Components



### ----------------------- END OF PHASE 4: OUTLIER MAPPING ----------------------- ###


