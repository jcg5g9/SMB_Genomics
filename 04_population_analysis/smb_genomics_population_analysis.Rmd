---
title: 'Analysis 4: Population inference'
author: "Joe Gunn"
date: "2022-08-29"
output: html_document
---

# Project: Population genomic analysis of Smallmouth Bass and Neosho Bass in the Central Interior Highlands
We investigated the extent of genomic divergence, local directional selection, and admixture between the Smallmouth Bass (<i>Micropterus dolomieu</i>) and the Neosho Bass (<i>M. velox</i>) in the Central Interior Highlands (CIH) ecoregion of central north America. Specifically, we used ddRADseq data to assessed the phylogenomic relationship between and within species, characterizing inter- and intraspecific diversity and SNPs potentially under local directional selection at the population level. Additionally, we inferred the relative timing of admxiture in Neosho Bass streams where there is known introgressive hybridization with Smallmouth Bass to understand the influence of natural, historic geographic factors on mixing (stream capture or transient flooding) vs. anthropogenic factors (i.e., non-native introductions through stocking), which is known to have occurred widely in these economically valuable species. We ultimately hoped to provide novel insights into the diversity of endemic, ecologically important and popular sport fish in the CIH.

## Specific Aim: Population Inference
In this analysis, we used the finerad.vcf data generated in Analysis 2 (SNP Filtering...) to assess fine-scale coancestry between Smallmouth Bass, and Neosho Bass in the CIH using haplotype inference (excluding Spotted Bass). Specifically, we estimated coancestry in 1) the full dataset, with all pure and admixed individuals, excluding the Spotted Bass X Smallmouth Bass hybrid (BFC10) inferred from population genomic analysis in Analysis 3, 2) the pure dataset, with only pure individuals of Smallmouth Bass and Neosho Bass, and 3) the admixed dataset, with only admixed individuals of Neosho Bass (no admixed Smallmouth Bass were detected).

## Phases of analysis:
### Phase 1: Data preparation 
### Phase 2: Coancestry analysis
### Phase 3: Plotting
### Phase 4: Population metadata generation

## Libraries needed for analysis
```{r libraries, echo = FALSE}
library(readxl)
library(tidyverse)
library(cowplot)
library(devtools)
library(XML)
library(RColorBrewer)

#Fine-structure R source code
source("code/source_code/FinestructureLibrary.R") 
```

## PHASE 1: DATA PREPARATION
In this phase of the analysis, we are reading in the fully filtered, non-thinned VCF dataset (`finerad.vcf`) and further filtering these data to create three additional datasets, including 1) all Smallmouth Bass and Neosho Bass samples; 2) pure samples only, and 3) admixed samples only.

All analyses conducted by calling commands in bash shell scripts were performed on the Lewis high-performance computing cluster at the University of Missouri <br>

<b>Programs needed</b>: <br><br>

FINERADSTRUCTURE v.0.3.2 (Malinsky, Trucchi, Lawson, & Falush, 2018) <br>

<b>Citation</b>:<br>

Malinsky, M., Trucchi, E., Lawson, D. J., & Falush, D. (2018). RADpainter and fineRADstructure: Population inference from RADseq data. Molecular Biology and Evolution, 35, 1284â€“1290. doi:10.1093/molbev/msy023

### STEP 1: Filter out Spotted Bass samples and the Spotted Bass X Neosho Bass hybrid. 
In this step, we are filtering out Spotted Bass and the single Spotted Bass X Neosho Bass hybrid (BFC10) from the full, non-thinned dataset, since we are interested in assessing coance

#### 1a: Generate a general bash shell script header for data filtering in VCFTools
In this step, we are generating another bash shell script to run individual sample filtering in VCFTools (see `02_filtering_processing_analysis/smb_genomics_filtering_processing_analysis.Rmd` for details on programs needed, etc.). Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each data filtering step and the associated lines of code in Rmd chunks. The shell script for running all VCFTools code is called "vcftools.sh".

##### 1a.1: Copy and paste the code below in a new shell script file: 

##### Generate VCFTools bash shell script: `code/shell_scripts/vcftools.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J vcftools  # give the job a custom name
#SBATCH -o filter_spotted.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

# Load VCFtools module

# module load rss/rss-2020
# module load vcftools/vcftools-v0.1.14
```

Make sure to copy the `popgen.vcf` dataset generated in Analysis 2 into a new sub-directory of the `data/` folder in this directory: `data/processed_vcf`

##### Important Note: the generated file will have an additional extension (.recode), which is not necessary for downstream analyses. Every time a new VCF file was filtered, we manually removed this piece of the extension by copying the file to a new name (see below) and deleting the .recode.vcf file.

#### 1b: Filter the full, non-thinned VCF to remove Spotted Bass hybrid (BFC10) and Spotted Bass individuals.

##### 1b.1. Read in the .Rda file saved in `smb_genomics_admixture_phylogenomics_analysis.Rmd`; run the Rmd chunk below:

##### Generate list of Spotted Bass hybrid: `data/filtering_data/bfc10.txt` 
```{r}
# Load in the .Rda file generated in the admixture analysis
load("../03_admixture_phylogenomics_analysis/data/filtering_data/bcf10.Rda")

BFC10 <- as.data.frame(BFC10)

# Save the list of bad samples as a .txt file without column names
write_tsv(BFC10, 
          file = "data/filtering_data/bfc10.txt", 
          col_names = FALSE)

# Save the list of bad samples as a .Rda file without column names
save(BFC10, file = "data/filtering_data/bcf10.Rda")
```

#### 1b.2. Copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate a filtered VCF file without BFC10:

##### Command line code for filtering. UNCOMMENT this code in the shell script:
```{bash}
## filter 01: omit Spotted Bass X Neosho Bass hybrid (BFC10) 
#vcftools --vcf ../../data/processed_vcf/finerad.vcf --remove ../../data/filtering_data/bfc10.txt --recode --recode-INFO-all --out ../../data/processed_vcf/01_finerad_spb_hybrid
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_bed/all_samples/01_finerad_spb_hybrid.vcf`. This file should be used as input in analysis in the next vcftools filter.

<b>Filtering results</b>: <br><br>
<b>Samples omitted </b> = 1 <br>
<b>Samples retained </b> = 91 <br>
<b>SNPs retained </b> = 50,828 <br>

##### 1b.3. Generate a list of only Spotted Bass to be used for filtering in subsequent steps:

##### Read in metadata and generate Spotted Bass list: `data/filtering_data/spotted_bass.txt`
```{r}
# Load metadata
load("../02_filtering_processing_analysis/data/metadata.Rda")

# Filter out spotted bass only from metadata
spotted_bass <- metadata %>%
  filter(species == "Spotted Bass")

# Select the first column and convert to data frame
spotted_bass <- data.frame(spotted_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(spotted_bass, 
          file = "data/filtering_data/spotted_bass.txt", 
          col_names = FALSE)
```

##### 1b.2. Copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate a filtered VCF file without Spotted Bass:

##### Command line code for filtering. UNCOMMENT this code in the shell script:
```{bash}
## filter 02: omit Spotted Bass
#vcftools --vcf ../../data/processed_vcf/01_finerad_spb_hybrid.vcf --remove ../../data/filtering_data/spotted_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/02_finerad_spb
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_bed/all_samples/02_finerad_spb.vcf`. This file should be used in the next vcftools filter.

<b>Filtering results</b>: <br><br>
<b>Samples omitted </b> = 4 <br>
<b>Samples retained </b> = 87 <br>
<b>SNPs retained </b> = 50,828 <br>

### STEP 2: Generate two datasets, one for only pure samples and one for only admixed samples
In this step, we are further filtering the finerad dataset to create datasets for 1) only pure samples and 2) only admixed samples. We are interested in understanding coancestry among individuals within these groups so that we may infer population designations based on haplotype similarity. Individuals that are closely related and likely within a single population form blocks of coancestry in a FINERADSTRUCTURE output heat map (see figures generated in PHASE 3 below).

#### 2b: Filter the full, non-thinned VCF to generate a dataset with all pure individuals.

##### 2b.1. Read in the .Rda file for admixed individuals saved in `smb_genomics_admixture_phylogenomics_analysis.Rmd`; run the Rmd chunk below:

##### Generate list of admixed individuals (to be removed from the dataset): `data/filtering_data/admixed_individuals.txt` 
```{r}
# Load in the .Rda file generated in the admixture analysis
load("../03_admixture_phylogenomics_analysis/data/filtering_data/admixed_individuals.Rda")

# Convert to dataframe
admixed_individuals <- as.data.frame(admixed_individuals)

# Save the list of bad samples as a .txt file without column names
write_tsv(admixed_individuals, 
          file = "data/filtering_data/admixed_individuals.txt", 
          col_names = FALSE)

# Save the list of bad samples as a .Rda file without column names
save(admixed_individuals, file = "data/filtering_data/admixed_individuals.Rda")
```

##### 2b.2. Copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate a filtered VCF file with only pure individuals:

##### Command line code for filtering. UNCOMMENT this code in the shell script:
```{bash}
## filter A_03: Generate finerad dataset with only pure individuals
#vcftools --vcf ../../data/processed_vcf/02_finerad_spb.vcf --remove ../../data/filtering_data/admixed_individuals.txt --recode --recode-INFO-all --out ../../data/processed_vcf/A_03_finerad_pure
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_bed/all_samples/03_finerad_pure.vcf`. This file should be used for downstream analyses in FINERADSTRUCTURE.

<b>Filtering results</b>: <br><br>
<b>Samples omitted </b> = 40 <br>
<b>Samples retained </b> = 47 <br>
<b>SNPs retained </b> = 50,828 <br>

#### 2c: Filter the full, non-thinned VCF to generate a dataset with all admixed individuals.

##### 2c.1. Read in the .Rda file for pure individuals saved in `smb_genomics_admixture_phylogenomics_analysis.Rmd`; run the Rmd chunk below:

##### Generate list of pure individuals (to be removed from the dataset): `data/filtering_data/pure_individuals.txt` 
```{r}
# Load in the .Rda file generated in the admixture analysis
load("../03_admixture_phylogenomics_analysis/data/filtering_data/pure_individuals.Rda")

# Convert to dataframe
pure_individuals <- as.data.frame(pure_individuals)

# Save the list of bad samples as a .txt file without column names
write_tsv(pure_individuals, 
          file = "data/filtering_data/pure_individuals.txt", 
          col_names = FALSE)

# Save the list of bad samples as a .Rda file without column names
save(pure_individuals, file = "data/filtering_data/pure_individuals.Rda")
```

##### 2c.2. Copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate a filtered VCF file with only pure individuals:

##### Command line code for filtering. UNCOMMENT this code in the shell script:
```{bash}
## filter B_03: Generate finerad dataset with only pure individuals
#vcftools --vcf ../../data/processed_vcf/02_finerad_spb.vcf --remove ../../data/filtering_data/pure_individuals.txt --recode --recode-INFO-all --out ../../data/processed_vcf/B_03_finerad_admixed
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_bed/all_samples/03_finerad_pure.vcf`. This file should be used for downstream analyses in FINERADSTRUCTURE.

<b>Filtering results</b>: <br><br>
<b>Samples omitted </b> = 47 <br>
<b>Samples retained </b> = 40 <br>
<b>SNPs retained </b> = 50,828 <br>

### ----------------------- END OF PHASE 1: DATA PREPARATION ----------------------- ###

## PHASE 2: COANCESTRY ANALYSIS
and generating haplotype mapping files (hapmap) files to be used for coancestry analysis with the software program FINERADSTRUCTURE

### STEP 1: Generate a general bash shell script header for all FINERADSTRUCTURE commands
In this step, we are generating a universal bash shell script to run all input file conversions and subsequent coancestry analyses in FINERADSTRUCTURE. Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion or analysis and the associated lines of code in Rmd chunks. The shell script for running all FINERADSTRUCTURE code is called "finerad.sh".

##### 1a: Generate the header for a general bash shell script to run FINERADSTRUCTURE:

##### Generate FINERADSTRUCTURE bash shell script: `code/shell_scripts/finerad.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J finerad  # give the job a custom name
#SBATCH -o finerad.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

# Commands here run only on the first core

# module load rss/rss-2020
# module load fineradstructure/fineradstructure-0.3.2
```

#### 1b: Generate painted hap map input files for coancestry analysis
In this step, we are converting VCF files to hap map files, which are input for the FINERADSTRUCTURE program, for 1) all Smallmouth Bass and Neosho Bass samples, 2) all pure samples only, and 3) all admixed samples.

##### 1b.1 Copy and paste the code below in the shell file generated in Step 1a above, which will generate hap map files for all three groups of interest (all individuals excluding Spotted Bass, pure individuals, and admixed individuals):

##### Generate hap map files. UNCOMMENT this code in the shell script:
```{bash}
## file conversion 01: convert VCF into haplotype chunks for all Smallmouth Bass and Neosho Bass
#RADpainter hapsFromVCF ../../data/processed_vcf/finerad.vcf > ../../datal/hap_maps/01_smb_neosho.txt
#RADpainter paint ../../data/hap_maps/01_smb_neosho.txt

## file conversion 02: convert VCF into haplotype chunks for all pure samples
#RADpainter hapsFromVCF ../../data/processed_vcf/A_03_finerad_pure.vcf > ../../datal/hap_maps/02_pure.txt
#RADpainter paint ../../data/hap_maps/02_pure.txt

## file conversion 03: convert VCF into haplotype chunks for all admixed samples
#RADpainter hapsFromVCF ../../data/processed_vcf/B_03_finerad_admixed.vcf > ../../datal/hap_maps/03_admixed.txt
#RADpainter paint ../../data/hap_maps/03_admixed.txt
```

This code generates 6 files: <br>
  1) `data/hap_maps/01_smb_neosho.txt`: this is a haplotype map file for Smallmouth Bass and Neosho Bass
  2) `data/hap_maps/02_pure.txt`: this is a haplotype map file for pure individuals
  3) `data/hap_maps/03_admixed.txt`: this is a haplotype map file for admixed individuals
  4) `data/hap_maps/01_smb_neosho_chunks.out`: this is a haplotype chunks file for Smallmouth Bass and Neosho Bass
  5) `data/hap_maps/02_pure_chunks.out`: this is a haplotype chunks file for pure individuals
  6) `data/hap_maps/01_admixed_chunks.out`: this is a haplotype chunks file for admixed individuals

Each of the "chunks" files is then used as input in the FINERADSTRUCTURE coancestry matrix algorithm.

#### 1c: Calculate coancestry matrices and build phylogenetic trees based on haplotype inference from hap map files
<b>We use the following flags in the code</b>: <br>
    -x: Number of burn-in steps (100,000)
    -y: Number of MCMC iterations (100,000)
    -z: Number of thinning steps (1,000)
    -T: Initialization procedure (don't set to anything, leave blank)
    -x: Number of tries for making best population state (10,000)
    
##### Copy and paste the code below in the shell file generated in Step 1a above, which will generate coancestry matrices and accompanying phylogenetic tree files for all three groups of interest (all individuals excluding Spotted Bass, pure individuals, and admixed individuals):

##### Calculate coancestry and generate phylogenies: 
```{bash}
## Coancestry 01: Smallmouth Bass and Neosho Bass
#finestructure -x 100000 -y 100000 -z 1000 ../../hap_maps/01_smb_neosho_chunks.out ../../mcmc_files/01_smb_neosho_chunks.mcmc.xml
#finestructure -m T -x 10000 ../../hap_maps/01_smb_neosho_chunks.out ../../mcmc_files/01_smb_neosho_chunks.mcmc.xml 01_smb_neosho_chunks.mcmcTree.xml

## Coancestry 02: Pure samples
#finestructure -x 100000 -y 100000 -z 1000 ../../hap_maps/02_pure_chunks.out ../../mcmc_files/02_pure_chunks.mcmc.xml
#finestructure -m T -x 10000 ../../hap_maps/02_pure_chunks.out ../../mcmc_files/02_pure_chunks.mcmc.xml 02_pure_chunks.mcmcTree.xml

## Coancestry 03:  Smallmouth Bass and Neosho Bass
#finestructure -x 100000 -y 100000 -z 1000 ../../hap_maps/03_admixed_chunks.out ../../mcmc_files/03_admixed_chunks.mcmc.xml
#finestructure -m T -x 10000 ../../hap_maps/03_admixed_chunks.out ../../mcmc_files/03_admixed_chunks.mcmc.xml 03_admixed_chunks.mcmcTree.xml
```

This code generates 6 files: <br>
  1) `data/mcmc_files/01_smb_neosho_chunks.mcmc.xml`: this is a coancestry matrix file Smallmouth Bass and Neosho Bass
  2) `data/mcmc_files/02_pure_chunks.mcmc.xml`: this is a coancestry matrix file file for pure individuals
  3) `data/mcmc_files/03_admixed_chunks.mcmc.xml`: this is a coancestry matrix file file for admixed individuals
  4) `data/tree_files/01_smb_neosho_chunks.mcmcTree.xml`: this is a phylogenetic tree file for Smallmouth Bass and Neosho Bass
  5) `data/tree_files/02_pure_chunks.mcmcTree.xml`: this is a phylogenetic tree file for pure individuals
  6) `data/tree_files/03_admixed_chunks.mcmcTree.xml`: this is a phylogenetic tree file for admixed individuals

Each of the output files were used to generate publication figures in the PHASE 3 (below).

### ----------------------- END OF PHASE 2: COANCESTRY ANALYSIS ----------------------- ###

## PHASE 3: PLOTTING
In this phase, we are using previously documented source code (`code/source_code/FinestructureLibrary.R`) to build publication-ready figures of coancestry matrices and corresponding phylogenies for each group of interest (Smallmouth Bass and Neosho Bass, pure samples, and admixed samples). 

### STEP 1: Read in hap map 'chunk' files, mcmc files, and tree files generated in Phase 2, Step 1b.1 above.

#### 1a: Read in files for Smallmouth Bass and Neosho Bass; run the Rmd chunk below:

###### Read in data:
```{r}
# Read in hapmap file
smb_neosho_hapmap <- "data/hap_maps/01_smb_neosho_chunks.out"

# Read in mcmc file
smb_neosho_mcmcfile <- "data/mcmc_files/01_smb_neosho_chunks.mcmc.xml"

# Read in tree file
smb_neosho_treefile <- "data/tree_files/01_smb_neosho_chunks.mcmcTree.xml"

# Save files as Rda files for downstream analyses and plotting
save(smb_neosho_hapmap, file = "data/hap_maps/smb_neosho_hapmap.Rda")
save(smb_neosho_mcmcfile, file = "data/mcmc_files/smb_neosho_mcmcfile.Rda")
save(smb_neosho_treefile, file = "data/tree_files/smb_neosho_treefile.Rda")
```

#### 1b: Read in files for pure samples; run the Rmd chunk below:

###### Read in data:
```{r}
# Read in hapmap file
pure_hapmap <- "data/hap_maps/02_pure_chunks.out"

# Read in mcmc file
pure_mcmcfile <- "data/mcmc_files/02_pure_chunks.mcmc.xml"

# Read in tree file
pure_treefile <- "data/tree_files/02_pure_chunks.mcmcTree.xml"

# Save files as Rda files for downstream analyses and plotting
save(smb_neosho_hapmap, file = "data/hap_maps/pure_hapmap.Rda")
save(pure_mcmcfile, file = "data/mcmc_files/pure_mcmcfile.Rda")
save(pure_treefile, file = "data/tree_files/pure_treefile.Rda")
```

#### 1c: Read in files for admixed samples; run the Rmd chunk below:

###### Read in data:
```{r}
# Read in hapmap file
admixed_hapmap <- "data/hap_maps/03_admixed_chunks.out"

# Read in mcmc file
admixed_mcmcfile <- "data/mcmc_files/03_admixed_chunks.mcmc.xml"

# Read in tree file
admixed_treefile <- "data/tree_files/03_admixed_chunks.mcmcTree.xml"

# Save files as Rda files for downstream analyses and plotting
save(admixed_hapmap, file = "data/hap_maps/admixed_hapmap.Rda")
save(admixed_mcmcfile, file = "data/mcmc_files/admixed_mcmcfile.Rda")
save(admixed_treefile, file = "data/tree_files/admixed_treefile.Rda")
```

### STEP 2: Generate input files for plotting.
In this step, we are using previously published source code by the developers of FINERADSTRUCTURE to get input files to plot coancestry matrices and phylogenetic trees. All code below is annotated to the best of our knowledge and corresponds directly with the published source code (FinestructureLibrary.R). Please note: given that this is published and peer-reviewed software, we do not attempt to explain annotations or code which we did not write; for this reason, some steps of the code, particularly in the plotting chunks, are obscure. We will do our best to continue updating this code to increase reproducibility and transparency of our analyses.

#### 2a: Set path name for depositing completed fineRADstructure figures; run the Rmd chunk below:

##### Set figure path: `figures/coancestry_figures`
```{r}
# Set plotsFolder path name
plotsFolder <- "figures/coancestry_figures"

# Set general name for analysis, which will be appended to each figure
analysisName <- "coancestry" 

# Set parameters for individuals and populations
maxIndv <- 10000
maxPop <-10000

# Save parameters
save(maxIndv, file = "data/maxIndv.Rda")
save(maxPop, file = "data/maxPop.Rda")
```

#### 2b: Set color palette to use for all coancestry heat map figures; run the Rmd chunk below:

##### Set color palette for figures
```{r color palette, echo=FALSE}
my_palette <- colorRampPalette(c("white", "navyblue","deeppink2","black"))(n = 299)
```

#### 2b. Extract XML data from mcmc and tree files

##### 2b.1 Extract XML data from mcmc and tree files for Smallmouth Bass and Neosho Bass; run the Rmd code below:

##### Extract data for Smallmouth Bass and Neosho Bass: 
```{r}
# Load SMB Neosho files
load("data/hap_maps/smb_neosho_hapmap.Rda")
load("data/mcmc_files/smb_neosho_mcmcfile.Rda")
load("data/tree_files/smb_neosho_treefile.Rda")

# Generate matrix of data
smb_neosho_dataraw <- as.matrix(read.table(smb_neosho_hapmap, 
                                           row.names = 1, 
                                           header = T, 
                                           skip = 1))

# Read in mcmc file
smb_neosho_mcmcxml <- xmlTreeParse(smb_neosho_mcmcfile)
smb_neosho_mcmcdata <- as.data.frame.myres(smb_neosho_mcmcxml)

# Read in tree file
smb_neosho_treexml <- xmlTreeParse(smb_neosho_treefile)
smb_neosho_ttree <- extractTree(smb_neosho_treexml)

# Save tree files
save(smb_neosho_treexml, file = "data/tree_files/smb_neosho_treexml.Rda")
save(smb_neosho_ttree, file = "data/tree_files/smb_neosho_ttree.Rda")
```

##### 2b.2 Extract XML data from mcmc and tree files for Smallmouth Bass and Neosho Bass; run the Rmd code below:

##### Extract data for pure samples: 
```{r}
# Save files as Rda files for downstream analyses and plotting
load("data/hap_maps/pure_hapmap.Rda")
load("data/mcmc_files/pure_mcmcfile.Rda")
load("data/tree_files/pure_treefile.Rda")

# Generate matrix of data
pure_dataraw <- as.matrix(read.table(pure_hapmap, 
                                     row.names = 1, 
                                     header = T, 
                                     skip = 1))

# Read in mcmc file and convert to data frame
pure_mcmcxml <- xmlTreeParse(pure_mcmcfile)
pure_mcmcdata <- as.data.frame.myres(pure_mcmcxml)

# Read in tree file
pure_treexml <- xmlTreeParse(pure_treefile)
pure_ttree <- extractTree(pure_treexml)

# Save tree files
save(pure_treexml, file = "data/tree_files/pure_treexml.Rda")
save(pure_ttree, file = "data/tree_files/pure_ttree.Rda")
```

##### 2b.3 Extract XML data from mcmc and tree files for admixed samples; run the Rmd code below:

##### Extract data for admixed samples: 
```{r}
# Save files as Rda files for downstream analyses and plotting
load("data/hap_maps/admixed_hapmap.Rda")
load("data/mcmc_files/admixed_mcmcfile.Rda")
load("data/tree_files/admixed_treefile.Rda")

# Generate matrix of data
admixed_dataraw <- as.matrix(read.table(admixed_hapmap, 
                                        row.names = 1, 
                                        header = T, 
                                        skip = 1)) 

# Read in mcmc file and convert to data frame
admixed_mcmcxml <- xmlTreeParse(admixed_mcmcfile)
admixed_mcmcdata <- as.data.frame.myres(admixed_mcmcxml)

# Read in tree file
admixed_treexml <- xmlTreeParse(admixed_treefile)
admixed_ttree <- extractTree(admixed_treexml)

# Save tree files
save(admixed_treexml, file = "data/tree_files/admixed_treexml.Rda")
save(admixed_ttree, file = "data/tree_files/admixed_ttree.Rda")
```

#### 2c. Generate input files for coancestry plots and dendrograms (phylogenies)

##### 2c.1. Generate input files for coancestry plots and dendrograms for Smallmouth Bass and Neosho Bass; run the Rmd code below:

##### Generate input files for Smallmouth Bass and Neosho Bass:
```{r}
# Load tree files
load("data/tree_files/smb_neosho_treexml.Rda")
load("data/tree_files/smb_neosho_ttree.Rda")

# Reduce the amount of significant digits printed in the posterior assignment probabilities:
smb_neosho_ttree$node.label[smb_neosho_ttree$node.label!=""] <- format(as.numeric(smb_neosho_ttree$node.label[smb_neosho_ttree$node.label!=""]), digits=2)

# convert to dendrogram format
smb_neosho_tdend <- myapetodend(smb_neosho_ttree, factor=1)

# map state as a finestructure clustering
smb_neosho_mapstate <- extractValue(smb_neosho_treexml,"Pop") 

# .. and as a list of individuals in populations
smb_neosho_mapstatelist <- popAsList(smb_neosho_mapstate) 

# population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
smb_neosho_popnames <- lapply(smb_neosho_mapstatelist, NameSummary)

# Get a nicer summary of the populations
smb_neosho_popnamesplot <-lapply(smb_neosho_mapstatelist, NameMoreSummary)

# Clean up pop names
names(smb_neosho_popnames) <- smb_neosho_popnamesplot 
names(smb_neosho_popnamesplot) <- smb_neosho_popnamesplot 

# use NameSummary to make popdend
smb_neosho_popdend <- makemydend(smb_neosho_tdend, smb_neosho_mapstatelist) 

 # needed for obscure dendrogram reasons
smb_neosho_popdend <- fixMidpointMembers(smb_neosho_popdend)

# use NameMoreSummary to make popdend
smb_neosho_popdendclear <- makemydend(smb_neosho_tdend, smb_neosho_mapstatelist, "NameMoreSummary") 

# needed for obscure dendrogram reasons
smb_neosho_popdendclear <- fixMidpointMembers(smb_neosho_popdendclear) 

# Save tree files for downstream plotting
save(smb_neosho_tdend, file = "data/tree_files/smb_neosho_tdend.Rda")
save(smb_neosho_dataraw, file = "data/tree_files/smb_neosho_dataraw.Rda")
save(smb_neosho_mapstatelist, file = "data/tree_files/smb_neosho_mapstatelist.Rda")
save(smb_neosho_popdend, file = "data/tree_files/smb_neosho_popdend.Rda")
```

##### 2c.2. Generate input files for coancestry plots and dendrograms for pure samples; run the Rmd code below:

##### Generate input files for pure samples:
```{r}
# Load tree files
load("data/tree_files/pure_treexml.Rda")
load("data/tree_files/pure_ttree.Rda")

# Reduce the amount of significant digits printed in the posteror assignment probabilities:
pure_ttree$node.label[pure_ttree$node.label!=""] <- format(as.numeric(pure_ttree$node.label[pure_ttree$node.label!=""]), digits=2)

# convert to dendrogram format
pure_tdend <- myapetodend(pure_ttree, factor=1)

# map state as a finestructure clustering
pure_mapstate <- extractValue(pure_treexml,"Pop")

# .. and as a list of individuals in populations
pure_mapstatelist <- popAsList(pure_mapstate) 

# population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
pure_popnames <- lapply(pure_mapstatelist, NameSummary)

# Get a nicer summary of the populations
pure_popnamesplot <-lapply(pure_mapstatelist, NameMoreSummary) 

# Clean up pop names
names(pure_popnames) <- pure_popnamesplot 
names(pure_popnamesplot) <- pure_popnamesplot 

# use NameSummary to make popdend
pure_popdend <- makemydend(pure_tdend, pure_mapstatelist) 

# needed for obscure dendrogram reasons
pure_popdend <- fixMidpointMembers(pure_popdend)

# use NameMoreSummary to make popdend
pure_popdendclear <- makemydend(pure_tdend, pure_mapstatelist, "NameMoreSummary") 

# needed for obscure dendrogram reasons
pure_popdendclear <- fixMidpointMembers(pure_popdendclear) 

# Save tree files for downstream plotting
save(pure_tdend, file = "data/tree_files/pure_tdend.Rda")
save(pure_dataraw, file = "data/tree_files/pure_dataraw.Rda")
save(pure_mapstatelist, file = "data/tree_files/pure_mapstatelist.Rda")
save(pure_popdend, file = "data/tree_files/pure_popdend.Rda")
```

##### 2c.3. Generate input files for coancestry plots and dendrograms for admixed samples; run the Rmd code below:

##### Generate input files for admixed samples:
```{r}
# Save tree files
load("data/tree_files/admixed_treexml.Rda")
load("data/tree_files/admixed_ttree.Rda")

# Reduce the amount of significant digits printed in the posteror assignment probabilities:
admixed_ttree$node.label[admixed_ttree$node.label!=""] <- format(as.numeric(admixed_ttree$node.label[admixed_ttree$node.label!=""]), digits=2)

# convert to dendrogram format
admixed_tdend <- myapetodend(admixed_ttree, factor=1)

# map state as a finestructure clustering
admixed_mapstate <- extractValue(admixed_treexml,"Pop") 

# .. and as a list of individuals in populations
admixed_mapstatelist <- popAsList(admixed_mapstate) 

# population names IN A REVERSIBLE FORMAT 
admixed_popnames <- lapply(admixed_mapstatelist, NameSummary) 

# Get a nicer summary of the populations
admixed_popnamesplot <-lapply(admixed_mapstatelist, NameMoreSummary) 

# Clean up pop names
names(admixed_popnames) <- admixed_popnamesplot 
names(admixed_popnamesplot) <- admixed_popnamesplot 

# use NameSummary to make popdend
admixed_popdend <- makemydend(admixed_tdend, admixed_mapstatelist) 

# needed for obscure dendrogram reasons
admixed_popdend <- fixMidpointMembers(admixed_popdend)

# use NameMoreSummary to make popdend
admixed_popdendclear <- makemydend(admixed_tdend, admixed_mapstatelist, "NameMoreSummary") 

# needed for obscure dendrogram reasons
admixed_popdendclear <- fixMidpointMembers(admixed_popdendclear) 

# Save tree files for downstream plotting
save(admixed_tdend, file = "data/tree_files/admixed_tdend.Rda")
save(admixed_dataraw, file = "data/tree_files/admixed_dataraw.Rda")
save(admixed_mapstatelist, file = "data/tree_files/admixed_mapstatelist.Rda")
save(admixed_popdend, file = "data/tree_files/admixed_popdend.Rda")
```

### STEP 3: Plotting
In this step, we are using the input files generated in Step 2 above to generate coancestry heat map plots along with their corresponding phylogenetic trees (dendrograms as described above). All code below is annotated to the best of our knowledge and corresponds directly with the published source code (FinestructureLibrary.R).

#### 3a: Generate plots for the three groups of interest (Smallmouth Bass and Neosho Bass, pure samples, and admixed samples).

##### 3a.1. Generate plots for Smallmouth Bass and Neosho Bass; run the Rmd code below:
The code below generates three heat map plots that may be used for publication figures: 1) coancestry in the same order as given by the input data; 2) coancestry ordered by population averages, and 3) coancestry ordered by population averages and with better looking labels. We have chosen to use Plot 3 from the list for publication.

##### Generate plot for Smallmouth Bass and Neosho Bass:
```{r}
# Load plotting parameters
load("data/maxIndv.Rda")
load("data/maxPop.Rda")

# Load files
load("data/tree_files/smb_neosho_tdend.Rda")
load("data/tree_files/smb_neosho_dataraw.Rda")
load("data/tree_files/smb_neosho_mapstatelist.Rda")
load("data/tree_files/smb_neosho_popdend.Rda")

# Put labels in order corresponding to the tree
smb_neosho_fullorder <- labels(smb_neosho_tdend)

# Reorder the data matrix
smb_neosho_datamatrix <- smb_neosho_dataraw[smb_neosho_fullorder, smb_neosho_fullorder] 

# cap the heatmap
smb_neosho_tmpmat <- smb_neosho_dataraw
smb_neosho_tmpmat[smb_neosho_tmpmat > maxIndv] <- maxIndv  

# Generate plot 1
pdf("figures/coancestry_figures/01_smb_neosho.pdf", height = 25, width = 25)

plotFinestructure(smb_neosho_tmpmat, 
                  dimnames(smb_neosho_tmpmat)[[1]], 
                  dend = smb_neosho_tdend,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))
dev.off()


## Plot 2: labels: population and coancestry averages in sensible order
smb_neosho_popmeanmatrix <- getPopMeanMatrix(smb_neosho_datamatrix, smb_neosho_mapstatelist)

# cap the heatmap
smb_neosho_tmpmat <- smb_neosho_popmeanmatrix
smb_neosho_tmpmat[smb_neosho_tmpmat > maxPop] <- maxPop 

# Generate plot 2
pdf("figures/coancestry_figures/01_smb_neosho_labels.pdf", height = 20, width = 20)

plotFinestructure(smb_neosho_tmpmat, 
                  dimnames(smb_neosho_tmpmat)[[1]], 
                  dend = smb_neosho_tdend, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))
dev.off()

## Plot 3: Best: more informative and better looking labels

# Format labels
smb_neosho_mappopcorrectorder <- NameExpand(labels(smb_neosho_popdend))
smb_neosho_mappopsizes <- sapply(smb_neosho_mappopcorrectorder,length)
smb_neosho_labellocs <- PopCenters(smb_neosho_mappopsizes)

# Set parameters
xcrt = 0
ycrt = 45

# Generate plot 3
pdf("figures/coancestry_figures/01_smb_neosho_best.pdf", height = 25, width = 25)
 
plotFinestructure(smb_neosho_tmpmat, 
                  dimnames(smb_neosho_tmpmat)[[1]], 
                  labelsx=labels(smb_neosho_popdendclear), 
                  labelsatx = smb_neosho_labellocs, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = smb_neosho_tdend, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()
```

We used Plot 3 as the basis for Supplementary Figure 5 in our in our published paper. We imported these maps into PowerPoint to add cleaner lables and any insets for easier interpretation.

##### 3a.2. Generate plots for pure samples; run the Rmd code below:
The code below generates three heat map plots that may be used for publication figures: 1) coancestry in the same order as given by the input data; 2) coancestry ordered by population averages, and 3) coancestry ordered by population averages and with better looking labels. We have chosen to use Plot 3 from the list for publication.

##### Generate plot for pure samples:
```{r}
# Load plotting parameters
load("data/maxIndv.Rda")
load("data/maxPop.Rda")

# Load files
load("data/tree_files/pure_tdend.Rda")
load("data/tree_files/pure_dataraw.Rda")
load("data/tree_files/pure_mapstatelist.Rda")
load("data/tree_files/pure_popdend.Rda")

# Put labels in order corresponding to the tree
pure_fullorder <- labels(pure_tdend)

# Reorder the data matrix
pure_datamatrix <- pure_dataraw[pure_fullorder, pure_fullorder] 

# cap the heatmap
pure_tmpmat <- pure_dataraw
pure_tmpmat[pure_tmpmat > maxIndv] <- maxIndv  

# Generate plot 1
pdf("figures/coancestry_figures/02_pure_.pdf", height = 25, width = 25)

plotFinestructure(pure_tmpmat, 
                  dimnames(pure_tmpmat)[[1]], 
                  dend = pure_tdend,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))
dev.off()


## Plot 2: labels: population and coancestry averages in sensible order
pure_popmeanmatrix <- getPopMeanMatrix(pure_datamatrix, pure_mapstatelist)

# cap the heatmap
pure_tmpmat <- pure_popmeanmatrix
pure_tmpmat[pure_tmpmat > maxPop] <- maxPop 

# Generate plot 2
pdf("figures/coancestry_figures/02_pure_labels.pdf", height = 20, width = 20)

plotFinestructure(pure_tmpmat, 
                  dimnames(pure_tmpmat)[[1]], 
                  dend = pure_tdend, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))
dev.off()

## Plot 3: Best: more informative and better looking labels

# Format labels
pure_mappopcorrectorder <- NameExpand(labels(pure_popdend))
pure_mappopsizes <- sapply(pure_mappopcorrectorder,length)
pure_labellocs <- PopCenters(pure_mappopsizes)

# Set parmaters
xcrt  =0
ycrt = 45
 
# Generate plot 3
pdf("figures/coancestry_figures/02_pure_best.pdf", height = 25, width = 25)
 
plotFinestructure(pure_tmpmat, 
                  dimnames(pure_tmpmat)[[1]], 
                  labelsx=labels(pure_popdendclear), 
                  labelsatx = pure_labellocs, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = pure_tdend, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))
dev.off()
```

We used Plot 3 as the basis for Figure 2a in our in our published paper. We imported these maps into PowerPoint to add cleaner lables and any insets for easier interpretation.

##### 3a.3. Generate plots for Smallmouth Bass and Neosho Bass; run the Rmd code below:
The code below generates three heat map plots that may be used for publication figures: 1) coancestry in the same order as given by the input data; 2) coancestry ordered by population averages, and 3) coancestry ordered by population averages and with better looking labels. We have chosen to use Plot 3 from the list for publication.

##### Generate plot for Smallmouth Bass and Neosho Bass:
```{r}
# Load plotting parameters
load("data/maxIndv.Rda")
load("data/maxPop.Rda")

# Load files
load("data/tree_files/admixed_tdend.Rda")
load("data/tree_files/admixed_dataraw.Rda")
load("data/tree_files/admixed_mapstatelist.Rda")
load("data/tree_files/admixed_popdend.Rda")

# Put labels in order corresponding to the tree
admixed_fullorder <- labels(admixed_tdend)

# Reorder the data matrix
admixed_datamatrix <- admixed_dataraw[admixed_fullorder, admixed_fullorder] 

# cap the heatmap
admixed_tmpmat <- admixed_dataraw
admixed_tmpmat[admixed_tmpmat > maxIndv] <- maxIndv  

# Generate plot 1
pdf("figures/coancestry_figures/03_admixed_coancestry.pdf", height = 25, width = 25)

plotFinestructure(admixed_tmpmat, 
                  dimnames(admixed_tmpmat)[[1]], 
                  dend = admixed_tdend,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))
dev.off()


## Plot 2: labels: population and coancestry averages in sensible order
admixed_popmeanmatrix <- getPopMeanMatrix(admixed_datamatrix, admixed_mapstatelist)

# cap the heatmap
admixed_tmpmat <- admixed_popmeanmatrix
admixed_tmpmat[admixed_tmpmat > maxPop] <- maxPop 

# Generate plot 2
pdf("figures/coancestry_figures/03_admixed_coancestry_labels.pdf", height = 20, width = 20)

plotFinestructure(admixed_tmpmat, 
                  dimnames(admixed_tmpmat)[[1]], 
                  dend = admixed_tdend, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))
dev.off()

## Plot 3: Best: more informative and better looking labels

# Format labels
admixed_mappopcorrectorder <- NameExpand(labels(admixed_popdend))
admixed_mappopsizes <- sapply(admixed_mappopcorrectorder,length)
admixed_labellocs <- PopCenters(admixed_mappopsizes)

# Set parameters
xcrt = 0
ycrt = 45

# Generate plot 3
pdf("figures/coancestry_figures/03_admixed_best.pdf", height = 25, width = 25)
 
plotFinestructure(admixed_tmpmat, 
                  dimnames(admixed_tmpmat)[[1]], 
                  labelsx=labels(admixed_popdendclear), 
                  labelsatx = admixed_labellocs, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = admixed_tdend, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))
dev.off()
```

We used Plot 3 as the basis for Figure 2b in our in our published paper. We imported these maps into PowerPoint to add cleaner lables and any insets for easier interpretation.

### ----------------------- END OF PHASE 3: PLOTTING ----------------------- ###

## PHASE 4: POPULATION METADATA GENERATION
In this phase of the analysis, we are using our inferences of populations from FINERADSTRUCTURE on the pure and admixed datasets to assign each individual to its respective population. We generate a new metadata file with sample_id and population to use in downstream analyses

### STEP 1: Generate new metadata file in Excel.
In this step, we use Microsoft Excel to create a new metadata set for populations, with column one being sample_id and column 2 being population as inferred in FINERADSTRUCTURE.

#### 1a: Generate new metadata file, input data, and save as `data/metadata/metadata_populations.xlsx`

##### 1a.1. Read in metadata, manipulate, and safe as a .Rda file for use in subsequent analyses; run the Rmd chunk below:

##### Read in and manipulate data:
```{r}
# Generate a population dataset including Spotted Bass (for future outlier Fst analysis)

# Read in pre-made Excel file
metadata_populations_spb <- read_excel("data/metadata/metadata_populations_spb.xlsx")

# Convert to dataframe
metadata_populations_spb <- as.data.frame(metadata_populations_spb)

# Mutate sample_id and population columns to factors
metadata_populations_spb <- metadata_populations_spb %>% 
  mutate(sample_id = factor(sample_id), 
         population = factor(population))

# Save the new population metadata file
save(metadata_populations_spb, file = "data/metadata/metadata_populations_spb.Rda")

## Generate a population metadata set excluding Spotted Bass

# Read in pre-made Excel file
metadata_populations <- read_excel("data/metadata/metadata_populations.xlsx")

# Convert to dataframe
metadata_populations <- as.data.frame(metadata_populations)

# Mutate sample_id and population columns to factors
metadata_populations <- metadata_populations  %>% 
  mutate(sample_id = factor(sample_id), 
         population = factor(population))

# Save the new population metadata file
save(metadata_populations, file = "data/metadata/metadata_populations.Rda")
```

### ----------------------- END OF PHASE 4: POPULATION METADATA GENERATION ----------------------- ###

## ------------------------ END OF ANALYSIS 4: POPULATION INFERENCE  ----------------------- ##

