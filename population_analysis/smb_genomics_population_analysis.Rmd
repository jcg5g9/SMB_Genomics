---
title: 'Analysis 4: Population Inference'
author: "Joe Gunn"
date: "2022-08-29"
output: html_document
---

# Project: Population genomic analysis of Smallmouth Bass and Neosho Bass in the Central Interior Highlands
We investigated the extent of genomic divergence, local directional selection, and admixture between the Smallmouth Bass (<i>Micropterus dolomieu</i>) and the Neosho Bass (<i>M. velox</i>) in the Central Interior Highlands (CIH) ecoregion of central north America. Specifically, we used ddRADseq data to assessed the phylogenomic relationship between and within species, characterizing inter- and intraspecific diversity and SNPs potentially under local directional selection at the population level. Additionally, we inferred the relative timing of admxiture in Neosho Bass streams where there is known introgressive hybridization with Smallmouth Bass to understand the influence of natural, historic geographic factors on mixing (stream capture or transient flooding) vs. anthropogenic factors (i.e., non-native introductions through stocking), which is known to have occurred widely in these economically valuable species. We ultimately hoped to provide novel insights into the diversity of endemic, ecologically important and popular sport fish in the CIH.

## Specific Aim: Population Inference
In this analysis, we used the finerad.vcf data generated in Analysis 2 (SNP Filtering...) to assess fine-scale coancestry between Smallmouth Bass, and Neosho Bass in the CIH using haplotype inference (excluding Spotted Bass). Specifically, we estimated coancestry in 1) the full dataset, with all pure and admixed individuals, excluding the Spotted Bass X Smallmouth Bass hybrid (BFC10) inferred from population genomic analysis in Analysis 3, 2) the pure dataset, with only pure individuals of Smallmouth Bass and Neosho Bass, and 3) the admixed dataset, with only admixed individuals of Neosho Bass (no admixed Smallmouth Bass were detected).

## Phases of analysis:
### Phase 1: Data preparation 
### Phase 2: Coancestry analysis
### Phase 3: Plotting

## Libraries needed for analysis
```{r libraries, echo = FALSE}
library(readxl)
library(tidyverse)
library(cowplot)
library(devtools)
library(XML)
library(RColorBrewer)
source("code/source_code/FinestructureLibrary.R") #Fine-structure R source code
```

## PHASE 1: DATA PREPARATION
In this phase of the analysis, we are reading in the fully filtered, non-thinned VCF dataset (`finerad.vcf`) and further filtering these data to create three additional datasets, including 1) all Smallmouth Bass and Neosho Bass samples; 2) pure samples only, and 3) admixed samples only.

All analyses conducted by calling commands in bash shell scripts were performed on the Lewis high-performance computing cluster at the University of Missouri <br>

<b>Programs needed</b>: <br><br>

FINERADSTRUCTURE v.0.3.2 (Malinsky, Trucchi, Lawson, & Falush, 2018) <br>

<b>Citation</b>:<br>

Malinsky, M., Trucchi, E., Lawson, D. J., & Falush, D. (2018). RADpainter and fineRADstructure: Population inference from RADseq data. Molecular Biology and Evolution, 35, 1284â€“1290. doi:10.1093/molbev/msy023

### STEP 1: Filter out Spotted Bass samples and the Spotted Bass X Neosho Bass hybrid. 
In this step, we are filtering out Spotted Bass and the single Spotted Bass X Neosho Bass hybrid (BFC10) from the full, non-thinned dataset, since we are interested in assessing coance

#### 1a: Generate a general bash shell script header for data filtering in VCFTools
In this step, we are generating another bash shell script to run individual sample filtering in VCFTools (see `filtering_processing_analysis/smb_genomics_filtering_processing_analysis.Rmd` for details on programs needed, etc.). Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each data filtering step and the associated lines of code in Rmd chunks. The shell script for running all VCFTools code is called "vcftools.sh".

##### 1a.1: Copy and paste the code below in a new shell script file: 

##### Generate VCFTools bash shell script: `code/shell_scripts/vcftools.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J vcftools  # give the job a custom name
#SBATCH -o filter_spotted.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

# Load VCFtools module

# module load rss/rss-2020
# module load vcftools/vcftools-v0.1.14
```

##### Important Note: the generated file will have an additional extension (.recode), which is not necessary for downstream analyses. Every time a new VCF file was filtered, we manually removed this piece of the extension by copying the file to a new name (see below) and deleting the .recode.vcf file.

#### 1b: Filter the full, non-thinned VCF to remove Spotted Bass hybrid (BFC10) and Spotted Bass individuals.

##### 1b.1. Read in the .Rda file saved in `smb_genomics_admixture_analysis.Rmd`; run the Rmd chunk below:

##### Generate list of Spotted Bass hybrid: `data/filtering_data/bfc10.txt` 
```{r}
# Load in the .Rda file generated in the admixture analysis
load("../admixture_analysis/data/filtering_data/bcf10.Rda")

BFC10 <- as.data.frame(BFC10)

# Save the list of bad samples as a .txt file without column names
write_tsv(BFC10, 
          file = "data/filtering_data/bfc10.txt", 
          col_names = FALSE)

# Save the list of bad samples as a .Rda file without column names
save(BFC10, file = "data/filtering_data/bcf10.Rda")
```

#### 1b.2. Copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate a filtered VCF file without BFC10:

##### Command line code for filtering. UNCOMMENT this code in the shell script:
```{bash}
## filter 01: omit Spotted Bass X Neosho Bass hybrid (BFC10) 
#vcftools --vcf ../../data/processed_vcf/finerad.vcf --remove ../../data/filtering_data/bfc10.txt --recode --recode-INFO-all --out ../../data/processed_vcf/01_finerad_spb_hybrid
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_bed/all_samples/01_finerad_spb_hybrid.vcf`. This file should be used as input in analysis in the next vcftools filter.

<b>Filtering results</b>: <br><br>
<b>Samples omitted </b> = 1 <br>
<b>Samples retained </b> = 91 <br>
<b>SNPs retained </b> = 50,828 <br>

##### 1b.3. Generate a list of only Spotted Bass to be used for filtering in subsequent steps:

##### Read in metadata and generate Spotted Bass list: `data/filtering_data/spotted_bass.txt`
```{r}
spotted_bass <- metadata %>%
  filter(species == "Spotted_Bass")

# Select the first column and convert to data frame
spotted_bass <- data.frame(spotted_bass) %>%
  select(sample_id)

# Save the list of bad samples as a .txt file without column names
write_tsv(spotted_bass, 
          file = "data/filtering_data/spotted_bass.txt", 
          col_names = FALSE)
```

##### 1b.2. Copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate a filtered VCF file without Spotted Bass:

##### Command line code for filtering. UNCOMMENT this code in the shell script and run: `sbatch vcftools.sh`
```{bash}
## filter 02: omit Spotted Bass
#vcftools --vcf ../../data/processed_vcf/01_finerad_spb_hybrid.vcf --remove ../../data/filtering_data/spotted_bass.txt --recode --recode-INFO-all --out ../../data/processed_vcf/02_finerad_spb
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_bed/all_samples/02_finerad_spb.vcf`. This file should be used in the next vcftools filter.

<b>Filtering results</b>: <br><br>
<b>Samples omitted </b> = 4 <br>
<b>Samples retained </b> = 87 <br>
<b>SNPs retained </b> = 50,828 <br>

### STEP 2: Generate two datasets, one for only pure samples and one for only admixed samples
In this step, we are further filtering the finerad dataset to create datasets for 1) only pure samples and 2) only admixed samples. We are interested in understanding coancestry among individuals within these groups so that we may infer population designations based on haplotype similarity. Individuals that are closely related and likely within a single population form blocks of coancestry in a FINERADSTRUCTURE output heat map (see figures generated in PHASE 3 below).

#### 2b: Filter the full, non-thinned VCF to generate a dataset with all pure individuals.

##### 2b.1. Read in the .Rda file for admixed individuals saved in `smb_genomics_admixture_analysis.Rmd`; run the Rmd chunk below:

##### Generate list of admixed individuals (to be removed from the dataset): `data/filtering_data/admixed_individuals.txt` 
```{r}
# Load in the .Rda file generated in the admixture analysis
load("../admixture_analysis/data/filtering_data/admixed_individuals.Rda")

admixed_individuals <- as.data.frame(admixed_individuals)

# Save the list of bad samples as a .txt file without column names
write_tsv(admixed_individuals, 
          file = "data/filtering_data/admixed_individuals.txt", 
          col_names = FALSE)

# Save the list of bad samples as a .Rda file without column names
save(admixed_individuals, file = "data/filtering_data/admixed_individuals.Rda")
```

##### 2b.2. Copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate a filtered VCF file with only pure individuals:

##### Command line code for filtering. UNCOMMENT this code in the shell script:
```{bash}
## filter A_03: Generate finerad dataset with only pure individuals
#vcftools --vcf ../../data/processed_vcf/02_finerad_spb.vcf --remove ../../data/filtering_data/admixed_individuals.txt --recode --recode-INFO-all --out ../../data/processed_vcf/A_03_finerad_pure
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_bed/all_samples/03_finerad_pure.vcf`. This file should be used for downstream analyses in FINERADSTRUCTURE.

<b>Filtering results</b>: <br><br>
<b>Samples omitted </b> = 40 <br>
<b>Samples retained </b> = 47 <br>
<b>SNPs retained </b> = 50,828 <br>

#### 2c: Filter the full, non-thinned VCF to generate a dataset with all admixed individuals.

##### 2c.1. Read in the .Rda file for pure individuals saved in `smb_genomics_admixture_analysis.Rmd`; run the Rmd chunk below:

##### Generate list of pure individuals (to be removed from the dataset): `data/filtering_data/pure_individuals.txt` 
```{r}
# Load in the .Rda file generated in the admixture analysis
load("../admixture_analysis/data/filtering_data/pure_individuals.Rda")

pure_individuals <- as.data.frame(pure_individuals)

# Save the list of bad samples as a .txt file without column names
write_tsv(pure_individuals, 
          file = "data/filtering_data/pure_individuals.txt", 
          col_names = FALSE)

# Save the list of bad samples as a .Rda file without column names
save(pure_individuals, file = "data/filtering_data/pure_individuals.Rda")
```

##### 2c.2. Copy and paste the code below in the shell file generated in Step 1a.1 above, which will generate a filtered VCF file with only pure individuals:

##### Command line code for filtering. UNCOMMENT this code in the shell script:
```{bash}
## filter B_03: Generate finerad dataset with only pure individuals
#vcftools --vcf ../../data/processed_vcf/02_finerad_spb.vcf --remove ../../data/filtering_data/pure_individuals.txt --recode --recode-INFO-all --out ../../data/processed_vcf/B_03_finerad_admixed
```

Run: `sbatch vcftools.sh`

This code generates the file: `data/processed_bed/all_samples/03_finerad_pure.vcf`. This file should be used for downstream analyses in FINERADSTRUCTURE.

<b>Filtering results</b>: <br><br>
<b>Samples omitted </b> = 47 <br>
<b>Samples retained </b> = 40 <br>
<b>SNPs retained </b> = 50,828 <br>

### ----------------------- END OF PHASE 1: DATA PREPARATION ----------------------- ###

## PHASE 2: COANCESTRY ANALYSIS
and generating haplotype mapping files (hapmap) files to be used for coancestry analysis with the software program FINERADSTRUCTURE

### STEP 1: Generate a general bash shell script header for all FINERADSTRUCTURE commands
In this step, we are generating a universal bash shell script to run all input file conversions and subsequent coancestry analyses in FINERADSTRUCTURE. Here, we only generate the annotated header for the shell script, and in subsequent steps, we include and provide details on each file conversion or analysis and the associated lines of code in Rmd chunks. The shell script for running all FINERADSTRUCTURE code is called "finerad.sh".

##### 1a: Generate the header for a general bash shell script to run FINERADSTRUCTURE:

##### Generate FINERADSTRUCTURE bash shell script: `code/shell_scripts/finerad.sh`
```{bash}
#! /bin/bash

#SBATCH -p Lewis  # use the Lewis partition
#SBATCH -J finerad  # give the job a custom name
#SBATCH -o finerad.out  # give the job output a custom name
#SBATCH -t 0-02:00  # two hour time limit

#SBATCH -N 1  # number of nodes
#SBATCH -n 1  # number of cores (AKA tasks)

# Commands here run only on the first core

# module load rss/rss-2020
# module load fineradstructure/fineradstructure-0.3.2
```

#### 1b: Generate painted hap map input files for coancestry analysis
In this step, we are converting VCF files to hap map files, which are input for the FINERADSTRUCTURE program, for 1) all Smallmouth Bass and Neosho Bass samples, 2) all pure samples only, and 3) all admixed samples.

##### 1b.1 Copy and paste the code below in the shell file generated in Step 1a above, which will generate hap map files for all three groups of interest (all individuals excluding Spotted Bass, pure individuals, and admixed individuals):

##### Generate hap map files. UNCOMMENT this code in the shell script:
```{bash}
## file conversion 01: convert VCF into haplotype chunks for all Smallmouth Bass and Neosho Bass
#RADpainter hapsFromVCF ../../data/processed_vcf/finerad.vcf > ../../datal/hap_maps/01_smb_neosho.txt
#RADpainter paint ../../data/hap_maps/01_smb_neosho.txt

## file conversion 02: convert VCF into haplotype chunks for all pure samples
#RADpainter hapsFromVCF ../../data/processed_vcf/A_03_finerad_pure.vcf > ../../datal/hap_maps/02_pure.txt
#RADpainter paint ../../data/hap_maps/02_pure.txt

## file conversion 03: convert VCF into haplotype chunks for all admixed samples
#RADpainter hapsFromVCF ../../data/processed_vcf/B_03_finerad_admixed.vcf > ../../datal/hap_maps/03_admixed.txt
#RADpainter paint ../../data/hap_maps/03_admixed.txt
```

This code generates 6 files: <br>
  1) `data/hap_maps/01_smb_neosho.txt`: this is a haplotype map file for Smallmouth Bass and Neosho Bass
  2) `data/hap_maps/02_pure.txt`: this is a haplotype map file for pure individuals
  3) `data/hap_maps/03_admixed.txt`: this is a haplotype map file for admixed individuals
  4) `data/hap_maps/01_smb_neosho_chunks.out`: this is a haplotype chunks file for Smallmouth Bass and Neosho Bass
  5) `data/hap_maps/02_pure_chunks.out`: this is a haplotype chunks file for pure individuals
  6) `data/hap_maps/01_admixed_chunks.out`: this is a haplotype chunks file for admixed individuals

Each of the "chunks" files is then used as input in the FINERADSTRUCTURE coancestry matrix algorithm.

#### 1c: Calculate coancestry matrices and build phylogenetic trees based on haplotype inference from hap map files
<b>We use the following flags in the code</b>: <br>
    -x: Number of burn-in steps (100,000)
    -y: Number of MCMC iterations (100,000)
    -z: Number of thinning steps (1,000)
    -T: Initialization procedure (don't set to anything, leave blank)
    -x: Number of tries for making best population state (10,000)
    
##### Copy and paste the code below in the shell file generated in Step 1a above, which will generate coancestry matrices and accompanying phylogenetic tree files for all three groups of interest (all individuals excluding Spotted Bass, pure individuals, and admixed individuals):

##### Calculate coancestry and generate phylogenies: 
```{bash}
## Coancestry 01: Smallmouth Bass and Neosho Bass
#finestructure -x 100000 -y 100000 -z 1000 ../../hap_maps/01_smb_neosho_chunks.out ../../mcmc_files/01_smb_neosho_chunks.mcmc.xml
#finestructure -m T -x 10000 ../../hap_maps/01_smb_neosho_chunks.out ../../mcmc_files/01_smb_neosho_chunks.mcmc.xml 01_smb_neosho_chunks.mcmcTree.xml

## Coancestry 02: Pure samples
#finestructure -x 100000 -y 100000 -z 1000 ../../hap_maps/02_pure_chunks.out ../../mcmc_files/02_pure_chunks.mcmc.xml
#finestructure -m T -x 10000 ../../hap_maps/02_pure_chunks.out ../../mcmc_files/02_pure_chunks.mcmc.xml 02_pure_chunks.mcmcTree.xml

## Coancestry 03:  Smallmouth Bass and Neosho Bass
#finestructure -x 100000 -y 100000 -z 1000 ../../hap_maps/03_admixed_chunks.out ../../mcmc_files/03_admixed_chunks.mcmc.xml
#finestructure -m T -x 10000 ../../hap_maps/03_admixed_chunks.out ../../mcmc_files/03_admixed_chunks.mcmc.xml 03_admixed_chunks.mcmcTree.xml
```

This code generates 6 files: <br>
  1) `data/mcmc_files/01_smb_neosho_chunks.mcmc.xml`: this is a coancestry matrix file Smallmouth Bass and Neosho Bass
  2) `data/mcmc_files/02_pure_chunks.mcmc.xml`: this is a coancestry matrix file file for pure individuals
  3) `data/mcmc_files/03_admixed_chunks.mcmc.xml`: this is a coancestry matrix file file for admixed individuals
  4) `data/tree_files/01_smb_neosho_chunks.mcmcTree.xml`: this is a phylogenetic tree file for Smallmouth Bass and Neosho Bass
  5) `data/tree_files/02_pure_chunks.mcmcTree.xml`: this is a phylogenetic tree file for pure individuals
  6) `data/tree_files/03_admixed_chunks.mcmcTree.xml`: this is a phylogenetic tree file for admixed individuals

Each of the output files were used to generate publication figures in the PHASE 3 (below).

### ----------------------- END OF PHASE 2: COANCESTRY ANALYSIS ----------------------- ###

## PHASE 3: PLOTTING
In this phase, we are using previously documented source code (`code/source_code/FinestructureLibrary.R`) to build publication-ready figures of coancestry matrices and corresponding phylogenies for each group of interest (Smallmouth Bass and Neosho Bass, pure samples, and admixed samples). 

### STEP 1: Read in hap map 'chunk' files, mcmc files, and tree files generated in Phase 2, Step 1b.1 above.

#### 1a: Read in files for Smallmouth Bass and Neosho Bass; run the Rmd chunk below:

###### Read in data:
```{r}
# Read in hapmap file
smb_neosho_hapmap <- "data/hap_maps/01_smb_neosho_chunks.out"

# Read in mcmc file
smb_neosho_mcmcfile <- "data/hap_maps/01_smb_neosho_chunks.mcmc.xml"

# Read in tree file
smb_neosho_treefile <- "data/hap_maps/01_smb_neosho_chunks.mcmcTree.xml"
```

#### 1b: Read in files for pure samples; run the Rmd chunk below:

###### Read in data:
```{r}
# Read in hapmap file
pure_hapmap <- "data/hap_maps/02_pure_chunks.out"

# Read in mcmc file
pure_mcmcfile <- "data/hap_maps/02_pure_chunks.mcmc.xml"

# Read in tree file
pure_treefile <- "data/hap_maps/02_pure_chunks.mcmcTree.xml"
```

#### 1c: Read in files for admixed samples; run the Rmd chunk below:

###### Read in data:
```{r}
# Read in hapmap file
admixed_hapmap <- "data/hap_maps/03_admixed_chunks.out"

# Read in mcmc file
admixed_mcmcfile <- "data/hap_maps/03_admixed_chunks.mcmc.xml"

# Read in tree file
admixed_treefile <- "data/hap_maps/03_admixed_chunks.mcmcTree.xml"
```

### STEP 2: Plot coancestry matrices along with corresponding phylogenetic trees.
In this step, we are using previously published source code by the developers of FINERADSTRUCTURE to plot coancestry matrices and phylogenetic trees. All code below is annotated to the best of our knowledge and corresponds directly with the published source code (FinestructureLibrary.R).

#### 2a: Set path name for depositing completed fineRADstructure figures; run the Rmd chunk below:

##### Set figure path: `figures/coancestry_figures`
```{r}
# Set plotsFolder path name
plotsFolder <- "figures/coancestry_figures"

# Set general name for analysis, which will be appended to each figure
analysisName <- "coancestry" 
maxIndv <- 10000
maxPop <-10000
```

#### 2b: Set color palette to use for all coancestry heat map figures; run the Rmd chunk below:

##### Set color palette for figures
```{r color palette, echo=FALSE}
my_palette <- colorRampPalette(c("white", "navyblue","deeppink2","black"))(n = 299)
```

#### 2b. Extract XML data from mcmc and tree files

##### 2b.1 Extract XML data from mcmc and tree files for Smallmouth Bass and Neosho Bass:

##### Extract data for Smallmouth Bass and Neosho Bass: 
```{r}
# Generate matrix of data
smb_neosho_dataraw <- as.matrix(read.table(smb_neosho_hapmap, 
                                    row.names=1, 
                                    header=T, 
                                    skip=1)) # read in the pairwise coincidence 

# Read in mcmc file
smb_neosho_mcmcxml <- xmlTreeParse(smb_neosho_mcmcfile)
smb_neosho_mcmcdata <- as.data.frame.myres(smb_neosho_mcmcfile)

# Read in tree file
smb_neosho_treexml <- xmlTreeParse(smb_neosho_treefile)
smb_neosho_ttree <- extractTree(smb_neosho_treexml)
```

##### 2b.2 Extract XML data from mcmc and tree files for Smallmouth Bass and Neosho Bass:

##### Extract data for pure samples: 
```{r}
# Generate matrix of data
pure_dataraw <- as.matrix(read.table(pure_hapmap, 
                                    row.names=1, 
                                    header=T, 
                                    skip=1)) # read in the pairwise coincidence 

# Read in mcmc file and convert to data frame
pure_mcmcxml <- xmlTreeParse(pure_mcmcfile)
pure_mcmcdata <- as.data.frame.myres(pure_mcmcfile)

# Read in tree file
pure_treexml <- xmlTreeParse(pure_treefile)
pure_ttree <- extractTree(pure_treexml)
```

##### 2b.3 Extract XML data from mcmc and tree files for admixed samples:

##### Extract data for admixed samples: 
```{r}
# Generate matrix of data
admixed_dataraw <- as.matrix(read.table(admixed_hapmap, 
                                    row.names=1, 
                                    header=T, 
                                    skip=1)) # read in the pairwise coincidence 

# Read in mcmc file and convert to data frame
admixed_mcmcxml <- xmlTreeParse(admixed_mcmcfile)
admixed_mcmcdata <- as.data.frame.myres(admixed_mcmcfile)

# Read in tree file
admixed_treexml <- xmlTreeParse(admixed_treefile)
admixed_ttree <- extractTree(admixed_treexml)
```


## Make files for coancestry plot and dendrogram
```{r}

#Only ADMIXED SMB samples

## Reduce the amount of significant digits printed in the posteror assignment probabilities (numbers shown in the tree):
ttree_admix$node.label[ttree_admix$node.label!=""] <- format(as.numeric(ttree_admix$node.label[ttree_admix$node.label!=""]),digits=2)

 # convert to dendrogram format
tdend_admix <- myapetodend(ttree_admix, factor=1)
## Now we work on the MAP state
mapstate_admix <- extractValue(treexml_admix,"Pop") # map state as a finestructure clustering
mapstatelist_admix <- popAsList(mapstate_admix) # .. and as a list of individuals in populations
popnames_admix <- lapply(mapstatelist_admix, NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot_admix <-lapply(mapstatelist_admix, NameMoreSummary) # a nicer summary of the populations

names(popnames_admix) <- popnamesplot_admix # for nicety only
names(popnamesplot_admix ) <- popnamesplot_admix # for nicety only

popdend_admix <- makemydend(tdend_admix, mapstatelist_admix) # use NameSummary to make popdend
popdend_admix <- fixMidpointMembers(popdend_admix) # needed for obscure dendrogram reasons
popdendclear_admix <- makemydend(tdend_admix, mapstatelist_admix, "NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear_admix <- fixMidpointMembers(popdendclear_admix) # needed for obscure dendrogram reasons


#Only SMB samples

## Reduce the amount of significant digits printed in the posteror assignment probabilities (numbers shown in the tree):
ttree_smb$node.label[ttree_smb$node.label!=""] <- format(as.numeric(ttree_smb$node.label[ttree_smb$node.label!=""]),digits=2)

 # convert to dendrogram format
tdend_smb <- myapetodend(ttree_smb, factor=1)
## Now we work on the MAP state
mapstate_smb <- extractValue(treexml_smb,"Pop") # map state as a finestructure clustering
mapstatelist_smb <- popAsList(mapstate_smb) # .. and as a list of individuals in populations
popnames_smb <- lapply(mapstatelist_smb, NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot_smb <-lapply(mapstatelist_smb, NameMoreSummary) # a nicer summary of the populations

names(popnames_smb) <- popnamesplot_smb # for nicety only
names(popnamesplot_smb ) <- popnamesplot_smb # for nicety only

popdend_smb <- makemydend(tdend_smb, mapstatelist_smb) # use NameSummary to make popdend
popdend_smb <- fixMidpointMembers(popdend_smb) # needed for obscure dendrogram reasons
popdendclear_smb <- makemydend(tdend_smb, mapstatelist_smb, "NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear_smb <- fixMidpointMembers(popdendclear_smb) # needed for obscure dendrogram reasons



#Only Pure SMB samples

## Reduce the amount of significant digits printed in the posteror assignment probabilities (numbers shown in the tree):
ttree_noadmix_smb$node.label[ttree_noadmix_smb$node.label!=""] <- format(as.numeric(ttree_noadmix_smb$node.label[ttree_noadmix_smb$node.label!=""]),digits=2)

 # convert to dendrogram format
tdend_noadmix_smb <- myapetodend(ttree_noadmix_smb, factor=1)
## Now we work on the MAP state
mapstate_noadmix_smb <- extractValue(treexml_noadmix_smb,"Pop") # map state as a finestructure clustering
mapstatelist_noadmix_smb <- popAsList(mapstate_noadmix_smb) # .. and as a list of individuals in populations
popnames_noadmix_smb <- lapply(mapstatelist_noadmix_smb, NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot_noadmix_smb <-lapply(mapstatelist_noadmix_smb, NameMoreSummary) # a nicer summary of the populations

names(popnames_noadmix_smb) <- popnamesplot_noadmix_smb # for nicety only
names(popnamesplot_noadmix_smb ) <- popnamesplot_noadmix_smb # for nicety only

popdend_noadmix_smb <- makemydend(tdend_noadmix_smb, mapstatelist_noadmix_smb) # use NameSummary to make popdend
popdend_noadmix_smb <- fixMidpointMembers(popdend_noadmix_smb) # needed for obscure dendrogram reasons
popdendclear_noadmix_smb <- makemydend(tdend_noadmix_smb, mapstatelist_noadmix_smb, "NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear_noadmix_smb <- fixMidpointMembers(popdendclear_noadmix_smb) # needed for obscure dendrogram reasons


#Only Pure samples

## Reduce the amount of significant digits printed in the posteror assignment probabilities (numbers shown in the tree):
ttree_noadmix$node.label[ttree_noadmix$node.label!=""] <- format(as.numeric(ttree_noadmix$node.label[ttree_noadmix$node.label!=""]),digits=2)

 # convert to dendrogram format
tdend_noadmix <- myapetodend(ttree_noadmix, factor=1)
## Now we work on the MAP state
mapstate_noadmix <- extractValue(treexml_noadmix,"Pop") # map state as a finestructure clustering
mapstatelist_noadmix <- popAsList(mapstate_noadmix) # .. and as a list of individuals in populations
popnames_noadmix <- lapply(mapstatelist_noadmix, NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot_noadmix <-lapply(mapstatelist_noadmix, NameMoreSummary) # a nicer summary of the populations

names(popnames_noadmix) <- popnamesplot_noadmix # for nicety only
names(popnamesplot_noadmix ) <- popnamesplot_noadmix # for nicety only

popdend_noadmix <- makemydend(tdend_noadmix, mapstatelist_noadmix) # use NameSummary to make popdend
popdend_noadmix <- fixMidpointMembers(popdend_noadmix) # needed for obscure dendrogram reasons
popdendclear_noadmix <- makemydend(tdend_noadmix, mapstatelist_noadmix, "NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear_noadmix <- fixMidpointMembers(popdendclear_noadmix) # needed for obscure dendrogram reasons



#Black Bass Samples, excluding the SPOTTED BASS HYBRID

## Reduce the amount of significant digits printed in the posteror assignment probabilities (numbers shown in the tree):
ttree_nohybrid$node.label[ttree_nohybrid$node.label!=""] <- format(as.numeric(ttree_nohybrid$node.label[ttree_nohybrid$node.label!=""]),digits=2)

 # convert to dendrogram format
tdend_nohybrid <- myapetodend(ttree_nohybrid, factor=1)
## Now we work on the MAP state
mapstate_nohybrid <- extractValue(treexml_nohybrid,"Pop") # map state as a finestructure clustering
mapstatelist_nohybrid <- popAsList(mapstate_nohybrid) # .. and as a list of individuals in populations
popnames_nohybrid <- lapply(mapstatelist_nohybrid, NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot_nohybrid <-lapply(mapstatelist_nohybrid, NameMoreSummary) # a nicer summary of the populations

names(popnames_nohybrid) <- popnamesplot_nohybrid # for nicety only
names(popnamesplot_nohybrid ) <- popnamesplot_nohybrid # for nicety only

popdend_nohybrid <- makemydend(tdend_nohybrid, mapstatelist_nohybrid) # use NameSummary to make popdend
popdend_nohybrid <- fixMidpointMembers(popdend_nohybrid) # needed for obscure dendrogram reasons
popdendclear_nohybrid <- makemydend(tdend_nohybrid, mapstatelist_nohybrid, "NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear_nohybrid <- fixMidpointMembers(popdendclear_nohybrid) # needed for obscure dendrogram reasons

#Black Bass Samples

## Reduce the amount of significant digits printed in the posteror assignment probabilities (numbers shown in the tree):
ttree_blackbass$node.label[ttree_blackbass$node.label!=""] <- format(as.numeric(ttree_blackbass$node.label[ttree_blackbass$node.label!=""]),digits=2)

 # convert to dendrogram format
tdend_blackbass <- myapetodend(ttree_blackbass, factor=1)
## Now we work on the MAP state
mapstate_blackbass <- extractValue(treexml_blackbass,"Pop") # map state as a finestructure clustering
mapstatelist_blackbass <- popAsList(mapstate_blackbass) # .. and as a list of individuals in populations
popnames_blackbass <- lapply(mapstatelist_blackbass, NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot_blackbass <-lapply(mapstatelist_blackbass, NameMoreSummary) # a nicer summary of the populations

names(popnames_blackbass) <- popnamesplot_blackbass # for nicety only
names(popnamesplot_blackbass ) <- popnamesplot_blackbass # for nicety only

popdend_blackbass <- makemydend(tdend_blackbass, mapstatelist_blackbass) # use NameSummary to make popdend
popdend_blackbass <- fixMidpointMembers(popdend_blackbass) # needed for obscure dendrogram reasons
popdendclear_blackbass <- makemydend(tdend_blackbass, mapstatelist_blackbass, "NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear_blackbass <- fixMidpointMembers(popdendclear_blackbass) # needed for obscure dendrogram reasons


#Neosho Samples

## Reduce the amount of significant digits printed in the posteror assignment probabilities (numbers shown in the tree):
ttree_neo$node.label[ttree_neo$node.label!=""] <- format(as.numeric(ttree_neo$node.label[ttree_neo$node.label!=""]),digits=2)

 # convert to dendrogram format
tdend_neo <- myapetodend(ttree_neo, factor=1)
## Now we work on the MAP state
mapstate_neo <- extractValue(treexml_neo,"Pop") # map state as a finestructure clustering
mapstatelist_neo <- popAsList(mapstate_neo) # .. and as a list of individuals in populations
popnames_neo <- lapply(mapstatelist_neo, NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot_neo <-lapply(mapstatelist_neo, NameMoreSummary) # a nicer summary of the populations

names(popnames_neo) <- popnamesplot_neo # for nicety only
names(popnamesplot_neo ) <- popnamesplot_neo # for nicety only

popdend_neo <- makemydend(tdend_neo, mapstatelist_neo) # use NameSummary to make popdend
popdend_neo <- fixMidpointMembers(popdend_neo) # needed for obscure dendrogram reasons
popdendclear_neo <- makemydend(tdend_neo, mapstatelist_neo, "NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear_neo <- fixMidpointMembers(popdendclear_neo) # needed for obscure dendrogram reasons

#Northern Samples

## Reduce the amount of significant digits printed in the posteror assignment probabilities (numbers shown in the tree):
ttree_nor$node.label[ttree_nor$node.label!=""] <- format(as.numeric(ttree_nor$node.label[ttree_nor$node.label!=""]),digits=2)

 # convert to dendrogram format
tdend_nor <- myapetodend(ttree_nor, factor=1)
## Now we work on the MAP state
mapstate_nor <- extractValue(treexml_nor,"Pop") # map state as a finestructure clustering
mapstatelist_nor <- popAsList(mapstate_nor) # .. and as a list of individuals in populations
popnames_nor <- lapply(mapstatelist_nor, NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot_nor <-lapply(mapstatelist_nor, NameMoreSummary) # a nicer summary of the populations

names(popnames_nor) <- popnamesplot_nor # for nicety only
names(popnamesplot_nor ) <- popnamesplot_nor # for nicety only

popdend_nor <- makemydend(tdend_nor, mapstatelist_nor) # use NameSummary to make popdend
popdend_nor <- fixMidpointMembers(popdend_nor) # needed for obscure dendrogram reasons
popdendclear_nor <- makemydend(tdend_nor, mapstatelist_nor, "NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear_nor <- fixMidpointMembers(popdendclear_nor) # needed for obscure dendrogram reasons

##Non-ark samples

## Reduce the amount of significant digits printed in the posteror assignment probabilities (numbers shown in the tree):
ttree_nonark$node.label[ttree_nonark$node.label!=""] <- format(as.numeric(ttree_nonark$node.label[ttree_nonark$node.label!=""]),digits=2)

 # convert to dendrogram format
tdend_nonark <- myapetodend(ttree_nonark, factor=1)
## Now we work on the MAP state
mapstate_nonark <- extractValue(treexml_nonark,"Pop") # map state as a finestructure clustering
mapstatelist_nonark <- popAsList(mapstate_nonark) # .. and as a list of individuals in populations
popnames_nonark <- lapply(mapstatelist_nonark, NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot_nonark <-lapply(mapstatelist_nonark, NameMoreSummary) # a nicer summary of the populations

names(popnames_nonark) <- popnamesplot_nonark # for nicety only
names(popnamesplot_nonark ) <- popnamesplot_nonark # for nicety only

popdend_nonark <- makemydend(tdend_nonark, mapstatelist_nonark) # use NameSummary to make popdend
popdend_nonark <- fixMidpointMembers(popdend_nonark) # needed for obscure dendrogram reasons
popdendclear_nonark <- makemydend(tdend_nonark, mapstatelist_nonark, "NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear_nonark <- fixMidpointMembers(popdendclear_nonark) # needed for obscure dendrogram reasons
```

## Print fineRADstructure Plots
```{r}
## Plot 1: COANCESTRY MATRIX
fullorder_admix <- labels(tdend_admix) # the order according to the tree
datamatrix_admix <- dataraw_admix[fullorder_admix, fullorder_admix] # reorder the data matrix

tmpmat_admix <- datamatrix_admix
tmpmat_admix[tmpmat_admix > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/admix_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_admix, 
                  dimnames(tmpmat_admix)[[1]], 
                  dend = tdend_admix,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 2: POPULATIONS AND COANCESTRY AVERAGES
popmeanmatrix_admix <- getPopMeanMatrix(datamatrix_admix, mapstatelist_admix)

tmpmat_admix <- popmeanmatrix_admix
tmpmat_admix[tmpmat_admix > maxPop] <- maxPop # cap the heatmap

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/admix_coancestry_matrix_averages_betterlabels.pdf", height = 20, width = 20)

plotFinestructure(tmpmat_admix, 
                  dimnames(tmpmat_admix)[[1]], 
                  dend = tdend_admix, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))

dev.off()


## Plot 3: POPULATIONS AND COANCESTRY AVERAGES WITH PERHAPS MORE INFORMATIVE LABELS
mappopcorrectorder_admix <- NameExpand(labels(popdend_admix))
mappopsizes_admix <- sapply(mappopcorrectorder_admix,length)
labellocs_admix <- PopCenters(mappopsizes_admix)
xcrt=0
ycrt=45

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/admix_coancestry_matrix_averages_betterlabels_betterlabels.pdf", height = 25, width = 25)
 
plotFinestructure(tmpmat_admix, 
                  dimnames(tmpmat_admix)[[1]], 
                  labelsx=labels(popdendclear_admix), 
                  labelsatx = labellocs_admix, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = tdend_admix, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()


## Plot 1: COANCESTRY MATRIX
fullorder_smb <- labels(tdend_smb) # the order according to the tree
datamatrix_smb <- dataraw_smb[fullorder_smb, fullorder_smb] # reorder the data matrix

tmpmat_smb <- datamatrix_smb
tmpmat_smb[tmpmat_smb > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/smb_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_smb, 
                  dimnames(tmpmat_smb)[[1]], 
                  dend = tdend_smb,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 2: POPULATIONS AND COANCESTRY AVERAGES
popmeanmatrix_smb <- getPopMeanMatrix(datamatrix_smb, mapstatelist_smb)

tmpmat_smb <- popmeanmatrix_smb
tmpmat_smb[tmpmat_smb > maxPop] <- maxPop # cap the heatmap

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/smb_coancestry_matrix_averages_betterlabels.pdf", height = 20, width = 20)

plotFinestructure(tmpmat_smb, 
                  dimnames(tmpmat_smb)[[1]], 
                  dend = tdend_smb, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))

dev.off()


## Plot 3: POPULATIONS AND COANCESTRY AVERAGES WITH PERHAPS MORE INFORMATIVE LABELS
mappopcorrectorder_smb <- NameExpand(labels(popdend_smb))
mappopsizes_smb <- sapply(mappopcorrectorder_smb,length)
labellocs_smb <- PopCenters(mappopsizes_smb)
xcrt=0
ycrt=45

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/smb_coancestry_matrix_averages_betterlabels_betterlabels.pdf", height = 25, width = 25)
 
plotFinestructure(tmpmat_smb, 
                  dimnames(tmpmat_smb)[[1]], 
                  labelsx=labels(popdendclear_smb), 
                  labelsatx = labellocs_smb, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = tdend_smb, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()



## Plot 1: COANCESTRY MATRIX
fullorder_noadmix_smb <- labels(tdend_noadmix_smb) # the order according to the tree
datamatrix_noadmix_smb <- dataraw_noadmix_smb[fullorder_noadmix_smb, fullorder_noadmix_smb] # reorder the data matrix

tmpmat_noadmix_smb <- datamatrix_noadmix_smb
tmpmat_noadmix_smb[tmpmat_noadmix_smb > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/noadmix_smb_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_noadmix_smb, 
                  dimnames(tmpmat_noadmix_smb)[[1]], 
                  dend = tdend_noadmix_smb,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 1: COANCESTRY MATRIX
fullorder_noadmix_smb <- labels(tdend_noadmix_smb) # the order according to the tree
datamatrix_noadmix_smb <- dataraw_noadmix_smb[fullorder_noadmix_smb, fullorder_noadmix_smb] # reorder the data matrix

tmpmat_noadmix_smb <- datamatrix_noadmix_smb
tmpmat_noadmix_smb[tmpmat_noadmix_smb > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/noadmix_smb_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_noadmix_smb, 
                  dimnames(tmpmat_noadmix_smb)[[1]], 
                  dend = tdend_noadmix_smb,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 2: POPULATIONS AND COANCESTRY AVERAGES
popmeanmatrix_noadmix_smb <- getPopMeanMatrix(datamatrix_noadmix_smb, mapstatelist_noadmix_smb)

tmpmat_noadmix_smb <- popmeanmatrix_noadmix_smb
tmpmat_noadmix_smb[tmpmat_noadmix_smb > maxPop] <- maxPop # cap the heatmap

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/noadmix_smb_coancestry_matrix_averages_betterlabels.pdf", height = 20, width = 20)

plotFinestructure(tmpmat_noadmix_smb, 
                  dimnames(tmpmat_noadmix_smb)[[1]], 
                  dend = tdend_noadmix_smb, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))

dev.off()


## Plot 3: POPULATIONS AND COANCESTRY AVERAGES WITH PERHAPS MORE INFORMATIVE LABELS
mappopcorrectorder_noadmix_smb <- NameExpand(labels(popdend_noadmix_smb))
mappopsizes_noadmix_smb <- sapply(mappopcorrectorder_noadmix_smb,length)
labellocs_noadmix_smb <- PopCenters(mappopsizes_noadmix_smb)
xcrt=0
ycrt=45

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/noadmix_smb_coancestry_matrix_averages_betterlabels_betterlabels.pdf", height = 25, width = 25)
 
plotFinestructure(tmpmat_noadmix_smb, 
                  dimnames(tmpmat_noadmix_smb)[[1]], 
                  labelsx=labels(popdendclear_noadmix_smb), 
                  labelsatx = labellocs_noadmix_smb, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = tdend_noadmix_smb, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()


## Plot 1: COANCESTRY MATRIX
fullorder_noadmix <- labels(tdend_noadmix) # the order according to the tree
datamatrix_noadmix <- dataraw_noadmix[fullorder_noadmix, fullorder_noadmix] # reorder the data matrix

tmpmat_noadmix <- datamatrix_noadmix
tmpmat_noadmix[tmpmat_noadmix > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/noadmix_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_noadmix, 
                  dimnames(tmpmat_noadmix)[[1]], 
                  dend = tdend_noadmix,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 2: POPULATIONS AND COANCESTRY AVERAGES
popmeanmatrix_noadmix <- getPopMeanMatrix(datamatrix_noadmix, mapstatelist_noadmix)

tmpmat_noadmix <- popmeanmatrix_noadmix
tmpmat_noadmix[tmpmat_noadmix > maxPop] <- maxPop # cap the heatmap

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/noadmix_coancestry_matrix_averages_betterlabels.pdf", height = 20, width = 20)

plotFinestructure(tmpmat_noadmix, 
                  dimnames(tmpmat_noadmix)[[1]], 
                  dend = tdend_noadmix, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))

dev.off()


## Plot 3: POPULATIONS AND COANCESTRY AVERAGES WITH PERHAPS MORE INFORMATIVE LABELS
mappopcorrectorder_noadmix <- NameExpand(labels(popdend_noadmix))
mappopsizes_noadmix <- sapply(mappopcorrectorder_noadmix,length)
labellocs_noadmix <- PopCenters(mappopsizes_noadmix)
xcrt=0
ycrt=45

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/noadmix_coancestry_matrix_averages_betterlabels_betterlabels.pdf", height = 25, width = 25)
 
plotFinestructure(tmpmat_noadmix, 
                  dimnames(tmpmat_noadmix)[[1]], 
                  labelsx=labels(popdendclear_noadmix), 
                  labelsatx = labellocs_noadmix, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = tdend_noadmix, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()



## Plot 1: COANCESTRY MATRIX
fullorder_nohybrid <- labels(tdend_nohybrid) # the order according to the tree
datamatrix_nohybrid <- dataraw_nohybrid[fullorder_nohybrid, fullorder_nohybrid] # reorder the data matrix

tmpmat_nohybrid <- datamatrix_nohybrid
tmpmat_nohybrid[tmpmat_nohybrid > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/nohybrid_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_nohybrid, 
                  dimnames(tmpmat_nohybrid)[[1]], 
                  dend = tdend_nohybrid,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 2: POPULATIONS AND COANCESTRY AVERAGES
popmeanmatrix_nohybrid <- getPopMeanMatrix(datamatrix_nohybrid, mapstatelist_nohybrid)

tmpmat_nohybrid <- popmeanmatrix_nohybrid
tmpmat_nohybrid[tmpmat_nohybrid > maxPop] <- maxPop # cap the heatmap

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/nohybrid_coancestry_matrix_averages_betterlabels.pdf", height = 20, width = 20)

plotFinestructure(tmpmat_nohybrid, 
                  dimnames(tmpmat_nohybrid)[[1]], 
                  dend = tdend_nohybrid, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))

dev.off()


## Plot 3: POPULATIONS AND COANCESTRY AVERAGES WITH PERHAPS MORE INFORMATIVE LABELS
mappopcorrectorder_nohybrid <- NameExpand(labels(popdend_nohybrid))
mappopsizes_nohybrid <- sapply(mappopcorrectorder_nohybrid,length)
labellocs_nohybrid <- PopCenters(mappopsizes_nohybrid)
xcrt=0
ycrt=45

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/nohybrid_coancestry_matrix_averages_betterlabels_betterlabels.pdf", height = 25, width = 25)
 
plotFinestructure(tmpmat_nohybrid, 
                  dimnames(tmpmat_nohybrid)[[1]], 
                  labelsx=labels(popdendclear_nohybrid), 
                  labelsatx = labellocs_nohybrid, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = tdend_nohybrid, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()


## Plot 1: COANCESTRY MATRIX
fullorder_blackbass <- labels(tdend_blackbass) # the order according to the tree
datamatrix_blackbass <- dataraw_blackbass[fullorder_blackbass, fullorder_blackbass] # reorder the data matrix

tmpmat_blackbass <- datamatrix_blackbass
tmpmat_blackbass[tmpmat_blackbass > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/blackbass_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_blackbass, 
                  dimnames(tmpmat_blackbass)[[1]], 
                  dend = tdend_blackbass,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 2: POPULATIONS AND COANCESTRY AVERAGES
popmeanmatrix_blackbass <- getPopMeanMatrix(datamatrix_blackbass, mapstatelist_blackbass)

tmpmat_blackbass <- popmeanmatrix_blackbass
tmpmat_blackbass[tmpmat_blackbass > maxPop] <- maxPop # cap the heatmap

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/blackbass_coancestry_matrix_averages_betterlabels.pdf", height = 20, width = 20)

plotFinestructure(tmpmat_blackbass, 
                  dimnames(tmpmat_blackbass)[[1]], 
                  dend = tdend_blackbass, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))

dev.off()


## Plot 3: POPULATIONS AND COANCESTRY AVERAGES WITH PERHAPS MORE INFORMATIVE LABELS
mappopcorrectorder_blackbass <- NameExpand(labels(popdend_blackbass))
mappopsizes_blackbass <- sapply(mappopcorrectorder_blackbass,length)
labellocs_blackbass <- PopCenters(mappopsizes_blackbass)
xcrt=0
ycrt=45

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/blackbass_coancestry_matrix_averages_betterlabels_betterlabels.pdf", height = 25, width = 25)
 
plotFinestructure(tmpmat_blackbass, 
                  dimnames(tmpmat_blackbass)[[1]], 
                  labelsx=labels(popdendclear_blackbass), 
                  labelsatx = labellocs_blackbass, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = tdend_blackbass, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()

##################

## Plot 1: COANCESTRY MATRIX
fullorder_neo <- labels(tdend_neo) # the order according to the tree
datamatrix_neo <- dataraw_neo[fullorder_neo, fullorder_neo] # reorder the data matrix

tmpmat_neo <- datamatrix_neo
tmpmat_neo[tmpmat_neo > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/neo_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_neo, 
                  dimnames(tmpmat_neo)[[1]], 
                  dend = tdend_neo,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 2: POPULATIONS AND COANCESTRY AVERAGES
popmeanmatrix_neo <- getPopMeanMatrix(datamatrix_neo, mapstatelist_neo)

tmpmat_neo <- popmeanmatrix_neo
tmpmat_neo[tmpmat_neo > maxPop] <- maxPop # cap the heatmap

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/neo_coancestry_matrix_averages_betterlabels.pdf", height = 20, width = 20)

plotFinestructure(tmpmat_neo, 
                  dimnames(tmpmat_neo)[[1]], 
                  dend = tdend_neo, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))

dev.off()


## Plot 3: POPULATIONS AND COANCESTRY AVERAGES WITH PERHAPS MORE INFORMATIVE LABELS
mappopcorrectorder_neo <- NameExpand(labels(popdend_neo))
mappopsizes_neo <- sapply(mappopcorrectorder_neo,length)
labellocs_neo <- PopCenters(mappopsizes_neo)
xcrt=0
ycrt=45

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/neo_coancestry_matrix_averages_betterlabels_betterlabels.pdf", height = 25, width = 25)
 
plotFinestructure(tmpmat_neo, 
                  dimnames(tmpmat_neo)[[1]], 
                  labelsx=labels(popdendclear_neo), 
                  labelsatx = labellocs_neo, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = tdend_neo, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()

##################

## Plot 1: COANCESTRY MATRIX
fullorder_nor <- labels(tdend_nor) # the order according to the tree
datamatrix_nor <- dataraw_nor[fullorder_nor, fullorder_nor] # reorder the data matrix

tmpmat_nor <- datamatrix_nor
tmpmat_nor[tmpmat_nor > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/nor_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_nor, 
                  dimnames(tmpmat_nor)[[1]], 
                  dend = tdend_nor,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 2: POPULATIONS AND COANCESTRY AVERAGES
popmeanmatrix_nor <- getPopMeanMatrix(datamatrix_nor, mapstatelist_nor)

tmpmat_nor <- popmeanmatrix_nor
tmpmat_nor[tmpmat_nor > maxPop] <- maxPop # cap the heatmap

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/nor_coancestry_matrix_averages_betterlabels.pdf", height = 20, width = 20)

plotFinestructure(tmpmat_nor, 
                  dimnames(tmpmat_nor)[[1]], 
                  dend = tdend_nor, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))

dev.off()


## Plot 3: POPULATIONS AND COANCESTRY AVERAGES WITH PERHAPS MORE INFORMATIVE LABELS
mappopcorrectorder_nor <- NameExpand(labels(popdend_nor))
mappopsizes_nor <- sapply(mappopcorrectorder_nor,length)
labellocs_nor <- PopCenters(mappopsizes_nor)
xcrt=0
ycrt=45

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/nor_coancestry_matrix_averages_betterlabels_betterlabels.pdf", height = 25, width = 25)
 
plotFinestructure(tmpmat_nor, 
                  dimnames(tmpmat_nor)[[1]], 
                  labelsx=labels(popdendclear_nor), 
                  labelsatx = labellocs_nor, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = tdend_nor, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()

##################

## Plot 1: COANCESTRY MATRIX
fullorder_nonark <- labels(tdend_nonark) # the order according to the tree
datamatrix_nonark <- dataraw_nonark[fullorder_nonark, fullorder_nonark] # reorder the data matrix

tmpmat_nonark <- datamatrix_nonark
tmpmat_nonark[tmpmat_nonark > maxIndv] <- maxIndv #  # cap the heatmap

pdf("../../visualization/fineradstructure_figures/final_figures/nonark_coancestry_matrix_betterlabels.pdf", height = 25, width = 25)

plotFinestructure(tmpmat_nonark, 
                  dimnames(tmpmat_nonark)[[1]], 
                  dend = tdend_nonark,
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2))

dev.off()


## Plot 2: POPULATIONS AND COANCESTRY AVERAGES
popmeanmatrix_nonark <- getPopMeanMatrix(datamatrix_nonark, mapstatelist_nonark)

tmpmat_nonark <- popmeanmatrix_nonark
tmpmat_nonark[tmpmat_nonark > maxPop] <- maxPop # cap the heatmap

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/nonark_coancestry_matrix_averages_betterlabels.pdf", height = 20, width = 20)

plotFinestructure(tmpmat_nonark, 
                  dimnames(tmpmat_nonark)[[1]], 
                  dend = tdend_nonark, 
                  cols = my_palette, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                                 t.srt = 1, 
                                 t.off = -0.5, 
                                 t.cex = 2))

dev.off()


## Plot 3: POPULATIONS AND COANCESTRY AVERAGES WITH PERHAPS MORE INFORMATIVE LABELS
mappopcorrectorder_nonark <- NameExpand(labels(popdend_nonark))
mappopsizes_nonark <- sapply(mappopcorrectorder_nonark,length)
labellocs_nonark <- PopCenters(mappopsizes_nonark)
xcrt=0
ycrt=45

pdf("../../visualization/fineradstructure_figures/unused_intermediate_figures/nonark_coancestry_matrix_averages_betterlabels_betterlabels.pdf", height = 25, width = 25)
 
plotFinestructure(tmpmat_nonark, 
                  dimnames(tmpmat_nonark)[[1]], 
                  labelsx=labels(popdendclear_nonark), 
                  labelsatx = labellocs_nonark, 
                  xcrt = xcrt, 
                  cols = my_palette, 
                  ycrt = ycrt, 
                  dend = tdend_nonark, 
                  cex.axis = 1.5, 
                  edgePar = list(p.lwd = 0, 
                               t.srt = 1, 
                               t.off = -0.5, 
                               t.cex = 2), 
                  hmmar = c(3,0,0,1))

dev.off()
```
