% MIXMAPPER Creates a scaffold tree using neighbor joining and finds the
% best-fit placement of one or two additional populations as two- or
% three-way admixtures.  Combines results from bootstrap replicates to
% obtain confidence intervals on parameters, which are output to the console
% in a summary table.  Parameter labels are as in Figure 2 of the MixMapper
% manuscript.  Branches of the scaffold tree from which ancestral
% populations split off are identified by branch-to-leaf paths.  (For
% example, a branch choice of 'Papuan' indicates the branch ending in
% Papuan, whereas '18-Papuan' indicates the branch above the Papuan leaf
% branch.)
%
%   [TREES,FITS] = MIXMAPPER(POP_DATA_REPS,SCAFFOLD_POP_NAMES,ADMIXED1)
%   computes best-fit parameters for fitting population ADMIXED1 as a
%   mixture of two populations branching from the scaffold tree.
%   POP_DATA_REPS is a struct array, each element of which contains the
%   following data for a single bootstrap replicate:
%   - f2_all (n x n matrix of pairwise f2 statistics)
%   - het (n vector of heterozygosity values)
%   - pop_names (n cell array)
%   These values can be computed from genotype data using the
%   compute_moment_stats C++ code, which writes data files that can be
%   imported into Matlab using the READ_MIXMAPPER_INPUT function.
%   SCAFFOLD_POP_NAMES is a cell array containing the populations to use
%   in the scaffold.
%   TREES is a struct array of phytree objects (from the Matlab
%   Bioinformatics Toolbox), one per bootstrap replicate.
%   FITS is a struct array containing corresponding parameters fit.
%
%   [TREES,FITS] = MIXMAPPER(...,ADMIXED1,ADMIXED2) fits ADMIXED1 as a
%   two-way admixture as above and subsequently fits ADMIXED2 as a mixture
%   of the ADMIXED1 branch and a third branch of the scaffold tree.
%
%   [TREES,FITS] = MIXMAPPER(...,ADMIXED1,ADMIXED2,OPTIONS) allows
%   setting additional options by passing a structure OPTIONS with the
%   following possible fields:
%   - outfile: string containing file path to which to write output
%   - drift_units: set to 1 to return branch lengths on the tree in drift
%     units (i.e., normalized by heterozygosity in the parent); note that as
%     drift units are not additive, the tree is made by first fitting in f2
%     units and then converting each branch length
%   - verbose: set to 1 to print detailed parameter-fitting data
%   - branch_sets: set to 1 to display branch names as sets
%   - test_2v3: (NEW in MixMapper 2.0; set to 1 to perform test)
%     Tests goodness of fit of 2-way vs. 3-way admixture models.
%     Specifically, the best-fit model of population ADMIXED2 as a simple
%     2-way admixture between scaffold populations is compared to the
%     best-fit model of ADMIXED2 as a 3-way admixture between ADMIXED1,
%     modeled as a mixture of two scaffold populations, and a third
%     scaffold population.  Each model is evaluated based on the residual
%     error of the fit, and the difference between the 2-way and 3-way
%     residual errors is displayed along with a 95% bootstrap confidence
%     interval.  Note that to make the residual errors comparable, the
%     error in the fitted value of f2(ADMIXED1,ADMIXED2) is not included in
%     the 3-way resnorm (differing from the usual resnorm output).
%   - no_opt3way: (NEW in MixMapper 2.0; set to 1 only to revert to pre-2.0)
%     The original MixMapper fit a 3-way admixture by fitting population
%     ADMIXED1 as a 2-way admixture and then holding the 2-way mixture
%     parameters fixed while fitting ADMIXED2 as a 3-way admixture.
%     MixMapper 2.0 now jointly fits both admixed populations,
%     re-optimizing the 2-way admixture model of ADMIXED1 when adding
%     ADMIXED2 to the model.  Specifically, the variables that are
%     re-optimized are the two mixture proportions and the two terminal 
%     drift lengths.  We have included the 'no_opt3way' option for
%     reproducibility of pre-2.0 results.
%
%   TREES = MIXMAPPER(POP_DATA,SCAFFOLD_POP_NAMES) creates and returns
%   only the scaffold tree.
%
%   Example:
%   
%       % read input data generated by compute_moment_stats (C++ code)
%       pop_data_reps = read_MixMapper_input('example/panel4_thinned_MixMapper');
%
%       % choose populations for scaffold tree
%       scaffold_pop_names = {'Dai' 'Japanese' 'Karitiana' 'Lahu' 'Mandenka' ...
%                             'Naxi' 'Papuan' 'Surui' 'Yi' 'Yoruba'};
%
%       % run bootstrap reps in parallel
%       matlabpool open 4   
%
%       % fit Sardinian as two-way admixture
%       [trees,fits] = MixMapper(pop_data_reps(1:24),scaffold_pop_names,'Sardinian');
%
%       % fit Mozabite as three-way admixture (with one branch off Sardinian)
%       [trees,fits] = MixMapper(pop_data_reps(1:24),scaffold_pop_names,'Sardinian','Mozabite');
%
%       % visualize scaffold tree
%       view(trees(1))
%
%       % test 2-way vs. 3-way goodness of fit
%       options.test_2v3 = 1;
%       MixMapper(pop_data_reps(1:24),scaffold_pop_names,'Sardinian','Mozabite',options);
%
%   See also READ_MIXMAPPER_INPUT.


% Mark Lipson and Po-Ru Loh, 5/29/2014 (version 2.0)

function [trees,fits] = MixMapper(pop_data_reps,scaffold_pop_names,admixed_name1,admixed_name2,options)

if nargin < 3
    admixed_name1 = '';
end
if nargin < 4
    admixed_name2 = '';
end
if nargin < 5
    options = [];
end

if ~isstruct(pop_data_reps), error('arg1 (pop_data_reps) must be struct'), end
if ~iscell(scaffold_pop_names), error('arg2 (scaffold_pop_names) must be cell array of strings'), end
if ~ischar(admixed_name1), error('arg3 (admixed_name1) must be string'), end
if ~ischar(admixed_name2), error('arg4 (admixed_name2) must be string'), end
if ~isstruct(options) && ~isempty(options), error('arg5 (options) must be struct'), end

if ~isfield(options,'test_2v3')
    options.test_2v3 = 0;
end

R = numel(pop_data_reps);
if R == 1 && ~options.test_2v3 % don't bootstrap
    [trees,fits] = fit_admixture(pop_data_reps,scaffold_pop_names,admixed_name1,admixed_name2,options);
    return
end

if isfield(options,'outfile')
    fid = fopen(options.outfile,'a');
else
    fid = 1;
end

if isfield(options,'drift_units')
    drift_units = options.drift_units;
else
    drift_units = 0;
end

if ~isfield(options,'print_output')
    options.print_output = 0; % default: don't display individual rep output
%     if exist('matlabpool') && matlabpool('size')>1
%         options.print_output = 0; % turn off output if making a parallel run
%     end
end

if ~isfield(options,'verbose')
    options.verbose = 0;
end

if ~isfield(options,'branch_sets')
    options.branch_sets = 0;
end

if ~isfield(options,'no_opt3way')
    options.no_opt3way = 0;
end



if options.test_2v3 % just perform 2-way vs. 3-way fit test
    fprintf('fitting %d replicates...\n',R);
    parfor r = 1:R
        fprintf('running rep %d...\n',r);
        
        % fit the second population as a 2-way admixture by itself
        [tree,fit2] = fit_admixture(pop_data_reps(r),scaffold_pop_names,admixed_name2,'',options);
        
        % fit the second population as a 3-way admixture branching from the first
        [~,fit3] = fit_admixture(pop_data_reps(r),scaffold_pop_names,admixed_name1,admixed_name2,options);
        
        if options.verbose
            fprintf('2-way: %.5g\t3-way: %.5g\n',fit2.resnorm1,fit3.resnorm12-fit3.resnorm1);
        end
        
        fits2(r) = fit2;
        fits3(r) = fit3;
        trees(r) = tree;
    end
    
    fprintf(fid,'---- Test for %s 2-way fit vs. 3-way fit from %s (%d reps) ----\n',admixed_name2,admixed_name1,R);
    fprintf(fid,'median resnorms:\t2-way: %.5g\t3-way: %.5g\n',median([fits2.resnorm1]),median([fits3.resnorm12]-[fits3.resnorm1]));
    fprintf(fid,'mean   resnorms:\t2-way: %.5g\t3-way: %.5g\n',mean([fits2.resnorm1]),mean([fits3.resnorm12]-[fits3.resnorm1]));
    ci95 = CI_pct([fits2.resnorm1]' - ([fits3.resnorm12]'-[fits3.resnorm1]'),95);
    fprintf(fid,'2-way - 3-way 95%% CI:   (%.5g, %.5g)   (positive <=> 3-way is better)\n',ci95(1),ci95(2));
    fprintf(fid,'\n');
    
    if fid ~= 1
        fclose(fid);
    end
    
    fits = [];
    return
end



fprintf('fitting %d replicates...\n',R);
parfor r = 1:R
    %t = getCurrentTask();
    %if t.ID == 1
        fprintf('running rep %d...\n',r);
    %end
    [tree,fit] = fit_admixture(pop_data_reps(r),scaffold_pop_names,admixed_name1,admixed_name2,options);
    
    % 3/28/13: we now make branch1 the major ancestry component
%     if ~isempty(admixed_name1)
%         [~,I] = sort({fit.trace1 fit.trace2});
%         if I(1) == 2 % swap branches if trace1 and trace2 not in lexicographic order
%             fit = swap12(fit);
%         end
%     end
    fits(r) = fit;
    trees(r) = tree;
end

if isempty(admixed_name1), return, end

tex_single = {}; tex_double = {}; % will contain tex strings for table output

if options.verbose
    fprintf(fid,'\n');
    fprintf(fid,'\n');
    fprintf(fid,'\t***************************************\n');
    fprintf(fid,'\t********** BOOTSTRAP RESULTS **********\n');
    fprintf(fid,'\t***************************************\n\n');
    
    fprintf(fid,'---- scaffold tree opt_edges ----\n');
    fprintf(fid,'%.3e ',[fits.resnorm0]); fprintf(fid,'\n');
    fprintf(fid,'%.4f     ',[fits.max_residual0]); fprintf(fid,'\n');
    
    fprintf(fid,'---- first admixture ----\n');
    fprintf(fid,'%s\n',admixed_name1);
end

agree_trace12 = true(R,1);
for r = 2:R
    if ~compare_split_pairs(fits(1).split1,fits(1).split2,fits(r).split1,fits(r).split2)
        agree_trace12(r) = false;
    end
end

if options.verbose
    if all(agree_trace12)
        fprintf(fid,'trace: %s\n',fits(1).trace1);
        fprintf(fid,'trace: %s\n',fits(1).trace2);
    else
        fprintf(fid,'*** traces do not agree! ***\n');
        for r = 1:R, fprintf(fid,'%-9s ',crop(fits(r).trace1,9)); end; fprintf(fid,'\n');
        for r = 1:R, fprintf(fid,'%-9s ',crop(fits(r).trace2,9)); end; fprintf(fid,'\n');
    end
    fprintf(fid,'%.3e ',[fits.resnorm1]); fprintf(fid,'\n');
    fprintf(fid,'%.4f     ',[fits.alpha]); fprintf(fid,'\n');
    fprintf(fid,'%.4f     ',[fits.r1]); fprintf(fid,'\n');
    fprintf(fid,'%.4f     ',[fits.r2]); fprintf(fid,'\n');
    fprintf(fid,'%.4f     ',[fits.c]); fprintf(fid,'\n');
end

used = false(R,1);
for r = 1:R
    if used(r), continue, end
    match_r = false(R,1);
    match_r(r) = true;
    for r2 = r+1:R %%%%% main code for branch agreement comparison %%%%%
        cmp_code = compare_split_pairs(fits(r).split1,fits(r).split2,fits(r2).split1,fits(r2).split2);
        if cmp_code
            match_r(r2) = true;
        end
        if cmp_code == -1 % swap branches on r2 to match r
            fprintf('swapping %d\n',r2)
            fits(r2) = swap12(fits(r2));
        end
    end
    
    used = used | match_r;
    subfits = fits(match_r);
    subdata = [subfits.resnorm1; subfits.alpha; subfits.r1; subfits.r2; subfits.c];
    if options.verbose
        fprintf(fid,'\n');
        fprintf(fid,'%s\n',admixed_name1);
        fprintf(fid,'trace: %s\n',fits(r).trace1);
        fprintf(fid,'trace: %s\n',fits(r).trace2);
        fprintf(fid,'# with trace: %d/%d\n',sum(match_r),R);
        fprintf(fid,'first bootstrap rep with trace: %d\n',r);
    end
    means = mean(subdata,2);
    stds = std(subdata,0,2);
    medians = median(subdata,2);
    ci90 = CI_pct(subdata',90);
    ci95 = CI_pct(subdata',95);
    if options.verbose
        fprintf(fid,'median resnorm1: %.4g\n',median([subfits.resnorm1]));
        fprintf(fid,'\n');
        fprintf(fid,'  mean +/- std      median       90%% CI            95%% CI\n');
        for p = 2:5
            fprintf(fid,'%.4f +/- %.4f   %.4f   (%.4f-%.4f)   (%.4f-%.4f)\n',...
                means(p),stds(p),medians(p),ci90(1,p),ci90(2,p),ci95(1,p),ci95(2,p));
        end
    end
    
    %%%%% tex output for table (in drift units if desired) %%%%%
    
    if drift_units
        edge_len_med1 = median(2*[subfits.edge_len1]./[subfits.h1]);
        edge_len_med2 = median(2*[subfits.edge_len2]./[subfits.h2]);
        subdata = ...
            [subfits.alpha
             [subfits.r1] * edge_len_med1
             [subfits.r2] * edge_len_med2
             2*[subfits.c] ./ ([subfits.h_mix1] + 2*[subfits.c])];
    else
        edge_len_med1 = median([subfits.edge_len1]);
        edge_len_med2 = median([subfits.edge_len2]);
        subdata = ...
            [subfits.alpha
             [subfits.r1] * edge_len_med1
             [subfits.r2] * edge_len_med2
             [subfits.c]];
    end
    
    ci95 = CI_pct(subdata',95);
    
    if options.branch_sets
        branch_name1 = fits(r).set1;
        branch_name2 = fits(r).set2;
    else
        branch_name1 = fits(r).trace1;
        branch_name2 = fits(r).trace2;
    end
    texstr = sprintf('%-16s & %-30s & %4d &  %8.3g  &  %5.3f-%5.3f  &  %5.3f-%5.3f / %5.3f  &  %5.3f-%5.3f / %5.3f  &  %5.3f-%5.3f',...
        admixed_name1,[branch_name1 ' + ' branch_name2],sum(match_r),...
        median([subfits.resnorm1]),...
        ci95(1,1),ci95(2,1),...
        ci95(1,2),ci95(2,2),edge_len_med1,...
        ci95(1,3),ci95(2,3),edge_len_med2,...
        ci95(1,4),ci95(2,4));
    tex_single = [tex_single {texstr}];
end

if ~isempty(admixed_name2)
    
    if options.verbose
        fprintf(fid,'---- second admixture ----\n');
        fprintf(fid,'%s\n',admixed_name2);
    end
    
    agree_trace3 = true(R,1);
    for r = 2:R
        if ~all(fits(r).split3 == fits(1).split3)
            agree_trace3(r) = false;
        end
    end
    
    if options.verbose
        if all(agree_trace3)
            fprintf(fid,'trace: %s\n',fits(1).trace3);
        else
            fprintf(fid,'*** traces do not agree! ***\n');
            for r = 1:R, fprintf(fid,'%-9s ',crop(fits(r).trace3,9)); end; fprintf(fid,'\n');
        end
        fprintf(fid,'%.3e ',[fits.resnorm12]); fprintf(fid,'\n');
        fprintf(fid,'%.4f     ',[fits.alpha_refit]); fprintf(fid,'\n');
        fprintf(fid,'%.4f     ',[fits.alpha2]); fprintf(fid,'\n');
        fprintf(fid,'%.4f     ',[fits.r1_refit]); fprintf(fid,'\n');
        fprintf(fid,'%.4f     ',[fits.r2_refit]); fprintf(fid,'\n');
        fprintf(fid,'%.4f     ',[fits.r3]); fprintf(fid,'\n');
        fprintf(fid,'%.4f     ',[fits.c11]); fprintf(fid,'\n');
        fprintf(fid,'%.4f     ',[fits.c12]); fprintf(fid,'\n');
        fprintf(fid,'%.4f     ',[fits.c2]); fprintf(fid,'\n');
    end
    
    used = ~agree_trace12; % only analyze those that agree on first admixture

    for r = 1:R
        if used(r), continue, end
        match_r = false(R,1);
        match_r(r) = true;
        for r2 = r+1:R
            if agree_trace12(r2) && all(fits(r2).split3 == fits(r).split3)
                match_r(r2) = true;
            end
        end
        used = used | match_r;

        if options.verbose
            fprintf(fid,'\n');
            fprintf(fid,'%s\n',admixed_name2);
            fprintf(fid,'trace: %s\n',fits(r).trace3);
            fprintf(fid,'# with trace: %d/%d\n',sum(match_r),sum(agree_trace12));
            fprintf(fid,'first bootstrap rep with trace: %d\n',r);
        end
        subfits = fits(match_r);
        subdata = [subfits.resnorm12; subfits.alpha_refit; subfits.alpha2; subfits.r1_refit; subfits.r2_refit; subfits.r3; subfits.c11; subfits.c12; subfits.c2];
        means = mean(subdata,2);
        stds = std(subdata,0,2);
        medians = median(subdata,2);
        ci90 = CI_pct(subdata',90);
        ci95 = CI_pct(subdata',95);
        if options.verbose
            fprintf(fid,'median resnorm12: %.4g\n',median([subfits.resnorm12]));
            fprintf(fid,'median resnorm12-resnorm1: %.4g\n',median([subfits.resnorm12]-[subfits.resnorm1]));
            fprintf(fid,'\n');
            fprintf(fid,'  mean +/- std      median       90%% CI            95%% CI\n');
            for p = 2:9
                fprintf(fid,'%.4f +/- %.4f   %.4f   (%.4f-%.4f)   (%.4f-%.4f)\n',...
                    means(p),stds(p),medians(p),ci90(1,p),ci90(2,p),ci95(1,p),ci95(2,p));
            end
        end
        
        %%%%% tex output for table (in drift units if desired) %%%%%
        
        if drift_units
            edge_len_med3 = median(2*[subfits.edge_len3]./[subfits.h3]);
            subdata = ...
                [subfits.alpha2
                 [subfits.r3] * edge_len_med3
                 2*[subfits.c11] ./ ([subfits.h_mix1] + 2*[subfits.c11] + 2*[subfits.c12])
                 2*[subfits.c12] ./ ([subfits.h_mix1] + 2*[subfits.c12])
                 2*[subfits.c2] ./ ([subfits.h_mix2] + 2*[subfits.c2])];
        else
            edge_len_med3 = median([subfits.edge_len3]);
            subdata = ...
                [subfits.alpha2
                 [subfits.r3] * edge_len_med3
                 [subfits.c11]
                 [subfits.c12]
                 [subfits.c2]];
        end
                
        ci95 = CI_pct(subdata',95);
        
        if options.branch_sets
            branch_name3 = fits(r).set3;
        else
            branch_name3 = fits(r).trace3;
        end
        texstr = sprintf('%-16s & %-30s & %4d &  %8.3g  &  %5.3f-%5.3f  &  %5.3f-%5.3f / %5.3f  &  %5.3f-%5.3f  &  %5.3f-%5.3f  &  %5.3f-%5.3f',...
            admixed_name2,[admixed_name1 ' + ' branch_name3],sum(match_r),...
            median([subfits.resnorm12]-[subfits.resnorm1]),...
            ci95(1,1),ci95(2,1),...
            ci95(1,2),ci95(2,2),edge_len_med3,...
            ci95(1,3),ci95(2,3),...
            ci95(1,4),ci95(2,4),...
            ci95(1,5),ci95(2,5));
        tex_double = [tex_double {texstr}];
    end
end

tex_single = strrep(tex_single,'  NaN','  n/a');
tex_double = strrep(tex_double,'  NaN','  n/a');
mix1_grep_tag = ''; %'   &MIX1';
mix2_grep_tag = ''; %'   &MIX2';

fprintf(fid,'\n');
fprintf(fid,'%-16s & %-30s & %4s &  %-8s  &  %-11s  &  %-19s  &  %-19s  &  %-11s\n',...
    'AdmixedPop','Branch1 + Branch2','\#','Resnorm','$\alpha$','Branch1Loc','Branch2Loc','MixedDrift');
fprintf(fid,'%s\n',repmat('-',1,156));
for texstr = tex_single, fprintf(fid,'%-145s%s\n',texstr{:},mix1_grep_tag); end
fprintf(fid,'%s%s\n',repmat(' ',1,156),mix1_grep_tag);

if ~isempty(admixed_name2)
    fprintf(fid,'\n');
    fprintf(fid,'%-16s & %-30s & %4s &  %-8s  &  %-11s  &  %-19s  &  %-12s &  %-12s &  %-11s\n',...
        'AdmixedPop2','Mix1 + Branch3','\#','Resnorm2','$\alpha_2$','Branch3Loc','MixedDrift1A','FinalDrift1B','MixedDrift2');
    fprintf(fid,'%s\n',repmat('-',1,156));
    for texstr = tex_double, fprintf(fid,'%-145s%s\n',texstr{:},mix2_grep_tag); end
    fprintf(fid,'%s%s\n',repmat(' ',1,156),mix2_grep_tag);
end

if fid ~= 1
    fclose(fid);
end

end

function substr = crop(str,len)
substr = str(1:min(length(str),len));
end

% returns 1 if equal, -1 if swapped, 0 if not equal
function cmp_code = compare_split_pairs(split1ref,split2ref,split1,split2)
if all(split1ref==split1) && all(split2ref==split2)
    cmp_code = 1;
elseif all(split1ref==split2) && all(split2ref==split1)
    cmp_code = -1;
else
    cmp_code = 0;
end
end

function swap_fit = swap12(fit) % swap branches 1 and 2 of (first) mix

swap_fit = fit;

swap_fit.trace1 = fit.trace2;
swap_fit.trace2 = fit.trace1;
swap_fit.split1 = fit.split2;
swap_fit.split2 = fit.split1;
swap_fit.set1 = fit.set2;
swap_fit.set2 = fit.set1;
swap_fit.alpha = 1-fit.alpha;
swap_fit.r1 = fit.r2;
swap_fit.r2 = fit.r1;
swap_fit.h1 = fit.h2;
swap_fit.h2 = fit.h1;
swap_fit.edge_len1 = fit.edge_len2;
swap_fit.edge_len2 = fit.edge_len1;

if isfield(fit,'trace3')
    swap_fit.alpha_refit = 1-fit.alpha_refit;
    swap_fit.r1_refit = fit.r2_refit;
    swap_fit.r2_refit = fit.r1_refit;
end

end

% computes basic confidence interval using percentiles
function ci = CI_pct(x,pct)

if size(x,1) == 1
    ci = [x; nan(size(x))];
else
    alpha = 1-pct/100;
    ci = [prctile(x,100*alpha/2); prctile(x,100*(1-alpha/2))];
end

end
